<!DOCTYPE html>
<html lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="爱吃鱼的呆先生">



<meta name="description" content="Java反射机制Java反射机制概述关于反射的理解Reflection（反射)是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法 加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java反射机制">
<meta property="og:url" content="http://yoursite.com/2020/03/06/3Java高级/Java反射机制/index.html">
<meta property="og:site_name" content="爱吃鱼的呆先生">
<meta property="og:description" content="Java反射机制Java反射机制概述关于反射的理解Reflection（反射)是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法 加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2020/03/06/3Java高级/Java反射机制/image-20200219141442814.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/3Java高级/Java反射机制/image-20200219180654962.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/3Java高级/Java反射机制/wps12.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/3Java高级/Java反射机制/wps13.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/3Java高级/Java反射机制/wps14.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/3Java高级/Java反射机制/wps15.png">
<meta property="og:updated_time" content="2020-03-06T09:38:24.830Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java反射机制">
<meta name="twitter:description" content="Java反射机制Java反射机制概述关于反射的理解Reflection（反射)是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法 加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像">
<meta name="twitter:image" content="http://yoursite.com/2020/03/06/3Java高级/Java反射机制/image-20200219141442814.png">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="爱吃鱼的呆先生" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Java反射机制 | 爱吃鱼的呆先生</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: false
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">爱吃鱼的呆先生</a></h1>
        </hgroup>

        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云与分类</a></li>
                        
                            <li><a href="/pdfdocuments/">pdf文档笔记</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="https://mail.163.com/" title="Email"></a>
                            
                                <a class="fa CSDN" href="https://www.csdn.net/" title="CSDN"></a>
                            
                                <a class="fa Coding" href="https://coding.net/login" title="Coding"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElasticSearch/">ElasticSearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Idea/">Idea</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Json/">Json</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Logstash/">Logstash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatisPlus/">MyBatisPlus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL基础/">MySQL基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Cloud/">Spring Cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringDataJPA/">SpringDataJPA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/String/">String</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zookeeper/">Zookeeper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/easyExcel/">easyExcel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://mybatis.org/mybatis-3/zh/index.html">Mybatis</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://spring.io/projects/spring-framework#overview">Spring</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://spring.io/projects/spring-boot">SpringBoot</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">真正的大师永远保持一颗学徒的心</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">爱吃鱼的呆先生</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">爱吃鱼的呆先生</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云与分类</a></li>
                
                    <li><a href="/pdfdocuments/">pdf文档笔记</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="https://mail.163.com/" title="Email"></a>
                            
                                <a class="fa CSDN" target="_blank" href="https://www.csdn.net/" title="CSDN"></a>
                            
                                <a class="fa Coding" target="_blank" href="https://coding.net/login" title="Coding"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-3Java高级/Java反射机制" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/06/3Java高级/Java反射机制/" class="article-date">
      <time datetime="2020-03-06T09:35:24.932Z" itemprop="datePublished">2020-03-06</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java反射机制
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java高级/">Java高级</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="Java反射机制"><a href="#Java反射机制" class="headerlink" title="Java反射机制"></a>Java反射机制</h1><h2 id="Java反射机制概述"><a href="#Java反射机制概述" class="headerlink" title="Java反射机制概述"></a>Java反射机制概述</h2><h3 id="关于反射的理解"><a href="#关于反射的理解" class="headerlink" title="关于反射的理解"></a>关于反射的理解</h3><p>Reflection（反射)是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法</p>
<p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射</p>
<p>框架 = 反射 + 注解 + 设计模式</p>
<img src="/2020/03/06/3Java高级/Java反射机制/image-20200219141442814.png" alt="image-20200219141442814" style="zoom:50%;">

<h3 id="体会反射机制的“动态性”"><a href="#体会反射机制的“动态性”" class="headerlink" title="体会反射机制的“动态性”"></a>体会反射机制的“动态性”</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//体会反射的动态性</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);<span class="comment">//0,1,2</span></span><br><span class="line">        String classPath = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">switch</span>(num)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                classPath = <span class="string">"java.util.Date"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                classPath = <span class="string">"java.lang.Object"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                classPath = <span class="string">"com.atguigu.java.Person"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object obj = getInstance(classPath);</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建一个指定类的对象。</span></span><br><span class="line"><span class="comment">classPath:指定类的全类名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(String classPath)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clazz =  Class.forName(classPath);</span><br><span class="line">    <span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反射机制能提供的功能"><a href="#反射机制能提供的功能" class="headerlink" title="反射机制能提供的功能"></a>反射机制能提供的功能</h3><p>在运行时判断任意一个对象所属的类</p>
<p>在运行时构造任意一个类的对象</p>
<p>在运行时判断任意一个类所具有的成员变量和方法</p>
<p>在运行时获取泛型信息</p>
<p>在运行时调用任意一个对象的成员变量和方法</p>
<p>在运行时处理注解</p>
<p>生成动态代理</p>
<h3 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h3><p>java.lang.Class:反射的源头</p>
<p>java.lang.reflect.Method</p>
<p>java.lang.reflect.Field</p>
<p>java.lang.reflect.Constructor</p>
<p>….</p>
<h2 id="Class类的理解与获取Class的实例"><a href="#Class类的理解与获取Class的实例" class="headerlink" title="Class类的理解与获取Class的实例"></a>Class类的理解与获取Class的实例</h2><h3 id="Class类的理解"><a href="#Class类的理解" class="headerlink" title="Class类的理解"></a>Class类的理解</h3><p>类的加载过程<br>程序经过javac.exe命令以后，会生成一个或多个字节码文件(.class结尾)。接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，此运行时类，就作为Class的一个实例</p>
<p>换句话说，Class的实例就对应着一个运行时类</p>
<p>加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式来获取此运行时类</p>
<p>在Object类中定义了以下的方法，此方法将被所有子类继承：<code>public final Class getClass()</code></p>
<p>以上的方法返回值的类型是一个Class类，此类是Java反射的源头，实际上所谓反射从程序的运行结果来看也很好理解，即：可以通过对象反射求出类的名称</p>
<h3 id="获取Class实例的几种方式"><a href="#获取Class实例的几种方式" class="headerlink" title="获取Class实例的几种方式"></a>获取Class实例的几种方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：调用运行时类的属性：.class</span></span><br><span class="line">Class clazz1 = Person.class;</span><br><span class="line">System.out.println(clazz1);</span><br><span class="line"><span class="comment">//方式二：通过运行时类的对象,调用getClass()</span></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">Class clazz2 = p1.getClass();</span><br><span class="line">System.out.println(clazz2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式三：调用Class的静态方法：forName(String classPath)</span></span><br><span class="line">Class clazz3 = Class.forName(<span class="string">"com.atguigu.java.Person"</span>);</span><br><span class="line"><span class="comment">//clazz3 = Class.forName("java.lang.String");</span></span><br><span class="line">System.out.println(clazz3);</span><br><span class="line"></span><br><span class="line">System.out.println(clazz1 == clazz2);</span><br><span class="line">System.out.println(clazz1 == clazz3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式四：使用类的加载器：ClassLoader  (了解)</span></span><br><span class="line">ClassLoader classLoader = ReflectionTest.class.getClassLoader();</span><br><span class="line">Class clazz4 = classLoader.loadClass(<span class="string">"com.atguigu.java.Person"</span>);</span><br><span class="line">System.out.println(clazz4);</span><br><span class="line"></span><br><span class="line">System.out.println(clazz1 == clazz4);</span><br></pre></td></tr></table></figure>

<h3 id="Class类的常用方法"><a href="#Class类的常用方法" class="headerlink" title="Class类的常用方法"></a>Class类的常用方法</h3><p><img src="/2020/03/06/3Java高级/Java反射机制/image-20200219180654962.png" alt="image-20200219180654962"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>创建类的对象的方式</p>
<p>方式一：new + 构造器</p>
<p>方式二：要创建Xxx类的对象，可以考虑：Xxx、Xxxs、XxxFactory、XxxBuilder类中查看是否有静态方法的存在。可以调用其静态方法，创建Xxx对象</p>
<p>方式三：通过反射</p>
<h3 id="哪些类型可以有Class对象"><a href="#哪些类型可以有Class对象" class="headerlink" title="哪些类型可以有Class对象"></a>哪些类型可以有Class对象</h3><p>class：外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类<br>interface：接口<br>[]：数组<br>enum：枚举<br>annotation：注解@interface<br>primitive type：基本数据类型<br>void</p>
<h2 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h2><h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><img src="/2020/03/06/3Java高级/Java反射机制/wps12.png" alt="img" style="zoom: 67%;">

<h3 id="类的加载器的作用"><a href="#类的加载器的作用" class="headerlink" title="类的加载器的作用"></a>类的加载器的作用</h3><p><img src="/2020/03/06/3Java高级/Java反射机制/wps13.png" alt="img"></p>
<h3 id="什么时候会发生类初始化"><a href="#什么时候会发生类初始化" class="headerlink" title="什么时候会发生类初始化"></a>什么时候会发生类初始化</h3><h4 id="类的主动引用（一定会发生类的初始化）"><a href="#类的主动引用（一定会发生类的初始化）" class="headerlink" title="类的主动引用（一定会发生类的初始化）"></a>类的主动引用（一定会发生类的初始化）</h4><ul>
<li><p>当虚拟机启动，先初始化main方法所在的类</p>
</li>
<li><p>new一个类的对象</p>
</li>
<li><p>调用类的静态成员（除了final常量）和静态方法</p>
</li>
<li><p>使用java.lang.reflect包的方法对类进行反射调用</p>
</li>
<li><p>当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类</p>
</li>
</ul>
<h4 id="类的被动引用（不会发生类的初始化）"><a href="#类的被动引用（不会发生类的初始化）" class="headerlink" title="类的被动引用（不会发生类的初始化）"></a>类的被动引用（不会发生类的初始化）</h4><ul>
<li><p>当访问一个静态域时，只有真正声明这个域的类才会被初始化，当通过子类引用父类的静态变量，不会导致子类初始化</p>
</li>
<li><p>通过数组定义类引用，不会触发此类的初始化</p>
</li>
<li><p>引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）</p>
</li>
</ul>
<h3 id="类的加载器的分类"><a href="#类的加载器的分类" class="headerlink" title="类的加载器的分类"></a>类的加载器的分类</h3><p><img src="/2020/03/06/3Java高级/Java反射机制/wps14.png" alt="img"></p>
<h3 id="Java类编译运行的执行的流程"><a href="#Java类编译运行的执行的流程" class="headerlink" title="Java类编译运行的执行的流程"></a>Java类编译运行的执行的流程</h3><p><img src="/2020/03/06/3Java高级/Java反射机制/wps15.png" alt="img"></p>
<h3 id="使用Classloader加载src目录下的配置文件"><a href="#使用Classloader加载src目录下的配置文件" class="headerlink" title="使用Classloader加载src目录下的配置文件"></a>使用Classloader加载src目录下的配置文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    Properties pros =  <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="comment">//此时的文件默认在当前的module下。</span></span><br><span class="line">    <span class="comment">//读取配置文件的方式一：</span></span><br><span class="line">    <span class="comment">//FileInputStream fis = new FileInputStream("jdbc.properties");</span></span><br><span class="line">    <span class="comment">//FileInputStream fis = new FileInputStream("src\\jdbc1.properties");</span></span><br><span class="line">    <span class="comment">//pros.load(fis);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取配置文件的方式二：使用ClassLoader</span></span><br><span class="line">    <span class="comment">//配置文件默认识别为：当前module的src下</span></span><br><span class="line">    <span class="comment">//这里使用系统类加载器</span></span><br><span class="line">    ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();</span><br><span class="line">    InputStream is = classLoader.getResourceAsStream(<span class="string">"jdbc1.properties"</span>);</span><br><span class="line">    pros.load(is);</span><br><span class="line"></span><br><span class="line">    String user = pros.getProperty(<span class="string">"user"</span>);</span><br><span class="line">    String password = pros.getProperty(<span class="string">"password"</span>);</span><br><span class="line">    System.out.println(<span class="string">"user = "</span> + user + <span class="string">",password = "</span> + password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反射应用一"><a href="#反射应用一" class="headerlink" title="反射应用一"></a>反射应用一</h2><p>创建运行时类的对象</p>
<h3 id="代码举例"><a href="#代码举例" class="headerlink" title="代码举例"></a>代码举例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewInstanceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">        Person person = personClass.newInstance();</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>newInstance()</p>
<p>调用此方法，创建对应的运行时类的对象。内部调用了运行时类的空参的构造器</p>
<p>要想此方法正常的创建运行时类的对象，要求：</p>
<ol>
<li><p>运行时类必须提供空参的构造器</p>
</li>
<li><p>空参的构造器的访问权限得够。通常，设置为public</p>
</li>
</ol>
<p>在javabean中要求提供一个public的空参构造器。原因：</p>
<ol>
<li><p>便于通过反射，创建运行时类的对象</p>
</li>
<li><p>便于子类继承此运行时类时，默认调用super()时，保证父类此构造器</p>
</li>
</ol>
<h2 id="反射应用二"><a href="#反射应用二" class="headerlink" title="反射应用二"></a>反射应用二</h2><p>获取运行时类的完整结构</p>
<p>我们可以通过反射，获取对应的运行时类中所有的属性、方法、构造器、父类、接口、父类的泛型、包、注解、异常等</p>
<h3 id="典型代码"><a href="#典型代码" class="headerlink" title="典型代码"></a>典型代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取属性结构</span></span><br><span class="line">    <span class="comment">//getFields():获取当前运行时类及其父类中声明为public访问权限的属性</span></span><br><span class="line">    Field[] fields = clazz.getFields();</span><br><span class="line">    <span class="keyword">for</span>(Field f : fields)&#123;</span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getDeclaredFields():获取当前运行时类中声明的所属性。（不包含父类中声明的属性）</span></span><br><span class="line">    Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span>(Field f : declaredFields)&#123;</span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getMethods():获取当前运行时类及其所父类中声明为public权限的方法</span></span><br><span class="line">    Method[] methods = clazz.getMethods();</span><br><span class="line">    <span class="keyword">for</span>(Method m : methods)&#123;</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">//getDeclaredMethods():获取当前运行时类中声明的所方法。（不包含父类中声明的方法）</span></span><br><span class="line">    Method[] declaredMethods = clazz.getDeclaredMethods();</span><br><span class="line">    <span class="keyword">for</span>(Method m : declaredMethods)&#123;</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取构造器结构</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">    <span class="comment">//getConstructors():获取当前运行时类中声明为public的构造器</span></span><br><span class="line">    Constructor[] constructors = clazz.getConstructors();</span><br><span class="line">    <span class="keyword">for</span>(Constructor c : constructors)&#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">//getDeclaredConstructors():获取当前运行时类中声明的所的构造器</span></span><br><span class="line">    Constructor[] declaredConstructors = clazz.getDeclaredConstructors();</span><br><span class="line">    <span class="keyword">for</span>(Constructor c : declaredConstructors)&#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取运行时类的父类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line"></span><br><span class="line">    Class superclass = clazz.getSuperclass();</span><br><span class="line">    System.out.println(superclass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取运行时类的带泛型的父类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line"></span><br><span class="line">    Type genericSuperclass = clazz.getGenericSuperclass();</span><br><span class="line">    System.out.println(genericSuperclass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取运行时类的带泛型的父类的泛型</span></span><br><span class="line"><span class="comment">代码：逻辑性代码  vs 功能性代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line"></span><br><span class="line">    Type genericSuperclass = clazz.getGenericSuperclass();</span><br><span class="line">    ParameterizedType paramType = (ParameterizedType) genericSuperclass;</span><br><span class="line">    <span class="comment">//获取泛型类型</span></span><br><span class="line">    Type[] actualTypeArguments = paramType.getActualTypeArguments();</span><br><span class="line">    <span class="comment">//System.out.println(actualTypeArguments[0].getTypeName());</span></span><br><span class="line">    <span class="comment">//或者如下方法</span></span><br><span class="line">    System.out.println(((Class)actualTypeArguments[<span class="number">0</span>]).getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取运行时类实现的接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line"></span><br><span class="line">    Class[] interfaces = clazz.getInterfaces();</span><br><span class="line">    <span class="keyword">for</span>(Class c : interfaces)&#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">//获取运行时类的父类实现的接口</span></span><br><span class="line">    Class[] interfaces1 = clazz.getSuperclass().getInterfaces();</span><br><span class="line">    <span class="keyword">for</span>(Class c : interfaces1)&#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取运行时类所在的包</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line"></span><br><span class="line">    Package pack = clazz.getPackage();</span><br><span class="line">    System.out.println(pack);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取运行时类声明的注解</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line"></span><br><span class="line">    Annotation[] annotations = clazz.getAnnotations();</span><br><span class="line">    <span class="keyword">for</span>(Annotation annos : annotations)&#123;</span><br><span class="line">        System.out.println(annos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反射应用三"><a href="#反射应用三" class="headerlink" title="反射应用三"></a>反射应用三</h2><p>调用指定的属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testField1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建运行时类的对象</span></span><br><span class="line">    Person p = (Person) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. getDeclaredField(String fieldName):获取运行时类中指定变量名的属性</span></span><br><span class="line">    Field name = clazz.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.保证当前属性是可访问的</span></span><br><span class="line">    name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//3.获取、设置指定对象的此属性值</span></span><br><span class="line">    name.set(p,<span class="string">"Tom"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(name.get(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用指定的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建运行时类的对象</span></span><br><span class="line">    Person p = (Person) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.获取指定的某个方法</span></span><br><span class="line"><span class="comment">    getDeclaredMethod():参数1 ：指明获取的方法的名称  参数2：指明获取的方法的形参列表</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Method show = clazz.getDeclaredMethod(<span class="string">"show"</span>, String.class);</span><br><span class="line">    <span class="comment">//2.保证当前方法是可访问的</span></span><br><span class="line">    show.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    3. 调用方法的invoke():参数1：方法的调用者  参数2：给方法形参赋值的实参</span></span><br><span class="line"><span class="comment">    invoke()的返回值即为对应类中调用的方法的返回值。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Object returnValue = show.invoke(p,<span class="string">"CHN"</span>); <span class="comment">//String nation = p.show("CHN");</span></span><br><span class="line">    System.out.println(returnValue);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"*************如何调用静态方法*****************"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private static void showDesc()</span></span><br><span class="line"></span><br><span class="line">    Method showDesc = clazz.getDeclaredMethod(<span class="string">"showDesc"</span>);</span><br><span class="line">    showDesc.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//如果调用的运行时类中的方法没返回值，则此invoke()返回null</span></span><br><span class="line">    <span class="comment">//Object returnVal = showDesc.invoke(null);</span></span><br><span class="line">    Object returnVal = showDesc.invoke(Person.class);</span><br><span class="line">    System.out.println(returnVal);<span class="comment">//null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用指定的构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConstructor</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//private Person(String name)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.获取指定的构造器</span></span><br><span class="line"><span class="comment">    getDeclaredConstructor():参数：指明构造器的参数列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    Constructor constructor = clazz.getDeclaredConstructor(String.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.保证此构造器是可访问的</span></span><br><span class="line">    constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.调用此构造器创建运行时类的对象</span></span><br><span class="line">    Person per = (Person) constructor.newInstance(<span class="string">"Tom"</span>);</span><br><span class="line">    System.out.println(per);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反射应用四"><a href="#反射应用四" class="headerlink" title="反射应用四"></a>反射应用四</h2><p>动态代理</p>
<h3 id="代理模式的原理"><a href="#代理模式的原理" class="headerlink" title="代理模式的原理"></a>代理模式的原理</h3><p>使用一个代理将对象包装起来, 然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上</p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现Runnable接口的方法创建多线程</span></span><br><span class="line">Class MyThread implements Runnable&#123;&#125; <span class="comment">//相当于被代理类</span></span><br><span class="line">Class Thread implements Runnable&#123;&#125; <span class="comment">//相当于代理类</span></span><br><span class="line">main()&#123;</span><br><span class="line">    MyThread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(t);</span><br><span class="line">    thread.start();<span class="comment">//启动线程；调用线程的run()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态代理的缺点"><a href="#静态代理的缺点" class="headerlink" title="静态代理的缺点"></a>静态代理的缺点</h3><p>① 代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。</p>
<p>② 每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。</p>
<h3 id="动态代理的特点"><a href="#动态代理的特点" class="headerlink" title="动态代理的特点"></a>动态代理的特点</h3><p>动态代理是指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对<br>象</p>
<h3 id="动态代理的实现"><a href="#动态代理的实现" class="headerlink" title="动态代理的实现"></a>动态代理的实现</h3><h4 id="需要解决的两个主要问题"><a href="#需要解决的两个主要问题" class="headerlink" title="需要解决的两个主要问题"></a>需要解决的两个主要问题</h4><p>问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象。 （通过</p>
<p>Proxy.newProxyInstance()实现）</p>
<p>问题二：当通过代理类的对象调用方法a时，如何动态的去调用被代理类中的同名方法a。(通过</p>
<p>InvocationHandler接口的实现类及其方法invoke())</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 动态代理的举例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Human</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getBelief</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span> <span class="keyword">implements</span> <span class="title">Human</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBelief</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"I believe I can fly!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我喜欢吃"</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HumanUtil</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"====================通用方法一===================="</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"====================通用方法二===================="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span></span>&#123;</span><br><span class="line">    <span class="comment">//调用此方法，返回一个代理类的对象。解决问题一</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxyInstance</span><span class="params">(Object obj)</span></span>&#123;<span class="comment">//obj:被代理类的对象</span></span><br><span class="line">        MyInvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler();</span><br><span class="line"></span><br><span class="line">        handler.bind(obj);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object obj;<span class="comment">//需要使用被代理类的对象进行赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke()</span></span><br><span class="line">    <span class="comment">//将被代理类要执行的方法a的功能就声明在invoke()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        HumanUtil util = <span class="keyword">new</span> HumanUtil();</span><br><span class="line">        util.method1();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//method:即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法</span></span><br><span class="line">        <span class="comment">//obj:被代理类的对象</span></span><br><span class="line">        Object returnValue = method.invoke(obj,args);</span><br><span class="line"></span><br><span class="line">        util.method2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上述方法的返回值就作为当前类中的invoke()的返回值。</span></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SuperMan superMan = <span class="keyword">new</span> SuperMan();</span><br><span class="line">        <span class="comment">//proxyInstance:代理类的对象</span></span><br><span class="line">        Human proxyInstance = (Human) ProxyFactory.getProxyInstance(superMan);</span><br><span class="line">        <span class="comment">//当通过代理类对象调用方法时，会自动的调用被代理类中同名的方法</span></span><br><span class="line">        String belief = proxyInstance.getBelief();</span><br><span class="line">        System.out.println(belief);</span><br><span class="line">        proxyInstance.eat(<span class="string">"四川麻辣烫"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"*****************************"</span>);</span><br><span class="line"></span><br><span class="line">        NikeClothFactory nikeClothFactory = <span class="keyword">new</span> NikeClothFactory();</span><br><span class="line"></span><br><span class="line">        ClothFactory proxyClothFactory = (ClothFactory) ProxyFactory.getProxyInstance(nikeClothFactory);</span><br><span class="line"></span><br><span class="line">        proxyClothFactory.produceCloth();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>体会：反射的动态性</p>
<h2 id="注"><a href="#注" class="headerlink" title="注"></a>注</h2><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>反射机制是 Java 语言提供的一种基础功能，赋予程序在运行时自省（introspect）的能力。简单来说就是通过反射，可以在运行期间获取、检测和调用对象的属性和方法。</p>
<h4 id="反射的使用场景"><a href="#反射的使用场景" class="headerlink" title="反射的使用场景"></a>反射的使用场景</h4><p>在现实中反射的使用场景有很多，比如以下几个。</p>
<p><strong>使用场景一</strong>：编程工具 IDEA 或 Eclipse 等，在写代码时会有代码（属性或方法名）提示，就是因为使用了反射。</p>
<p><strong>使用场景二</strong>：很多知名的框架，为了让程序更优雅更简洁，也会使用到反射。</p>
<p>例如，<strong>Spring</strong> 可以通过配置来加载不同的类，调用不同的方法，代码如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"person"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.spring.beans.Person"</span> init-method=<span class="string">"initPerson"</span>&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>例如，<strong>MyBatis</strong> 在 Mapper 使用外部类的 SQL 构建查询时，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SelectProvider</span>(type = PersonSql.class, method = <span class="string">"getListSql"</span>)</span><br><span class="line"><span class="function">List&lt;Person&gt; <span class="title">getList</span><span class="params">()</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonSql</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getListSql</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="keyword">new</span> SQL() &#123;&#123;</span><br><span class="line">            SELECT(<span class="string">"*"</span>);</span><br><span class="line">            FROM(<span class="string">"person"</span>);</span><br><span class="line">        &#125;&#125;.toString();</span><br><span class="line">        <span class="keyword">return</span> sql;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用场景三</strong>：数据库连接池，也会使用反射调用不同类型的数据库驱动，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String url = <span class="string">"jdbc:mysql://127.0.0.1:3306/mydb"</span>;</span><br><span class="line">String username = <span class="string">"root"</span>;</span><br><span class="line">String password = <span class="string">"root"</span>;</span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">Connection connection = DriverManager.getConnection(url, username, password);</span><br></pre></td></tr></table></figure>

<p>当然反射还有其他很多类似的使用场景，这里就不一一列举，读者可以举一反三，想想在平常的开发中，还有哪些使用了反射功能的场景。</p>
<h4 id="反射的基本使用"><a href="#反射的基本使用" class="headerlink" title="反射的基本使用"></a>反射的基本使用</h4><p>下来我们通过反射调用类中的某个方法，来学习反射的基本使用。</p>
<p>使用反射调用类中的方法，分为三种情况：</p>
<ul>
<li>调用静态方法</li>
<li>调用公共方法</li>
<li>调用私有方法</li>
</ul>
<p>假设有一个实体类 MyReflect 包含了以上三种方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.interview.chapter4;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReflect</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Static Method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 公共方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publicMd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Public Method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 私有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">privateMd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Private Method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面分别来看，使用反射如何调用以上三种类型的方法。</p>
<h5 id="①-反射调用静态方法"><a href="#①-反射调用静态方法" class="headerlink" title="① 反射调用静态方法"></a>① <strong>反射调用静态方法</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class myClass = Class.forName(<span class="string">"com.interview.chapter4.MyReflect"</span>);</span><br><span class="line">Method method = myClass.getMethod(<span class="string">"staticMd"</span>);</span><br><span class="line">method.invoke(myClass);</span><br></pre></td></tr></table></figure>

<h5 id="②-反射调用公共方法"><a href="#②-反射调用公共方法" class="headerlink" title="② 反射调用公共方法"></a>② <strong>反射调用公共方法</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class myClass = Class.forName(<span class="string">"com.interview.chapter4.MyReflect"</span>);</span><br><span class="line"><span class="comment">// 创建实例对象（相当于 new ）</span></span><br><span class="line">Object instance = myClass.newInstance();</span><br><span class="line">Method method2 = myClass.getMethod(<span class="string">"publicMd"</span>);</span><br><span class="line">method2.invoke(instance);</span><br></pre></td></tr></table></figure>

<h5 id="③-反射调用私有方法"><a href="#③-反射调用私有方法" class="headerlink" title="③ 反射调用私有方法"></a>③ <strong>反射调用私有方法</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class myClass = Class.forName(<span class="string">"com.interview.chapter4.MyReflect"</span>);</span><br><span class="line"><span class="comment">// 创建实例对象（相当于 new ）</span></span><br><span class="line">Object object = myClass.newInstance();</span><br><span class="line">Method method3 = myClass.getDeclaredMethod(<span class="string">"privateMd"</span>);</span><br><span class="line">method3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method3.invoke(object);</span><br></pre></td></tr></table></figure>

<h4 id="反射使用总结"><a href="#反射使用总结" class="headerlink" title="反射使用总结"></a>反射使用总结</h4><p>反射获取调用类可以通过 Class.forName()，反射获取类实例要通过 newInstance()，相当于 new  一个新对象，反射获取方法要通过 getMethod()，获取到类方法之后使用 invoke()   对类方法进行调用。如果是类方法为私有方法的话，则需要通过 setAccessible(true)  来修改方法的访问限制，以上的这些操作就是反射的基本使用。</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>动态代理可以理解为，本来应该自己做的事情，却交给别人代为处理，这个过程就叫做动态代理。</p>
<h4 id="动态代理的使用场景"><a href="#动态代理的使用场景" class="headerlink" title="动态代理的使用场景"></a>动态代理的使用场景</h4><p>动态代理被广为人知的使用场景是 Spring 中的面向切面编程（AOP）。例如，依赖注入 @Autowired 和事务注解 @Transactional 等，都是利用动态代理实现的。</p>
<p>动态代理还可以封装一些 RPC 调用，也可以通过代理实现一个全局拦截器等。</p>
<h4 id="动态代理和反射的关系"><a href="#动态代理和反射的关系" class="headerlink" title="动态代理和反射的关系"></a>动态代理和反射的关系</h4><p>JDK 原生提供的动态代理就是通过反射实现的，但动态代理的实现方式还可以是 ASM（一个短小精悍的字节码操作框架）、cglib（基于 ASM）等，并不局限于反射。</p>
<p>下面我们分别来看：JDK 原生动态代理和 cglib 的实现。</p>
<h4 id="1）JDK-原生动态代理"><a href="#1）JDK-原生动态代理" class="headerlink" title="1）JDK 原生动态代理"></a>1）JDK 原生动态代理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"The dog is eating"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"The cat is eating"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JDK 代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target; <span class="comment">// 代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="comment">// 取得代理对象</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用前"</span>);</span><br><span class="line">        Object result = method.invoke(target, args); <span class="comment">// 方法调用</span></span><br><span class="line">        System.out.println(<span class="string">"调用后"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// JDK 动态代理调用</span></span><br><span class="line">    AnimalProxy proxy = <span class="keyword">new</span> AnimalProxy();</span><br><span class="line">    Animal dogProxy = (Animal) proxy.getInstance(<span class="keyword">new</span> Dog());</span><br><span class="line">    dogProxy.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码，我们实现了通过动态代理，在所有请求前、后都打印了一个简单的信息。</p>
<p><strong>注意：</strong> JDK Proxy 只能代理实现接口的类（即使是 extends 继承类也是不可以代理的）。</p>
<h4 id="2）cglib-动态代理"><a href="#2）cglib-动态代理" class="headerlink" title="2）cglib 动态代理"></a>2）cglib 动态代理</h4><p>要是用 cglib 实现要添加对 cglib 的引用，如果是 maven 项目的话，直接添加以下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.2.12&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>cglib 的具体实现，请参考以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Panda</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"The panda is eating"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target; <span class="comment">// 代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 设置父类为实例类</span></span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());</span><br><span class="line">        <span class="comment">// 回调方法</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用前"</span>);</span><br><span class="line">        Object result = methodProxy.invokeSuper(o, objects); <span class="comment">// 执行方法调用</span></span><br><span class="line">        System.out.println(<span class="string">"调用后"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cglib 动态代理调用</span></span><br><span class="line">    CglibProxy proxy = <span class="keyword">new</span> CglibProxy();</span><br><span class="line">    Panda panda = (Panda)proxy.getInstance(<span class="keyword">new</span> Panda());</span><br><span class="line">    panda.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序执行的结果：</p>
<blockquote>
<p>调用前</p>
<p>The panda is eating</p>
<p>调用后</p>
</blockquote>
<p>由以上代码可以知道，cglib 的调用通过实现 MethodInterceptor 接口的 intercept 方法，调用  invokeSuper 进行动态代理的。它可以直接对普通类进行动态代理，并不需要像 JDK 代理那样，需要通过接口来完成，值得一提的是  Spring 的动态代理也是通过 cglib 实现的。</p>
<p><strong>注意</strong>：cglib 底层是通过子类继承被代理对象的方式实现动态代理的，因此代理类不能是最终类（final），否则就会报错 java.lang.IllegalArgumentException: Cannot subclass final class xxx。</p>
<h3 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="1-动态代理解决了什么问题？"><a href="#1-动态代理解决了什么问题？" class="headerlink" title="1.动态代理解决了什么问题？"></a>1.动态代理解决了什么问题？</h4><p>答：首先它是一个代理机制，如果熟悉设计模式中的代理模式，我们会知道，代理可以看作是对调用目标的一个包装，这样我们对目标代码的调用不是直接发生的，而是通过代理完成，通过代理可以让调用者与实现者之间解耦。比如进行 RPC 调用，通过代理，可以提供更加友善的界面；还可以通过代理，做一个全局的拦截器。</p>
<h4 id="2-动态代理和反射的关系是什么？"><a href="#2-动态代理和反射的关系是什么？" class="headerlink" title="2.动态代理和反射的关系是什么？"></a>2.动态代理和反射的关系是什么？</h4><p>答：反射可以用来实现动态代理，但动态代理还有其他的实现方式，比如 ASM（一个短小精悍的字节码操作框架）、cglib 等。</p>
<h4 id="3-以下描述错误的是？"><a href="#3-以下描述错误的是？" class="headerlink" title="3.以下描述错误的是？"></a>3.以下描述错误的是？</h4><p>A：cglib 的性能更高<br>B：Spring 中有使用 cglib 来实现动态代理<br>C：Spring 中有使用 JDK 原生的动态代理<br>D：JDK 原生动态代理性能更高</p>
<p>答：D</p>
<p>题目解析：Spring 动态代理的实现方式有两种：cglib 和 JDK 原生动态代理。</p>
<h4 id="4-请补全以下代码？"><a href="#4-请补全以下代码？" class="headerlink" title="4.请补全以下代码？"></a>4.请补全以下代码？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReflect</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">privateMd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Private Method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReflectTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        Class myClass = Class.forName(<span class="string">"MyReflect"</span>);</span><br><span class="line">        Object object = myClass.newInstance();</span><br><span class="line">        <span class="comment">// 补充此行代码</span></span><br><span class="line">        method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        method.invoke(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答：Method method = myClass.getDeclaredMethod(“privateMd”);</p>
<p>题目解析：此题主要考的是私有方法的获取，私有方法的获取并不是通过 getMethod() 方式，而是通过 getDeclaredMethod() 获取的。</p>
<h4 id="5-cglib-可以代理任何类这句话对吗？为什么？"><a href="#5-cglib-可以代理任何类这句话对吗？为什么？" class="headerlink" title="5.cglib 可以代理任何类这句话对吗？为什么？"></a>5.cglib 可以代理任何类这句话对吗？为什么？</h4><p>答：这句话不完全对，因为 cglib 只能代理可以有子类的普通类，对于像最终类（final），cglib 是不能实现动态代理的，因为 cglib 的底层是通过继承代理类的子类来实现动态代理的，所以不能被继承类无法使用 cglib。</p>
<h4 id="6-JDK-原生动态代理和-cglib-有什么区别？"><a href="#6-JDK-原生动态代理和-cglib-有什么区别？" class="headerlink" title="6.JDK 原生动态代理和 cglib 有什么区别？"></a>6.JDK 原生动态代理和 cglib 有什么区别？</h4><p>答：JDK 原生动态代理和 cglib 区别如下：</p>
<ul>
<li>JDK 原生动态代理是基于接口实现的，不需要添加任何依赖，可以平滑的支持 JDK 版本的升级；</li>
<li>cglib 不需要实现接口，可以直接代理普通类，需要添加依赖包，性能更高。</li>
</ul>
<h4 id="7-为什么-JDK-原生的动态代理必须要通过接口来完成？"><a href="#7-为什么-JDK-原生的动态代理必须要通过接口来完成？" class="headerlink" title="7.为什么 JDK 原生的动态代理必须要通过接口来完成？"></a>7.为什么 JDK 原生的动态代理必须要通过接口来完成？</h4><p>答：这是由于 JDK 原生设计的原因，来看动态代理的实现方法 newProxyInstance() 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ......</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   loader the class loader to define the proxy class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   interfaces the list of interfaces for the proxy class to implement</span></span><br><span class="line"><span class="comment"> * ......</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      InvocationHandler h)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 省略其他代码</span></span><br></pre></td></tr></table></figure>

<p>来看前两个参数的声明：</p>
<ul>
<li>loader：为类加载器，也就是 target.getClass().getClassLoader()</li>
<li>interfaces：接口代理类的接口实现列表</li>
</ul>
<p>看了上面的参数说明，我们就明白了，要使用 JDK 原生的动态只能通过实现接口来完成。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>通过本文可以知道 JDK 原生动态代理是使用反射实现的，但动态代理的实现方式不止有反射，还可以是  ASM（一个短小精悍的字节码操作框架）、cglib（基于 ASM）等。其中 JDK 原生的动态代理是通过接口实现的，而 cglib  是通过子类实现的，因此 cglib  不能代理最终类（final）。而反射不但可以反射调用静态方法，还可以反射调用普通方法和私有方法，其中调用私有方法时要设置  setAccessible 为 true。</p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2020/03/06/3Java高级/Java反射机制/">Java反射机制</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">爱吃鱼的呆先生</a></p>
        <p><span>发布时间:</span>2020-03-06, 17:35:24</p>
        <p><span>最后更新:</span>2020-03-06, 17:38:24</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2020/03/06/3Java高级/Java反射机制/" title="Java反射机制">http://yoursite.com/2020/03/06/3Java高级/Java反射机制/</a>
            <span class="copy-path" data-clipboard-text="原文: http://yoursite.com/2020/03/06/3Java高级/Java反射机制/　　作者: 爱吃鱼的呆先生" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2020/03/06/4悟空Java并发编程/AQS/">
                    
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2020/03/06/3Java高级/Java8新特性/">
                    Java8新特性
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java反射机制"><span class="toc-number">1.</span> <span class="toc-text">Java反射机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java反射机制概述"><span class="toc-number">1.1.</span> <span class="toc-text">Java反射机制概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#关于反射的理解"><span class="toc-number">1.1.1.</span> <span class="toc-text">关于反射的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#体会反射机制的“动态性”"><span class="toc-number">1.1.2.</span> <span class="toc-text">体会反射机制的“动态性”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反射机制能提供的功能"><span class="toc-number">1.1.3.</span> <span class="toc-text">反射机制能提供的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#相关API"><span class="toc-number">1.1.4.</span> <span class="toc-text">相关API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Class类的理解与获取Class的实例"><span class="toc-number">1.2.</span> <span class="toc-text">Class类的理解与获取Class的实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Class类的理解"><span class="toc-number">1.2.1.</span> <span class="toc-text">Class类的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取Class实例的几种方式"><span class="toc-number">1.2.2.</span> <span class="toc-text">获取Class实例的几种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class类的常用方法"><span class="toc-number">1.2.3.</span> <span class="toc-text">Class类的常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">1.2.4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#哪些类型可以有Class对象"><span class="toc-number">1.2.5.</span> <span class="toc-text">哪些类型可以有Class对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ClassLoader"><span class="toc-number">1.3.</span> <span class="toc-text">ClassLoader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类的加载过程"><span class="toc-number">1.3.1.</span> <span class="toc-text">类的加载过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类的加载器的作用"><span class="toc-number">1.3.2.</span> <span class="toc-text">类的加载器的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么时候会发生类初始化"><span class="toc-number">1.3.3.</span> <span class="toc-text">什么时候会发生类初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#类的主动引用（一定会发生类的初始化）"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">类的主动引用（一定会发生类的初始化）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类的被动引用（不会发生类的初始化）"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">类的被动引用（不会发生类的初始化）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类的加载器的分类"><span class="toc-number">1.3.4.</span> <span class="toc-text">类的加载器的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java类编译运行的执行的流程"><span class="toc-number">1.3.5.</span> <span class="toc-text">Java类编译运行的执行的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用Classloader加载src目录下的配置文件"><span class="toc-number">1.3.6.</span> <span class="toc-text">使用Classloader加载src目录下的配置文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#反射应用一"><span class="toc-number">1.4.</span> <span class="toc-text">反射应用一</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#代码举例"><span class="toc-number">1.4.1.</span> <span class="toc-text">代码举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#说明"><span class="toc-number">1.4.2.</span> <span class="toc-text">说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#反射应用二"><span class="toc-number">1.5.</span> <span class="toc-text">反射应用二</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#典型代码"><span class="toc-number">1.5.1.</span> <span class="toc-text">典型代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#反射应用三"><span class="toc-number">1.6.</span> <span class="toc-text">反射应用三</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#反射应用四"><span class="toc-number">1.7.</span> <span class="toc-text">反射应用四</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#代理模式的原理"><span class="toc-number">1.7.1.</span> <span class="toc-text">代理模式的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态代理"><span class="toc-number">1.7.2.</span> <span class="toc-text">静态代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态代理的缺点"><span class="toc-number">1.7.3.</span> <span class="toc-text">静态代理的缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态代理的特点"><span class="toc-number">1.7.4.</span> <span class="toc-text">动态代理的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态代理的实现"><span class="toc-number">1.7.5.</span> <span class="toc-text">动态代理的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#需要解决的两个主要问题"><span class="toc-number">1.7.5.1.</span> <span class="toc-text">需要解决的两个主要问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码实现"><span class="toc-number">1.7.5.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#注"><span class="toc-number">1.8.</span> <span class="toc-text">注</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#反射"><span class="toc-number">1.8.1.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#反射的使用场景"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">反射的使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#反射的基本使用"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">反射的基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#①-反射调用静态方法"><span class="toc-number">1.8.1.2.1.</span> <span class="toc-text">① 反射调用静态方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#②-反射调用公共方法"><span class="toc-number">1.8.1.2.2.</span> <span class="toc-text">② 反射调用公共方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#③-反射调用私有方法"><span class="toc-number">1.8.1.2.3.</span> <span class="toc-text">③ 反射调用私有方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#反射使用总结"><span class="toc-number">1.8.1.3.</span> <span class="toc-text">反射使用总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态代理"><span class="toc-number">1.8.2.</span> <span class="toc-text">动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#动态代理的使用场景"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">动态代理的使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动态代理和反射的关系"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">动态代理和反射的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1）JDK-原生动态代理"><span class="toc-number">1.8.2.3.</span> <span class="toc-text">1）JDK 原生动态代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2）cglib-动态代理"><span class="toc-number">1.8.2.4.</span> <span class="toc-text">2）cglib 动态代理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#相关面试题"><span class="toc-number">1.8.3.</span> <span class="toc-text">相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-动态代理解决了什么问题？"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">1.动态代理解决了什么问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-动态代理和反射的关系是什么？"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">2.动态代理和反射的关系是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-以下描述错误的是？"><span class="toc-number">1.8.3.3.</span> <span class="toc-text">3.以下描述错误的是？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-请补全以下代码？"><span class="toc-number">1.8.3.4.</span> <span class="toc-text">4.请补全以下代码？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-cglib-可以代理任何类这句话对吗？为什么？"><span class="toc-number">1.8.3.5.</span> <span class="toc-text">5.cglib 可以代理任何类这句话对吗？为什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-JDK-原生动态代理和-cglib-有什么区别？"><span class="toc-number">1.8.3.6.</span> <span class="toc-text">6.JDK 原生动态代理和 cglib 有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-为什么-JDK-原生的动态代理必须要通过接口来完成？"><span class="toc-number">1.8.3.7.</span> <span class="toc-text">7.为什么 JDK 原生的动态代理必须要通过接口来完成？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结-1"><span class="toc-number">1.8.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"Java反射机制　| 爱吃鱼的呆先生　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2020/03/06/4悟空Java并发编程/AQS/" title="上一篇: ">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2020/03/06/3Java高级/Java8新特性/" title="下一篇: Java8新特性">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/05/07/Mybatis/1mybatis高级原理分析/">1mybatis高级原理分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/07/Mybatis/Mybatis基础1/">mybatis基础详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/04/Vue/Vue1/">Vue/Vue1</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/03/面试/简历/">面试/简历</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/01/SpringDataJPA/SpringDataJPA/">SpringDataJPA</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/01/ELK/Logstash/">Logstash</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/01/ELK/ElasticSearch/">ElasticSearch</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/29/0编程工具/easyExcel/">easyExcel</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/28/ZooKeeper/3Zookeeper/">第1章Zookeeper理论基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/24/Spring/2Spring核心理解/">Spring/2Spring核心理解</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/23/数据结构/动态规划/">数据结构/动态规划</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/21/Json/Json/">Json详解以及fastjson使用教程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/18/SpringMVC/SpringMVC/">SpringMVC/SpringMVC</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/18/Kafka/Kafka/">Kafka/Kafka</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/14/0编程工具/Idea/">Idea</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/31/9Redis/1Redis/">Redis1</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/29/SpringCloud/1SpringCloud/">Spring Cloud基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/29/ZooKeeper/1Zookeeper/">第1章Zookeeper理论基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/8MySQL/4MySQL/">8MySQL/4MySQL</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/24/8MySQL/3MySQL/">8MySQL/3MySQL</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/21/8MySQL/2MySQL/">8MySQL/2MySQL</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/20/8MySQL/1MySQL/">MySQL介绍和基本的SQL编写及解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/19/0编程工具/Linux5/">0编程工具/Linux5</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/17/0编程工具/Linux3/">Linux3</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/15/0编程工具/Linux2/">Linux2</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/15/数据结构/2栈和队列/">栈和队列</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/15/数据结构/1数组/">数组</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/10/0编程工具/Linux/">Linux1</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/锁/">锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/详解之同步synchronized/">多线程二之高并发详解之同步synchronized关键字</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/线程8大核心基础/">多线程三之线程8大核心基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/治理线程的第二法宝/">4悟空Java并发编程/治理线程的第二法宝</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/控制并发流程/">4悟空Java并发编程/控制并发流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/并发编程的基石/">多线程一之并发编程的基石</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/并发工具类纵览/">并发工具类</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/并发容器精讲/">4悟空Java并发编程/并发容器精讲</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/实战项目/">4悟空Java并发编程/实战项目</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/原子类/">原子类</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/ThreadLocal详解/">ThreadLocal详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/Java内存模型之底层原理/">Java内存模型之底层原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/AQS/">4悟空Java并发编程/AQS</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/3Java高级/Java反射机制/">Java反射机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/3Java高级/Java8新特性/">Java8新特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/3Java高级/IO流/">IO流</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/2Java常用类/String类型相关习题/">String类型相关习题</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/2Java常用类/StringBuffer与StringBuilder/">StringBuffer与StringBuilder</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/2Java常用类/1String与String相关的类/">String详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/1Java基础/面向对象二5/">面向对象二</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/1Java基础/面向对象三6/">面向对象三</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/1Java基础/面向对象一4/">面向对象一</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/1Java基础/数组8/">数组</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/1Java基础/排序算法/">十大排序算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/1Java基础/异常7/">异常处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/1Java基础/八大排序算法9/">八大排序算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/1Java基础/代码简洁之道/">代码简洁之道</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/1Java基础/java3流程控制/">1Java基础/java3流程控制</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/1Java基础/Java2基本语法/">1Java基础/Java2基本语法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/1Java基础/Java1概述/">Java概述</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/06/0编程工具/Git&GitHub/">Git&GitHub</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/13/MybatisPlus/MyBatisPlus/">MyBatisPlus</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2019-2020 爱吃鱼的呆先生
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>