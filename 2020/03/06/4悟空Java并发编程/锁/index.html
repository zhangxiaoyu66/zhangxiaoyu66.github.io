<!DOCTYPE html>
<html lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="爱吃鱼的呆先生">



<meta name="description" content="锁Lock接口简介、地位、作用锁是一种工具，用于控制对共享资源的访问 Lock和synchronized，这两个是最常见的锁，它们都可以达到线程安全的目的，但是使用上和功能上又有较大的不同，Lock并不是用来代替synchronized的，而是当使用synchronized不合适或不足以满足要求的时候，来提供高级功能的 Lock接口最常见的实现类是ReentrantLock，通常情况下，Lock只">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="锁">
<meta property="og:url" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/锁/index.html">
<meta property="og:site_name" content="爱吃鱼的呆先生">
<meta property="og:description" content="锁Lock接口简介、地位、作用锁是一种工具，用于控制对共享资源的访问 Lock和synchronized，这两个是最常见的锁，它们都可以达到线程安全的目的，但是使用上和功能上又有较大的不同，Lock并不是用来代替synchronized的，而是当使用synchronized不合适或不足以满足要求的时候，来提供高级功能的 Lock接口最常见的实现类是ReentrantLock，通常情况下，Lock只">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/锁/image-20200216221234030.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/锁/image-20200217093018777.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/锁/image-20200217093104111.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/锁/image-20200217094556506.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/锁/image-20200217094714552.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/锁/image-20200217094819855.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/锁/image-20200217094847840.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/锁/image-20200217110015522.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/锁/image-20200217110219956.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/锁/image-20200217110300124.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/锁/image-20200217120854960.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/锁/image-20200217132628631.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/锁/image-20200217132907762.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/锁/image-20200217133241108.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/锁/image-20200217162838514.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/锁/image-20200217162916201.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/锁/image-20200217182506087.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/锁/image-20200217182619470.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/锁/image-20200217182746211.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/锁/image-20200217200730026.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/锁/image-20200217200947738.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/锁/image-20200217201005490.png">
<meta property="og:updated_time" content="2020-02-18T02:32:47.473Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="锁">
<meta name="twitter:description" content="锁Lock接口简介、地位、作用锁是一种工具，用于控制对共享资源的访问 Lock和synchronized，这两个是最常见的锁，它们都可以达到线程安全的目的，但是使用上和功能上又有较大的不同，Lock并不是用来代替synchronized的，而是当使用synchronized不合适或不足以满足要求的时候，来提供高级功能的 Lock接口最常见的实现类是ReentrantLock，通常情况下，Lock只">
<meta name="twitter:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/锁/image-20200216221234030.png">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="爱吃鱼的呆先生" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>锁 | 爱吃鱼的呆先生</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: false
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">爱吃鱼的呆先生</a></h1>
        </hgroup>

        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云与分类</a></li>
                        
                            <li><a href="/pdfdocuments/">pdf文档笔记</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="https://mail.163.com/" title="Email"></a>
                            
                                <a class="fa CSDN" href="https://www.csdn.net/" title="CSDN"></a>
                            
                                <a class="fa Coding" href="https://coding.net/login" title="Coding"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElasticSearch/">ElasticSearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Idea/">Idea</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Json/">Json</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Logstash/">Logstash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatisPlus/">MyBatisPlus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL基础/">MySQL基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Cloud/">Spring Cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringDataJPA/">SpringDataJPA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/String/">String</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zookeeper/">Zookeeper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/easyExcel/">easyExcel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://mybatis.org/mybatis-3/zh/index.html">Mybatis</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://spring.io/projects/spring-framework#overview">Spring</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://spring.io/projects/spring-boot">SpringBoot</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">真正的大师永远保持一颗学徒的心</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">爱吃鱼的呆先生</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">爱吃鱼的呆先生</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云与分类</a></li>
                
                    <li><a href="/pdfdocuments/">pdf文档笔记</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="https://mail.163.com/" title="Email"></a>
                            
                                <a class="fa CSDN" target="_blank" href="https://www.csdn.net/" title="CSDN"></a>
                            
                                <a class="fa Coding" target="_blank" href="https://coding.net/login" title="Coding"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-4悟空Java并发编程/锁" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/06/4悟空Java并发编程/锁/" class="article-date">
      <time datetime="2020-03-06T09:41:28.663Z" itemprop="datePublished">2020-03-06</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      锁
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java多线程/">Java多线程</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h2><h3 id="简介、地位、作用"><a href="#简介、地位、作用" class="headerlink" title="简介、地位、作用"></a>简介、地位、作用</h3><p>锁是一种工具，用于控制对共享资源的访问</p>
<p>Lock和synchronized，这两个是最常见的锁，它们都可以达到线程安全的目的，但是使用上和功能上又有较大的不同，Lock并不是用来代替synchronized的，而是当使用synchronized不合适或不足以满足要求的时候，来提供高级功能的</p>
<p>Lock接口最常见的实现类是ReentrantLock，通常情况下，Lock只允许一个线程来访问这个共享资源，不过有的时候，一些特殊的实现也 可允许并发访问，比如ReadWriteLock里面的ReadLock</p>
<a id="more"></a>

<h3 id="为什么synchronizd不够用为什么需要Lock"><a href="#为什么synchronizd不够用为什么需要Lock" class="headerlink" title="为什么synchronizd不够用为什么需要Lock"></a>为什么synchronizd不够用为什么需要Lock</h3><ol>
<li><p>效率低</p>
<p>锁的释放情况少、试图获得锁时不能设定超时，不能中断一个正在试图获得锁的线程</p>
</li>
<li><p>不够灵活</p>
<p>加锁和释放锁的时机单一，每个锁仅有单一的条件（某个对象），这是不够的，而读写锁更灵活</p>
</li>
<li><p>无法知道是否成功 获得到锁</p>
</li>
</ol>
<h3 id="Lock主要方法介绍"><a href="#Lock主要方法介绍" class="headerlink" title="Lock主要方法介绍"></a>Lock主要方法介绍</h3><p>在Lock中声明四个方法来获取锁</p>
<p>lock()、tryLock()、tryLock(long time,TimeUnit unit)和lockInterruptibly()</p>
<h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><p>Lock()是最普通的获取锁，如果锁已经被其他线程获取，则进行等待</p>
<p>Lock不会像synchronized一样在异常时自动释放锁，因此最佳实践是在finally中释放锁，以保证异常时锁一定被释放</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：</span></span><br><span class="line"><span class="comment"> * Lock不会像synchronized一样，异常的时候自动释放锁，所以最佳实践是，finally中释放锁，以便保证发生异常的时候锁一定被释放</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MustUnlock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//获取本锁保护的资源</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"开始执行任务"</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main开始执行任务</span><br></pre></td></tr></table></figure>

<p>Lock()方法不能被中断，这会带来很大的隐患，一旦陷入死锁，Lock会陷入永久等待</p>
<h4 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock()"></a>tryLock()</h4><p>tryLock()用来尝试获取锁，如果当前锁没有被其他线程占用，则获取成功，则返回true，否则返回false，代表获取锁失败，相比于Lock，这样的方法显然功能更强大了，我们可以根据是否获取到锁来决定后续程序的行为，该方法会立即返回，即使在拿不到锁的时候也不会一直在等待</p>
<h4 id="tryLock-long-time-TimeUnit-unit"><a href="#tryLock-long-time-TimeUnit-unit" class="headerlink" title="tryLock(long time,TimeUnit unit)"></a>tryLock(long time,TimeUnit unit)</h4><p>超时就放弃</p>
<h4 id="lockInterruptibly"><a href="#lockInterruptibly" class="headerlink" title="lockInterruptibly()"></a>lockInterruptibly()</h4><p>相当于tryLock(long time,TimeUnit unit)把超时时间设置为无限</p>
<h4 id="unlock"><a href="#unlock" class="headerlink" title="unlock()"></a>unlock()</h4><p>解锁</p>
<h3 id="可见性保证"><a href="#可见性保证" class="headerlink" title="可见性保证"></a>可见性保证</h3><p>Lock的加解锁和synchronized有同样的内存语意，也就是说，下一个线程加锁后可以看到所有前一个线程解锁前发生的所有操作</p>
<h2 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h2><p>这些分类是从各种不同的角度出发去看的</p>
<p>这些分类并不是互斥的，也就是多个类型可以并存，有可能一个锁，同时属于两种类型</p>
<p>比如ReentrantLock既是互斥锁，又是可重入锁</p>
<p><img src="/2020/03/06/4悟空Java并发编程/锁/image-20200216221234030.png" alt="image-20200216221234030"></p>
<h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><p>乐观锁也称为非互斥同步锁，悲观锁也称为互斥同步锁</p>
<h3 id="互斥锁同步锁的劣势"><a href="#互斥锁同步锁的劣势" class="headerlink" title="互斥锁同步锁的劣势"></a>互斥锁同步锁的劣势</h3><p>阻塞和唤醒带来的性能劣势</p>
<p>可能会陷入永久阻塞，如果持有锁的线程被永久阻塞，比如遇到了无限循环、死锁等活跃性问题，那么等待该线程释放锁的那几个悲催的线程，将永远也得不到执行</p>
<p>会发生优先级反转</p>
<h3 id="什么是乐观锁和悲观锁"><a href="#什么是乐观锁和悲观锁" class="headerlink" title="什么是乐观锁和悲观锁"></a>什么是乐观锁和悲观锁</h3><p>从是否锁住资源的角度分类</p>
<p><strong>悲观锁</strong></p>
<p>如果一个线程不锁住资源，别的线程就会来争抢，就会造成数据结果错误，所以每次悲观锁为了确保结果的正确性，会在每次获取并修改数据的时候把锁锁住，让别人无法访问该数据，这样就可以确保数据内容万无一失</p>
<p>Java中悲观锁的实现就是synchronized和Lock相关类</p>
<img src="/2020/03/06/4悟空Java并发编程/锁/image-20200217093018777.png" alt="image-20200217093018777" style="zoom: 50%;">

<img src="/2020/03/06/4悟空Java并发编程/锁/image-20200217093104111.png" alt="image-20200217093104111" style="zoom: 80%;">

<p><strong>乐观锁</strong></p>
<p>认为自己在处理操作的时候不会有其他线程来干扰，所以并不会锁住被操作的对象</p>
<p>在更新的时候，对比用户修改的期间数据有没有被其他人改变过，如果没有改变过，就说明真的是只有用户自己在操作，此时，用户就正常区修改数据，如果数据和用户开始的时候得到的值不一样，说明其他人在这段时间内改变过数据，那就不继续更新数据的过程用户会选择放弃、报错、重试等策略</p>
<p>乐观锁的实现一般是利用CAS算法来实现的</p>
<img src="/2020/03/06/4悟空Java并发编程/锁/image-20200217094556506.png" alt="image-20200217094556506" style="zoom: 67%;">

<img src="/2020/03/06/4悟空Java并发编程/锁/image-20200217094714552.png" alt="image-20200217094714552" style="zoom: 67%;">

<img src="/2020/03/06/4悟空Java并发编程/锁/image-20200217094819855.png" alt="image-20200217094819855" style="zoom:67%;">

<img src="/2020/03/06/4悟空Java并发编程/锁/image-20200217094847840.png" alt="image-20200217094847840" style="zoom: 80%;">

<h3 id="典型例子"><a href="#典型例子" class="headerlink" title="典型例子"></a>典型例子</h3><p>Java中悲观锁的实现就是synchronized和Lock相关类</p>
<p>乐观锁的典型例子就是原子类、并发容器</p>
<h4 id="例子一"><a href="#例子一" class="headerlink" title="例子一"></a>例子一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PessimismOptimismLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        atomicInteger.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="例子二"><a href="#例子二" class="headerlink" title="例子二"></a>例子二</h4><p>Git：Git就是乐观锁的典型例子，当向远端仓库push的时候，git就会检查远端仓库的版本是不是领先于现在的版本，如果远程仓库的版本号和本地的不一样，就表示有其他人修改了远端代码，这次提交就失败了，如果远端和本地版本号一致，就可以顺利提交版本到远端仓库</p>
<p>Git不适用悲观锁</p>
<h4 id="例子三"><a href="#例子三" class="headerlink" title="例子三"></a>例子三</h4><p><code>select for update</code>就是悲观锁，用version控制数据库就是乐观锁</p>
<p>添加一个字段lock_version（专门用来记录版本号的）</p>
<p>先查询这个更新语句的version：<code>select * from table</code></p>
<p>然后<code>update set num = 2，version = version + 1 where version = 1 and id = 5</code></p>
<p>如果version被更新了等于2，不一样就会出现更新错误，就是是乐观锁的原理</p>
<h3 id="开销对比"><a href="#开销对比" class="headerlink" title="开销对比"></a>开销对比</h3><p>悲观锁的原始开销要高于乐观锁，但是特点是一劳永逸，临界区持锁的时间很长，也不会对互斥锁造成影响</p>
<p>乐观锁一开始的开销笔悲观锁小，但是如果自旋时间很长或者不停重试，那么消耗的资源也会越来越多</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>悲观锁</p>
<p>适合并发写入多的情况，适用于临界区持锁时间比较长的情况，悲观锁可以避免大量的无用自选等消耗，典型情况：</p>
<ol>
<li>临界区有IO操作</li>
<li>临界区代码复杂或循环量大</li>
<li>临界区竞争非常激烈</li>
</ol>
<p>乐观锁</p>
<p>适合并发写入少，大部分是读写的场景，不加锁能让读取性能大幅提高</p>
<h2 id="可重入锁和非可重入锁"><a href="#可重入锁和非可重入锁" class="headerlink" title="可重入锁和非可重入锁"></a>可重入锁和非可重入锁</h2><p>ReentrantLock使用案例</p>
<p>案例一</p>
<img src="/2020/03/06/4悟空Java并发编程/锁/image-20200217110015522.png" alt="image-20200217110015522" style="zoom: 67%;">

<img src="/2020/03/06/4悟空Java并发编程/锁/image-20200217110219956.png" alt="image-20200217110219956" style="zoom:67%;">

<img src="/2020/03/06/4悟空Java并发编程/锁/image-20200217110300124.png" alt="image-20200217110300124" style="zoom:67%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     演示多线程预定电影院座位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CinemaBookSeat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bookSeat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"开始预定座位"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"完成预定座位"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; bookSeat()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; bookSeat()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; bookSeat()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; bookSeat()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread-0开始预定座位</span><br><span class="line">Thread-0完成预定座位</span><br><span class="line">Thread-1开始预定座位</span><br><span class="line">Thread-1完成预定座位</span><br><span class="line">Thread-2开始预定座位</span><br><span class="line">Thread-2完成预定座位</span><br><span class="line">Thread-3开始预定座位</span><br><span class="line">Thread-3完成预定座位</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     演示ReentrantLock的基本用法，演示被打断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> LockDemo().init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Outputer outputer = <span class="keyword">new</span> Outputer();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">5</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    outputer.output(<span class="string">"悟空"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">5</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    outputer.output(<span class="string">"大师兄"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Outputer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//字符串打印方法，一个个字符的打印</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> len = name.length();</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                    System.out.print(name.charAt(i));</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">""</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="什么是可重入"><a href="#什么是可重入" class="headerlink" title="什么是可重入"></a>什么是可重入</h3><p>可重入锁意味着：若一个程序或子程序可以“在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错”，则称其为可重入（reentrant或re-entrant）的。即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合设计时预期的结果。与多线程并发执行的线程安全不同，可重入强调对<strong>单个线程执行时重新进入同一个子程序</strong>仍然是安全的。</p>
<p>通俗来说：当线程请求一个由其它线程持有的对象锁时，该线程会阻塞，而当线程请求由自己持有的对象锁时，如果该锁是重入锁，请求就会成功，否则阻塞。</p>
<p>好处</p>
<p>避免死锁</p>
<h3 id="可重入的性质"><a href="#可重入的性质" class="headerlink" title="可重入的性质"></a>可重入的性质</h3><p><strong>案例一</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetHoldCount</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> ReentrantLock lock =  <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//getHoldCount()方法会显示出当前锁被获取几次</span></span><br><span class="line">        System.out.println(lock.getHoldCount());</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(lock.getHoldCount());</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(lock.getHoldCount());</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(lock.getHoldCount());</span><br><span class="line">        lock.unlock();</span><br><span class="line">        System.out.println(lock.getHoldCount());</span><br><span class="line">        lock.unlock();</span><br><span class="line">        System.out.println(lock.getHoldCount());</span><br><span class="line">        lock.unlock();</span><br><span class="line">        System.out.println(lock.getHoldCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p><strong>案例一</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursionDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">accessResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"已经对资源进行了处理"</span>);</span><br><span class="line">            <span class="keyword">if</span> (lock.getHoldCount()&lt;<span class="number">5</span>) &#123;</span><br><span class="line">                System.out.println(lock.getHoldCount());</span><br><span class="line">                accessResource();</span><br><span class="line">                System.out.println(lock.getHoldCount());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        accessResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">已经对资源进行了处理</span><br><span class="line">1</span><br><span class="line">已经对资源进行了处理</span><br><span class="line">2</span><br><span class="line">已经对资源进行了处理</span><br><span class="line">3</span><br><span class="line">已经对资源进行了处理</span><br><span class="line">4</span><br><span class="line">已经对资源进行了处理</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h4 id="源码对比：可重入锁ReentrantLock以及非可重入锁ThreadPoolExcutor的Worker类"><a href="#源码对比：可重入锁ReentrantLock以及非可重入锁ThreadPoolExcutor的Worker类" class="headerlink" title="源码对比：可重入锁ReentrantLock以及非可重入锁ThreadPoolExcutor的Worker类"></a>源码对比：可重入锁ReentrantLock以及非可重入锁ThreadPoolExcutor的Worker类</h4><p><img src="/2020/03/06/4悟空Java并发编程/锁/image-20200217120854960.png" alt="image-20200217120854960"></p>
<h4 id="ReentrantLock的其他方法介绍"><a href="#ReentrantLock的其他方法介绍" class="headerlink" title="ReentrantLock的其他方法介绍"></a>ReentrantLock的其他方法介绍</h4><p>isHeldByCurrentThread</p>
<p>可以看出锁是否被当前线程持有</p>
<p>getQueueLength</p>
<p>可以返回当前正在等待这把锁的队列有多长</p>
<p>一般这两个方法是开发和调试时候使用 </p>
<h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><h3 id="什么是公平和非公平"><a href="#什么是公平和非公平" class="headerlink" title="什么是公平和非公平"></a>什么是公平和非公平</h3><p>公平指的是按照线程请求的顺序来分配锁</p>
<p>非公平指的是不完全按照请求的顺序，在一定情况下可以插队</p>
<p>注意：非公平也同样不提倡“插队”行为，这里的非公平指的是在“合适的时机”插队，而不是盲目的插队</p>
<h3 id="为什么要有非公平锁"><a href="#为什么要有非公平锁" class="headerlink" title="为什么要有非公平锁"></a>为什么要有非公平锁</h3><p>Java这样设计的目的，是为了提高效率，避免唤醒带来的空档期</p>
<p>在大多数情况下，由于唤醒的过程开销是比较大的，在这个期间为了增加吞吐量，来把这段唤醒开销时间利用出去，这就是非公平锁的根本原因</p>
<h3 id="公平情况（以ReentrantLock为例）"><a href="#公平情况（以ReentrantLock为例）" class="headerlink" title="公平情况（以ReentrantLock为例）"></a>公平情况（以ReentrantLock为例）</h3><p>ReentrantLock默认是非公平锁，如果在创建ReentrantLock对象时，参数填写为true，那么这就是一个公平锁</p>
<p>案例</p>
<p>假设线程1234是按顺序调用lock()的</p>
<p>后续等待的线程会到wait queue里，按照顺序依次执行</p>
<p><img src="/2020/03/06/4悟空Java并发编程/锁/image-20200217132628631.png" alt="image-20200217132628631"></p>
<p>在线程1执行unlock()释放锁之后，由于此时线程2的等待时间最久，所以线程2先得到锁，然后是线程3和线程4</p>
<p><img src="/2020/03/06/4悟空Java并发编程/锁/image-20200217132907762.png" alt="image-20200217132907762"></p>
<h3 id="不公平的情况（以ReentrantLock为例）"><a href="#不公平的情况（以ReentrantLock为例）" class="headerlink" title="不公平的情况（以ReentrantLock为例）"></a>不公平的情况（以ReentrantLock为例）</h3><p>如果在线程1释放锁的时候，线程5恰好去执行lock()</p>
<p>由于ReentrantLock发现此时并没有线程持有lock这把锁（线程2还没来得及获取到，因为获取需要时间）</p>
<p>线程5可以插队，直接拿到这把锁，这也是ReentrantLock默认的公平策略，也就是“不公平”</p>
<p><img src="/2020/03/06/4悟空Java并发编程/锁/image-20200217133241108.png" alt="image-20200217133241108"></p>
<h3 id="代码案例：演示公平和非公平的效果"><a href="#代码案例：演示公平和非公平的效果" class="headerlink" title="代码案例：演示公平和非公平的效果"></a>代码案例：演示公平和非公平的效果</h3><p>公平锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     演示公平和不公平两种情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FairLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrintQueue printQueue = <span class="keyword">new</span> PrintQueue();</span><br><span class="line">        Thread thread[] = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            thread[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Job(printQueue));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            thread[i].start();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Job</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    PrintQueue printQueue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(PrintQueue printQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.printQueue = printQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始打印"</span>);</span><br><span class="line">        printQueue.printJob(<span class="keyword">new</span> Object());</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"打印完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock queueLock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printJob</span><span class="params">(Object document)</span> </span>&#123;</span><br><span class="line">        queueLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> duration = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>) + <span class="number">1</span>;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"正在打印，需要"</span> + duration);</span><br><span class="line">            Thread.sleep(duration * <span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            queueLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queueLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> duration = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>) + <span class="number">1</span>;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"正在打印，需要"</span> + duration+<span class="string">"秒"</span>);</span><br><span class="line">            Thread.sleep(duration * <span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            queueLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Thread-0开始打印</span><br><span class="line">Thread-0正在打印，需要4</span><br><span class="line">Thread-1开始打印</span><br><span class="line">Thread-2开始打印</span><br><span class="line">Thread-3开始打印</span><br><span class="line">Thread-4开始打印</span><br><span class="line">Thread-5开始打印</span><br><span class="line">Thread-6开始打印</span><br><span class="line">Thread-7开始打印</span><br><span class="line">Thread-8开始打印</span><br><span class="line">Thread-9开始打印</span><br><span class="line">Thread-1正在打印，需要6</span><br><span class="line">Thread-2正在打印，需要4</span><br><span class="line">Thread-3正在打印，需要2</span><br><span class="line">Thread-4正在打印，需要4</span><br><span class="line">Thread-5正在打印，需要1</span><br><span class="line">Thread-6正在打印，需要6</span><br><span class="line">Thread-7正在打印，需要1</span><br><span class="line">Thread-8正在打印，需要10</span><br><span class="line">Thread-9正在打印，需要4</span><br><span class="line">Thread-0正在打印，需要4秒</span><br><span class="line">Thread-0打印完毕</span><br><span class="line">Thread-1正在打印，需要10秒</span><br><span class="line">Thread-1打印完毕</span><br><span class="line">Thread-2正在打印，需要9秒</span><br><span class="line">Thread-2打印完毕</span><br><span class="line">Thread-3正在打印，需要2秒</span><br><span class="line">Thread-3打印完毕</span><br><span class="line">Thread-4正在打印，需要6秒</span><br><span class="line">Thread-4打印完毕</span><br><span class="line">Thread-5正在打印，需要7秒</span><br><span class="line">Thread-5打印完毕</span><br><span class="line">Thread-6正在打印，需要4秒</span><br><span class="line">Thread-6打印完毕</span><br><span class="line">Thread-7正在打印，需要9秒</span><br><span class="line">Thread-7打印完毕</span><br><span class="line">Thread-8正在打印，需要6秒</span><br><span class="line">Thread-8打印完毕</span><br><span class="line">Thread-9正在打印，需要4秒</span><br><span class="line">Thread-9打印完毕</span><br></pre></td></tr></table></figure>

<p>非公平锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     演示公平和不公平两种情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FairLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrintQueue printQueue = <span class="keyword">new</span> PrintQueue();</span><br><span class="line">        Thread thread[] = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            thread[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Job(printQueue));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            thread[i].start();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Job</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    PrintQueue printQueue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(PrintQueue printQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.printQueue = printQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始打印"</span>);</span><br><span class="line">        printQueue.printJob(<span class="keyword">new</span> Object());</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"打印完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock queueLock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printJob</span><span class="params">(Object document)</span> </span>&#123;</span><br><span class="line">        queueLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> duration = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>) + <span class="number">1</span>;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"正在打印，需要"</span> + duration);</span><br><span class="line">            Thread.sleep(duration * <span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            queueLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queueLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> duration = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>) + <span class="number">1</span>;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"正在打印，需要"</span> + duration+<span class="string">"秒"</span>);</span><br><span class="line">            Thread.sleep(duration * <span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            queueLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Thread-0开始打印</span><br><span class="line">Thread-0正在打印，需要8</span><br><span class="line">Thread-1开始打印</span><br><span class="line">Thread-2开始打印</span><br><span class="line">Thread-3开始打印</span><br><span class="line">Thread-4开始打印</span><br><span class="line">Thread-5开始打印</span><br><span class="line">Thread-6开始打印</span><br><span class="line">Thread-7开始打印</span><br><span class="line">Thread-8开始打印</span><br><span class="line">Thread-9开始打印</span><br><span class="line">Thread-0正在打印，需要6秒</span><br><span class="line">Thread-1正在打印，需要6</span><br><span class="line">Thread-0打印完毕</span><br><span class="line">Thread-1正在打印，需要10秒</span><br><span class="line">Thread-1打印完毕</span><br><span class="line">Thread-2正在打印，需要2</span><br><span class="line">Thread-2正在打印，需要1秒</span><br><span class="line">Thread-2打印完毕</span><br><span class="line">Thread-3正在打印，需要10</span><br><span class="line">Thread-3正在打印，需要3秒</span><br><span class="line">Thread-3打印完毕</span><br><span class="line">Thread-4正在打印，需要6</span><br><span class="line">Thread-4正在打印，需要7秒</span><br><span class="line">Thread-4打印完毕</span><br><span class="line">Thread-5正在打印，需要2</span><br><span class="line">Thread-5正在打印，需要3秒</span><br><span class="line">Thread-5打印完毕</span><br><span class="line">Thread-6正在打印，需要3</span><br><span class="line">Thread-6正在打印，需要2秒</span><br><span class="line">Thread-6打印完毕</span><br><span class="line">Thread-7正在打印，需要8</span><br><span class="line">Thread-7正在打印，需要6秒</span><br><span class="line">Thread-7打印完毕</span><br><span class="line">Thread-8正在打印，需要6</span><br><span class="line">Thread-8正在打印，需要5秒</span><br><span class="line">Thread-8打印完毕</span><br><span class="line">Thread-9正在打印，需要2</span><br><span class="line">Thread-9正在打印，需要5秒</span><br><span class="line">Thread-9打印完毕</span><br></pre></td></tr></table></figure>

<h3 id="特例"><a href="#特例" class="headerlink" title="特例"></a>特例</h3><p>针对tryLock()方法，它不遵循设定的公平的规则</p>
<p>当有线程执行tryLock()的时候，一旦有线程释放了锁，那么这个正在tryLock的线程就能获取到锁，即使在它之前已经有其他线程在等待队列里</p>
<h3 id="对比公平和非公平的优缺点"><a href="#对比公平和非公平的优缺点" class="headerlink" title="对比公平和非公平的优缺点"></a>对比公平和非公平的优缺点</h3><p><img src="/2020/03/06/4悟空Java并发编程/锁/image-20200217162838514.png" alt="image-20200217162838514"></p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p><img src="/2020/03/06/4悟空Java并发编程/锁/image-20200217162916201.png" alt="image-20200217162916201"></p>
<p>先去判断是否前面有线程在队列中排队，如果没有则再次获取锁，非公平锁中没有这样的判断，也就是说不管有没有线程在队列中，都尝试获取锁</p>
<h2 id="共享锁和排它锁"><a href="#共享锁和排它锁" class="headerlink" title="共享锁和排它锁"></a>共享锁和排它锁</h2><p>以ReentrantReadWriteLock读写锁为例</p>
<h3 id="什么是共享锁和排它锁"><a href="#什么是共享锁和排它锁" class="headerlink" title="什么是共享锁和排它锁"></a>什么是共享锁和排它锁</h3><p>排它锁</p>
<p>又称独占锁、独享锁，获取锁之后既能读也能写，此时其他线程再也没有办法获得排它锁，只能有获取排它锁的线程修改数据，保证了线程安全，synchronized就是排它锁</p>
<p>共享锁</p>
<p>又称为读锁，在获取共享锁之后，可以查看但无法修改和删除数据，其他线程此时也可以获取到共享锁，也可以查看但无法修改和删除数据</p>
<p>共享锁和排它锁的典型是读写锁ReentrantReadWriteLock，其中读锁是共享锁，写锁是排它锁</p>
<h3 id="读写锁的作用"><a href="#读写锁的作用" class="headerlink" title="读写锁的作用"></a>读写锁的作用</h3><p>在没有读写锁之前，假设使用ReentrantLock，那么虽然我们保证了线程安全，但是也浪费一定的资源，因为多个读操作同时进行，并没有线程安全问题</p>
<p>在读的地方使用读锁，写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的，提高了程序的执行效率</p>
<h3 id="读写锁的规则"><a href="#读写锁的规则" class="headerlink" title="读写锁的规则"></a>读写锁的规则</h3><ol>
<li>多个线程只申请读锁，都可以申请到</li>
<li>如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁</li>
<li>如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁</li>
</ol>
<p><strong>总结</strong></p>
<p>一句话总结，要么是一个或多个线程同时有读锁，要么是一个线程有写锁，但是两个不会同时出现（要么多读，要么一写）</p>
<p>读写锁只是一把锁，可以通过两种方式锁定：读锁定和写锁定。读写锁可以同时被一个或者多个线程读锁定，也可以被单一线程写锁定，但是永远不能同时对这把锁进行读锁定和写锁定</p>
<h3 id="ReentrantReadWriteLock具体用法"><a href="#ReentrantReadWriteLock具体用法" class="headerlink" title="ReentrantReadWriteLock具体用法"></a>ReentrantReadWriteLock具体用法</h3><p>之前的情况，未使用读写锁</p>
<p><img src="/2020/03/06/4悟空Java并发编程/锁/image-20200217182506087.png" alt="image-20200217182506087"></p>
<p>现在用了读写锁，线程1和线程2可以同时用读锁，提高了效率  </p>
<p><img src="/2020/03/06/4悟空Java并发编程/锁/image-20200217182619470.png" alt="image-20200217182619470"></p>
<p> 当线程1和线程2都释放锁以后，线程3和线程4就可以写入了，但是只能有一个线程持有写锁</p>
<p><img src="/2020/03/06/4悟空Java并发编程/锁/image-20200217182746211.png" alt="image-20200217182746211"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     TODO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CinemaReadWrite</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock reentrantReadWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock.ReadLock readLock = reentrantReadWriteLock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock.WriteLock writeLock = reentrantReadWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"得到了读锁，正在读取"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"释放读锁"</span>);</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"得到了写锁，正在写入"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"释放写锁"</span>);</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;read(),<span class="string">"Thread1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;read(),<span class="string">"Thread2"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;write(),<span class="string">"Thread3"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;write(),<span class="string">"Thread4"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread1得到了读锁，正在读取</span><br><span class="line">Thread2得到了读锁，正在读取</span><br><span class="line">Thread2释放读锁</span><br><span class="line">Thread1释放读锁</span><br><span class="line">Thread3得到了写锁，正在写入</span><br><span class="line">Thread3释放写锁</span><br><span class="line">Thread4得到了写锁，正在写入</span><br><span class="line">Thread4释放写锁</span><br></pre></td></tr></table></figure>

<h3 id="读锁和写锁的交互方式"><a href="#读锁和写锁的交互方式" class="headerlink" title="读锁和写锁的交互方式"></a>读锁和写锁的交互方式</h3><p><strong>插队策略</strong></p>
<p>插队哪一个线程去执行，读线程可以插队，可以多个线程同时去读，这样提高了效率</p>
<p><strong>升降级</strong></p>
<p>读锁和写锁不是平等的，实际上写锁更加厉害，读锁相对没有那么厉害，可不可以直接升降级，可不可以在不释放写锁的情况下直接升级获取读锁，或者可不可以在持有读锁的时候可不可以升级成写锁</p>
<h4 id="ReentrantReadWriteLock的实现"><a href="#ReentrantReadWriteLock的实现" class="headerlink" title="ReentrantReadWriteLock的实现"></a>ReentrantReadWriteLock的实现</h4><p>不允许读锁插队</p>
<p>允许降级，不允许升级</p>
<h3 id="读锁插队策略"><a href="#读锁插队策略" class="headerlink" title="读锁插队策略"></a>读锁插队策略</h3><p>对于公平锁而言，如果是公平的就不要想插队了</p>
<p>对于非公平锁，假设线程2和线程4正在同时读取，线程3想要写入，拿不到锁，于是进入等待队列，线程5不在队列里，现在想要读取</p>
<p><strong>策略1</strong></p>
<p>读可以插队，效率高，但容易造成饥饿</p>
<p><img src="/2020/03/06/4悟空Java并发编程/锁/image-20200217200730026.png" alt="image-20200217200730026"></p>
<p><strong>策略2</strong></p>
<p>避免饥饿</p>
<p><img src="/2020/03/06/4悟空Java并发编程/锁/image-20200217200947738.png" alt="image-20200217200947738"></p>
<p><img src="/2020/03/06/4悟空Java并发编程/锁/image-20200217201005490.png" alt="image-20200217201005490"></p>
<p>策略的选择取决于锁的具体实现，ReentrantReadWriteLock的实现是选择策略2，是很明智的</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>公平锁</strong></p>
<p>不允许插队</p>
<p><strong>非公平锁</strong></p>
<p>写锁可以随时插队</p>
<p>读锁仅在等待队列头结点不是获取写锁的线程的时候，才可以插队</p>
<h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Nonfair version of Sync</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8159625535654395037L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// writers can always barge</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* As a heuristic to avoid indefinite writer starvation,</span></span><br><span class="line"><span class="comment">         * block if the thread that momentarily appears to be head</span></span><br><span class="line"><span class="comment">         * of queue, if one exists, is a waiting writer.  This is</span></span><br><span class="line"><span class="comment">         * only a probabilistic effect since a new reader will not</span></span><br><span class="line"><span class="comment">         * block if there is a waiting writer behind other enabled</span></span><br><span class="line"><span class="comment">         * readers that have not yet drained from the queue.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fair version of Sync</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2274990926593161451L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="锁的升降级"><a href="#锁的升降级" class="headerlink" title="锁的升降级"></a>锁的升降级</h3><p> 为什么需要升降级</p>
<p>支持锁的降级，不支持升级</p>
<p>代码演示</p>
<h3 id="共享锁和排它锁总结"><a href="#共享锁和排它锁总结" class="headerlink" title="共享锁和排它锁总结"></a>共享锁和排它锁总结</h3><ol>
<li><p>ReentrantReadWriteLock实现了ReadWriteLock接口，最主要的有两个方法：readLock()和writeLock()用来获取读锁和写锁</p>
</li>
<li><p>锁申请和释放策略</p>
<ul>
<li><p>多个线程只能申请读锁，都可以申请到</p>
</li>
<li><p>如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁</p>
</li>
<li><p>如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放锁</p>
</li>
<li><p>要么是一个或多个线程同时有读锁，要么是一个线程有些锁，但是两者不能同时出现</p>
<p>总结：要么多读，要么一写</p>
</li>
</ul>
</li>
<li><p>插队策略</p>
<p>为了防止饥饿，读锁不能插队</p>
</li>
<li><p>升降级策略</p>
<p>只能降级，不能升级</p>
</li>
<li><p>适用场合</p>
<p>相比于ReentrantLock适用于一般场合，ReentrantReadWriteLock适用于读多写少的情况，合理使用可以进一步提高并发效率</p>
</li>
</ol>
<h2 id="自旋锁和阻塞锁"><a href="#自旋锁和阻塞锁" class="headerlink" title="自旋锁和阻塞锁"></a>自旋锁和阻塞锁</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要消耗处理器时间，如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长，在许多场景中，同步资源锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失</p>
<p>如果物理机器有多个处理器能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁</p>
<p>而为了让当前线程去检测，需要让当前线程进行自旋，如果在自旋完成后，前面锁定同步资源已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销，这就是自旋锁</p>
<p>阻塞锁和自旋锁相反，阻塞锁如果遇到没有得到锁的情况，会直接把线程阻塞，直到被唤醒</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>如果锁被占用的时间过长，那么自旋锁的线程只会白浪费处理器的资源，在自旋的过程中，一直消耗CPU，所以虽然自旋锁的起始开销低于悲观锁，但是随着自旋锁时间增加，开销也是线性增长的，开销也是线性增长的</p>
<h3 id="原理和源码分析"><a href="#原理和源码分析" class="headerlink" title="原理和源码分析"></a>原理和源码分析</h3><p>在Java1.5版本及以上的并发框架java.util.concurrent的atomic包下的类基本都是使用自旋锁实现的</p>
<p>AtomicInteger的实现</p>
<p>自旋锁的实现原理是CAS，AtomicInteger中调用unsafe进行自增操作的源码中，do-while循环就是一个自旋操作，如果修改过程中遇到其他线程竞争导致没有修改成功，就在while中死循环，直到修改成功</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     自旋锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; sign = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">while</span> (!sign.compareAndSet(<span class="keyword">null</span>, current)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"自旋获取失败，再次尝试"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        sign.compareAndSet(current, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpinLock spinLock = <span class="keyword">new</span> SpinLock();</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"开始尝试获取自旋锁"</span>);</span><br><span class="line">                spinLock.lock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"获取到了自旋锁"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">300</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    spinLock.unlock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"释放了自旋锁"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Thread-0开始尝试获取自旋锁</span><br><span class="line">Thread-0获取到了自旋锁</span><br><span class="line">Thread-1开始尝试获取自旋锁</span><br><span class="line">自旋获取失败，再次尝试</span><br><span class="line">自旋获取失败，再次尝试</span><br><span class="line">自旋获取失败，再次尝试</span><br><span class="line">自旋获取失败，再次尝试</span><br><span class="line">自旋获取失败，再次尝试</span><br><span class="line">自旋获取失败，再次尝试</span><br><span class="line">自旋获取失败，再次尝试</span><br><span class="line">自旋获取失败，再次尝试</span><br><span class="line">自旋获取失败，再次尝试</span><br><span class="line">自旋获取失败，再次尝试</span><br><span class="line">自旋获取失败，再次尝试</span><br><span class="line">自旋获取失败，再次尝试</span><br><span class="line">自旋获取失败，再次尝试</span><br><span class="line">自旋获取失败，再次尝试</span><br><span class="line">自旋获取失败，再次尝试</span><br><span class="line">自旋获取失败，再次尝试</span><br><span class="line">自旋获取失败，再次尝试</span><br><span class="line">自旋获取失败，再次尝试</span><br><span class="line">自旋获取失败，再次尝试</span><br><span class="line">自旋获取失败，再次尝试</span><br><span class="line">自旋获取失败，再次尝试</span><br><span class="line">自旋获取失败，再次尝试</span><br><span class="line">自旋获取失败，再次尝试</span><br><span class="line">自旋获取失败，再次尝试</span><br><span class="line">自旋获取失败，再次尝试</span><br><span class="line">自旋获取失败，再次尝试</span><br><span class="line">自旋获取失败，再次尝试</span><br><span class="line">自旋获取失败，再次尝试</span><br><span class="line">自旋获取失败，再次尝试</span><br><span class="line">自旋获取失败，再次尝试</span><br><span class="line">Thread-0释放了自旋锁</span><br><span class="line">Thread-1获取到了自旋锁</span><br><span class="line">Thread-1释放了自旋锁</span><br></pre></td></tr></table></figure>

<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>自旋锁一般用于多核的服务器，在并发不是特别高的情况下，比阻塞锁的效率高</p>
<p>另外，自旋锁适用于临界区比较小的情况，否则如果临界区很大（线程一旦拿到锁，很久以后才会释放），则不合适</p>
<h2 id="可中断锁"><a href="#可中断锁" class="headerlink" title="可中断锁"></a>可中断锁</h2><p>在Java中，synchronized就不是可中断锁，而Lock是可中断锁，因为tryLock(time)和lockInterruptibly都能响应中断</p>
<p>如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，用户就可以中断它，这就是可中断锁</p>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><h3 id="Java虚拟机对锁的优化"><a href="#Java虚拟机对锁的优化" class="headerlink" title="Java虚拟机对锁的优化"></a>Java虚拟机对锁的优化</h3><p>自旋锁和自适应</p>
<p>在锁的临界区很小的情况下，可以提高效率</p>
<p>自适应是在尝试自旋的时候不是盲目尝试100万遍，而是尝试10次、20次，如果得不到锁，就转为阻塞锁</p>
<p>锁消除</p>
<p>有一些场景不必要加锁，某段代码就在方法内部的，并且所有同步的代码都在方法内部，此时不会有外部用户访问这个方法的内部资源，此时虚拟机会分析出来，认为这些资源是私有的，无需加锁，就把该锁消除了</p>
<p>锁粗化</p>
<h3 id="在写代码的时候如何优化锁和提高并发性能"><a href="#在写代码的时候如何优化锁和提高并发性能" class="headerlink" title="在写代码的时候如何优化锁和提高并发性能"></a>在写代码的时候如何优化锁和提高并发性能</h3><ol>
<li><p>缩小同步代码块</p>
</li>
<li><p>尽量不要锁住方法</p>
</li>
<li><p>减少请求锁的次数</p>
</li>
<li><p>避免人为制造“热点”</p>
</li>
<li><p>锁中尽量不要再包含锁</p>
</li>
<li><p>选择合适的锁类型或合适的工具类</p>
</li>
</ol>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2020/03/06/4悟空Java并发编程/锁/">锁</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">爱吃鱼的呆先生</a></p>
        <p><span>发布时间:</span>2020-03-06, 17:41:28</p>
        <p><span>最后更新:</span>2020-02-18, 10:32:47</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2020/03/06/4悟空Java并发编程/锁/" title="锁">http://yoursite.com/2020/03/06/4悟空Java并发编程/锁/</a>
            <span class="copy-path" data-clipboard-text="原文: http://yoursite.com/2020/03/06/4悟空Java并发编程/锁/　　作者: 爱吃鱼的呆先生" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2020/03/10/0编程工具/Linux/">
                    Linux1
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2020/03/06/4悟空Java并发编程/详解之同步synchronized/">
                    多线程二之高并发详解之同步synchronized关键字
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#锁"><span class="toc-number">1.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lock接口"><span class="toc-number">1.1.</span> <span class="toc-text">Lock接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介、地位、作用"><span class="toc-number">1.1.1.</span> <span class="toc-text">简介、地位、作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么synchronizd不够用为什么需要Lock"><span class="toc-number">1.1.2.</span> <span class="toc-text">为什么synchronizd不够用为什么需要Lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock主要方法介绍"><span class="toc-number">1.1.3.</span> <span class="toc-text">Lock主要方法介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Lock"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">Lock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tryLock"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">tryLock()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tryLock-long-time-TimeUnit-unit"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">tryLock(long time,TimeUnit unit)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lockInterruptibly"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">lockInterruptibly()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unlock"><span class="toc-number">1.1.3.5.</span> <span class="toc-text">unlock()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可见性保证"><span class="toc-number">1.1.4.</span> <span class="toc-text">可见性保证</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁分类"><span class="toc-number">1.2.</span> <span class="toc-text">锁分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#乐观锁和悲观锁"><span class="toc-number">1.3.</span> <span class="toc-text">乐观锁和悲观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#互斥锁同步锁的劣势"><span class="toc-number">1.3.1.</span> <span class="toc-text">互斥锁同步锁的劣势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是乐观锁和悲观锁"><span class="toc-number">1.3.2.</span> <span class="toc-text">什么是乐观锁和悲观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#典型例子"><span class="toc-number">1.3.3.</span> <span class="toc-text">典型例子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#例子一"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">例子一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#例子二"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">例子二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#例子三"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">例子三</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#开销对比"><span class="toc-number">1.3.4.</span> <span class="toc-text">开销对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用场景"><span class="toc-number">1.3.5.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可重入锁和非可重入锁"><span class="toc-number">1.4.</span> <span class="toc-text">可重入锁和非可重入锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是可重入"><span class="toc-number">1.4.1.</span> <span class="toc-text">什么是可重入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可重入的性质"><span class="toc-number">1.4.2.</span> <span class="toc-text">可重入的性质</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#源码对比：可重入锁ReentrantLock以及非可重入锁ThreadPoolExcutor的Worker类"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">源码对比：可重入锁ReentrantLock以及非可重入锁ThreadPoolExcutor的Worker类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReentrantLock的其他方法介绍"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">ReentrantLock的其他方法介绍</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#公平锁和非公平锁"><span class="toc-number">1.5.</span> <span class="toc-text">公平锁和非公平锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是公平和非公平"><span class="toc-number">1.5.1.</span> <span class="toc-text">什么是公平和非公平</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要有非公平锁"><span class="toc-number">1.5.2.</span> <span class="toc-text">为什么要有非公平锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#公平情况（以ReentrantLock为例）"><span class="toc-number">1.5.3.</span> <span class="toc-text">公平情况（以ReentrantLock为例）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不公平的情况（以ReentrantLock为例）"><span class="toc-number">1.5.4.</span> <span class="toc-text">不公平的情况（以ReentrantLock为例）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码案例：演示公平和非公平的效果"><span class="toc-number">1.5.5.</span> <span class="toc-text">代码案例：演示公平和非公平的效果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特例"><span class="toc-number">1.5.6.</span> <span class="toc-text">特例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对比公平和非公平的优缺点"><span class="toc-number">1.5.7.</span> <span class="toc-text">对比公平和非公平的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#源码分析"><span class="toc-number">1.5.8.</span> <span class="toc-text">源码分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#共享锁和排它锁"><span class="toc-number">1.6.</span> <span class="toc-text">共享锁和排它锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是共享锁和排它锁"><span class="toc-number">1.6.1.</span> <span class="toc-text">什么是共享锁和排它锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#读写锁的作用"><span class="toc-number">1.6.2.</span> <span class="toc-text">读写锁的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#读写锁的规则"><span class="toc-number">1.6.3.</span> <span class="toc-text">读写锁的规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantReadWriteLock具体用法"><span class="toc-number">1.6.4.</span> <span class="toc-text">ReentrantReadWriteLock具体用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#读锁和写锁的交互方式"><span class="toc-number">1.6.5.</span> <span class="toc-text">读锁和写锁的交互方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ReentrantReadWriteLock的实现"><span class="toc-number">1.6.5.1.</span> <span class="toc-text">ReentrantReadWriteLock的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#读锁插队策略"><span class="toc-number">1.6.6.</span> <span class="toc-text">读锁插队策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-number">1.6.6.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#源码分析-1"><span class="toc-number">1.6.7.</span> <span class="toc-text">源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#锁的升降级"><span class="toc-number">1.6.8.</span> <span class="toc-text">锁的升降级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#共享锁和排它锁总结"><span class="toc-number">1.6.9.</span> <span class="toc-text">共享锁和排它锁总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自旋锁和阻塞锁"><span class="toc-number">1.7.</span> <span class="toc-text">自旋锁和阻塞锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概念"><span class="toc-number">1.7.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缺点"><span class="toc-number">1.7.2.</span> <span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原理和源码分析"><span class="toc-number">1.7.3.</span> <span class="toc-text">原理和源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#适用场景"><span class="toc-number">1.7.4.</span> <span class="toc-text">适用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可中断锁"><span class="toc-number">1.8.</span> <span class="toc-text">可中断锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁优化"><span class="toc-number">1.9.</span> <span class="toc-text">锁优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java虚拟机对锁的优化"><span class="toc-number">1.9.1.</span> <span class="toc-text">Java虚拟机对锁的优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在写代码的时候如何优化锁和提高并发性能"><span class="toc-number">1.9.2.</span> <span class="toc-text">在写代码的时候如何优化锁和提高并发性能</span></a></li></ol></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"锁　| 爱吃鱼的呆先生　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2020/03/10/0编程工具/Linux/" title="上一篇: Linux1">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2020/03/06/4悟空Java并发编程/详解之同步synchronized/" title="下一篇: 多线程二之高并发详解之同步synchronized关键字">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/05/07/Mybatis/1mybatis高级原理分析/">1mybatis高级原理分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/07/Mybatis/Mybatis基础1/">mybatis基础详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/04/Vue/Vue1/">Vue/Vue1</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/03/面试/简历/">面试/简历</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/01/SpringDataJPA/SpringDataJPA/">SpringDataJPA</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/01/ELK/Logstash/">Logstash</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/01/ELK/ElasticSearch/">ElasticSearch</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/29/0编程工具/easyExcel/">easyExcel</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/28/ZooKeeper/3Zookeeper/">第1章Zookeeper理论基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/24/Spring/2Spring核心理解/">Spring/2Spring核心理解</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/23/数据结构/动态规划/">数据结构/动态规划</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/21/Json/Json/">Json详解以及fastjson使用教程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/18/SpringMVC/SpringMVC/">SpringMVC/SpringMVC</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/18/Kafka/Kafka/">Kafka/Kafka</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/14/0编程工具/Idea/">Idea</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/31/9Redis/1Redis/">Redis1</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/29/SpringCloud/1SpringCloud/">Spring Cloud基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/29/ZooKeeper/1Zookeeper/">第1章Zookeeper理论基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/8MySQL/4MySQL/">8MySQL/4MySQL</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/24/8MySQL/3MySQL/">8MySQL/3MySQL</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/21/8MySQL/2MySQL/">8MySQL/2MySQL</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/20/8MySQL/1MySQL/">MySQL介绍和基本的SQL编写及解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/19/0编程工具/Linux5/">0编程工具/Linux5</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/17/0编程工具/Linux3/">Linux3</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/15/0编程工具/Linux2/">Linux2</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/15/数据结构/2栈和队列/">栈和队列</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/15/数据结构/1数组/">数组</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/10/0编程工具/Linux/">Linux1</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/锁/">锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/详解之同步synchronized/">多线程二之高并发详解之同步synchronized关键字</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/线程8大核心基础/">多线程三之线程8大核心基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/治理线程的第二法宝/">4悟空Java并发编程/治理线程的第二法宝</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/控制并发流程/">4悟空Java并发编程/控制并发流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/并发编程的基石/">多线程一之并发编程的基石</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/并发工具类纵览/">并发工具类</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/并发容器精讲/">4悟空Java并发编程/并发容器精讲</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/实战项目/">4悟空Java并发编程/实战项目</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/原子类/">原子类</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/ThreadLocal详解/">ThreadLocal详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/Java内存模型之底层原理/">Java内存模型之底层原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/AQS/">4悟空Java并发编程/AQS</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/3Java高级/Java反射机制/">Java反射机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/3Java高级/Java8新特性/">Java8新特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/3Java高级/IO流/">IO流</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/2Java常用类/String类型相关习题/">String类型相关习题</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/2Java常用类/StringBuffer与StringBuilder/">StringBuffer与StringBuilder</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/2Java常用类/1String与String相关的类/">String详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/1Java基础/面向对象二5/">面向对象二</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/1Java基础/面向对象三6/">面向对象三</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/1Java基础/面向对象一4/">面向对象一</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/1Java基础/数组8/">数组</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/1Java基础/排序算法/">十大排序算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/1Java基础/异常7/">异常处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/1Java基础/八大排序算法9/">八大排序算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/1Java基础/代码简洁之道/">代码简洁之道</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/1Java基础/java3流程控制/">1Java基础/java3流程控制</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/1Java基础/Java2基本语法/">1Java基础/Java2基本语法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/1Java基础/Java1概述/">Java概述</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/06/0编程工具/Git&GitHub/">Git&GitHub</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/13/MybatisPlus/MyBatisPlus/">MyBatisPlus</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2019-2020 爱吃鱼的呆先生
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>