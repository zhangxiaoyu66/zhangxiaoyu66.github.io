<!DOCTYPE html>
<html lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="爱吃鱼的呆先生">



<meta name="description" content="线程8大核心基础实现多线程的方法到底有1种还是2种还是4种网上说法1种的观点，2种的观点，4种的观点，其他观点 正确说法Oracle官网的文档是如何写的？ 正确答案是2种 1There are two ways to create a new thread of execution. One is to declare a class to be a subclass of Thread. Thi">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="多线程三之线程8大核心基础">
<meta property="og:url" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/线程8大核心基础/index.html">
<meta property="og:site_name" content="爱吃鱼的呆先生">
<meta property="og:description" content="线程8大核心基础实现多线程的方法到底有1种还是2种还是4种网上说法1种的观点，2种的观点，4种的观点，其他观点 正确说法Oracle官网的文档是如何写的？ 正确答案是2种 1There are two ways to create a new thread of execution. One is to declare a class to be a subclass of Thread. Thi">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/线程8大核心基础/FutureTask.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/线程8大核心基础/image-20200304212936052.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/线程8大核心基础/image-20200305131453211.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/线程8大核心基础/1.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/线程8大核心基础/image-20200305222403686.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/线程8大核心基础/image-20200305223245960.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/线程8大核心基础/image-20200306075851814.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/线程8大核心基础/2.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/线程8大核心基础/3.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/线程8大核心基础/4.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/线程8大核心基础/image-20200307131526595.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/线程8大核心基础/image-20200202005758106.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/线程8大核心基础/image-20200307192244172.png">
<meta property="og:updated_time" content="2020-03-09T11:16:25.516Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="多线程三之线程8大核心基础">
<meta name="twitter:description" content="线程8大核心基础实现多线程的方法到底有1种还是2种还是4种网上说法1种的观点，2种的观点，4种的观点，其他观点 正确说法Oracle官网的文档是如何写的？ 正确答案是2种 1There are two ways to create a new thread of execution. One is to declare a class to be a subclass of Thread. Thi">
<meta name="twitter:image" content="http://yoursite.com/2020/03/06/4悟空Java并发编程/线程8大核心基础/FutureTask.png">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="爱吃鱼的呆先生" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>多线程三之线程8大核心基础 | 爱吃鱼的呆先生</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: false
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">爱吃鱼的呆先生</a></h1>
        </hgroup>

        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云与分类</a></li>
                        
                            <li><a href="/pdfdocuments/">pdf文档笔记</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="https://mail.163.com/" title="Email"></a>
                            
                                <a class="fa CSDN" href="https://www.csdn.net/" title="CSDN"></a>
                            
                                <a class="fa Coding" href="https://coding.net/login" title="Coding"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElasticSearch/">ElasticSearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Idea/">Idea</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Json/">Json</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Logstash/">Logstash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatisPlus/">MyBatisPlus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL基础/">MySQL基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Cloud/">Spring Cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringDataJPA/">SpringDataJPA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/String/">String</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zookeeper/">Zookeeper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/easyExcel/">easyExcel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://mybatis.org/mybatis-3/zh/index.html">Mybatis</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://spring.io/projects/spring-framework#overview">Spring</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://spring.io/projects/spring-boot">SpringBoot</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">真正的大师永远保持一颗学徒的心</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">爱吃鱼的呆先生</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">爱吃鱼的呆先生</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云与分类</a></li>
                
                    <li><a href="/pdfdocuments/">pdf文档笔记</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="https://mail.163.com/" title="Email"></a>
                            
                                <a class="fa CSDN" target="_blank" href="https://www.csdn.net/" title="CSDN"></a>
                            
                                <a class="fa Coding" target="_blank" href="https://coding.net/login" title="Coding"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-4悟空Java并发编程/线程8大核心基础" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/06/4悟空Java并发编程/线程8大核心基础/" class="article-date">
      <time datetime="2020-03-06T09:41:28.653Z" itemprop="datePublished">2020-03-06</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      多线程三之线程8大核心基础
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java多线程/">Java多线程</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="线程8大核心基础"><a href="#线程8大核心基础" class="headerlink" title="线程8大核心基础"></a>线程8大核心基础</h1><h2 id="实现多线程的方法到底有1种还是2种还是4种"><a href="#实现多线程的方法到底有1种还是2种还是4种" class="headerlink" title="实现多线程的方法到底有1种还是2种还是4种"></a>实现多线程的方法到底有1种还是2种还是4种</h2><h3 id="网上说法"><a href="#网上说法" class="headerlink" title="网上说法"></a>网上说法</h3><p>1种的观点，2种的观点，4种的观点，其他观点</p>
<h3 id="正确说法"><a href="#正确说法" class="headerlink" title="正确说法"></a>正确说法</h3><p>Oracle官网的文档是如何写的？</p>
<p>正确答案是2种</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">There are two ways to create a new thread of execution. One is to declare a class to be a subclass of Thread. This subclass should override the run method of class Thread. An instance of the subclass can then be allocated and started.</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The other way to create a thread is to declare a class that implements the Runnable interface. That class then implements the run method. An instance of the class can then be allocated, passed as an argument when creating Thread, and started.</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>实现Runnable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：用Runnable方式创建线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableStyle</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunnableStyle());</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用Runnable方法实现线程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用Runnable方法实现线程</span><br></pre></td></tr></table></figure>

<!--more-->

<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>继承Thread类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：用Thread方式实现线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStyle</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用Thread类实现线程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ThreadStyle().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用Thread类实现线程</span><br></pre></td></tr></table></figure>

<h3 id="两种方法的对比"><a href="#两种方法的对比" class="headerlink" title="两种方法的对比"></a>两种方法的对比</h3><p>方法一（实现Runnable接口）更好</p>
<ol>
<li>从代码架构去考虑，具体的执行任务（run方法）应该与线程的创建与运行的机制（也就是Thread类）是解耦的，不应该把这两件事混为一坛，从解耦的角度实现Runnable接口更好</li>
<li>继承Thread类每次想新建一个任务，只能新建一个独立的线程，而新建一个独立的线程是十分消耗资源的，需要创建、执行、销毁，而使用Runnable就可以使用后续的像线程池这样的工具来减少这些资源的损耗</li>
<li>因为Java不支撑双继承，导致一个类无法继承多个类，这样就限制了可扩展性</li>
</ol>
<h3 id="两种方法的本质区别"><a href="#两种方法的本质区别" class="headerlink" title="两种方法的本质区别"></a>两种方法的本质区别</h3><p>方法一（实现Runnable接口）：最终调用<code>target.run();</code></p>
<p>当实现Runnable接口的时候，实际是传入一个target对象，在执行<code>run()</code>方法时候由于target不为null就执行了<code>target.run()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Thread构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Thread类中的target变量</span></span><br><span class="line"><span class="keyword">private</span> Runnable target;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Thread类中的run()方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二（继承Thread类）：run()整个都被重写</p>
<p>继承Thread类，并重写<code>run()</code>方法，一旦重写，<code>run()</code>中的方法就不会被使用，而是重写新的方法，将只执行<code>run()</code>方法里的内容，其他不会执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>同时用两种方法会怎么样?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：同时使用Runnable和Thread两种实现线程的方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BothRunnableThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"我来自Runnable"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"我来自Thread"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我来自Thread</span><br></pre></td></tr></table></figure>

<p>从面向对象的思想去考虑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我来自Thread"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>覆盖了之前的的<code>run()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我来自Runnable"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以输出结果就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我来自Thread</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最精准的描述</p>
<p>通常我们可以分为两类，Oracle也是这么说</p>
<p>准确的讲，创建线程只有一种方式那就是构造Thread类，而实现线程的执行单元有两种方式</p>
<ul>
<li>方法一：实现Runnable接口的run()方法，并把Runnable实例传给Thread类</li>
<li>方法二：重写Thread的run()方法（继承Thread类）</li>
</ul>
<h3 id="经典错误观点"><a href="#经典错误观点" class="headerlink" title="经典错误观点"></a>经典错误观点</h3><p><strong>“线程池创建线程也是一种新建线程的方式”</strong> 错误</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            executorService.submit(<span class="keyword">new</span> Task() &#123;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>newCachedThreadPool方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>newCachedThreadPool方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>defaultThreadFactory方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadFactory <span class="title">defaultThreadFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultThreadFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DefaultThreadFactory方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default thread factory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">    DefaultThreadFactory() &#123;</span><br><span class="line">        SecurityManager s = System.getSecurityManager();</span><br><span class="line">        group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                              Thread.currentThread().getThreadGroup();</span><br><span class="line">        namePrefix = <span class="string">"pool-"</span> +</span><br><span class="line">                      poolNumber.getAndIncrement() +</span><br><span class="line">                     <span class="string">"-thread-"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重点在这里，要注意</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                              namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                              <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">            t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">            t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这里看出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重点在这里，要注意</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                          namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                          <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">        t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">        t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程池同样是通过Runnable接口实现</p>
<p><strong>“通过Callable和FutureTask创建线程，也算是一种新建线程的方式”</strong> 错误</p>
<p><img src="/2020/03/06/4悟空Java并发编程/线程8大核心基础/FutureTask.png" alt></p>
<p><strong>“无返回值是实现runnable接口，有返回值是实现callable接口，所以callable是新的实现线程的方式”</strong>错误</p>
<p>此方法与上面类似</p>
<p>Callable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FutureTask构造函数中传入Callable</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.callable = callable;</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FutureTask中的<code>run()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//看这里，注意</span></span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定时器</strong> 错误</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：定时器创建线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTimmerTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        timer.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span>, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>匿名内部类</strong> 错误</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     匿名内部类的方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousInnerClassDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Lambda表达式</strong> 错误</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     lambda表达式创建线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lambda</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; System.out.println(Thread.currentThread().getName())).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>多线程的实现方式，在代码中写法千变万化，但是本质万变不离其宗</p>
<h3 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h3><h4 id="如何从宏观和微观两个方面来提高技术"><a href="#如何从宏观和微观两个方面来提高技术" class="headerlink" title="如何从宏观和微观两个方面来提高技术"></a>如何从宏观和微观两个方面来提高技术</h4><p>宏观上</p>
<ol>
<li>并不是靠工作年限，有的人工作了5年技术却还是只懂皮毛</li>
<li>要有强大的责任心，不放过任何bug，找到原因并去解决，这就是提高</li>
<li>主动：永远不会觉得自己的时间多余，重构、优化、学习、总结等</li>
<li>敢于承担：虽然这个技术难题以前没有碰到过，但是在一定的了解调研后，敢于承担技术难题，让工作充满挑战，这一次次攻克难关的过程中，进步是飞速的</li>
<li>关心产品，关心业务，而不只是写代码</li>
</ol>
<p>微观上</p>
<ol>
<li><p>看经典书籍（指外国人写的经典的中国译本，比如所Java并发编程实战、自定向下计算机网络）</p>
</li>
<li><p>看官方文档</p>
</li>
<li><p>英文搜google和stackoverflow</p>
</li>
<li><p>自己动手写，实践demo，尝试用到项目里</p>
</li>
<li><p>不理解的领域参考多个书本，综合判断</p>
</li>
<li><p>学习开源项目，分析源码</p>
</li>
</ol>
<h4 id="如何了解技术领域的前沿动态"><a href="#如何了解技术领域的前沿动态" class="headerlink" title="如何了解技术领域的前沿动态"></a>如何了解技术领域的前沿动态</h4><p>高质量固定途径：ohmyrss.com（信息源筛选，为我所用）</p>
<p>订阅技术网站的邮件：InfoQ（每周都看）</p>
<h3 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h3><p><strong>面试第一题</strong></p>
<p>有多少种实现线程的方法？</p>
<p>思路有5点</p>
<ol>
<li>从不同角度看，会有不同的答案</li>
<li>典型答案是两种</li>
<li>我们看原理，两种本质都是一样的</li>
<li>具体展开说</li>
<li>结论</li>
</ol>
<p><strong>面试第二题</strong></p>
<p>实现Runnable接口和继承Thread类哪种方式更好？</p>
<ol>
<li>从代码架构角度</li>
<li>新建线程的损耗</li>
<li>Java不支持双继承</li>
</ol>
<h2 id="启动线程的正确和错误方式"><a href="#启动线程的正确和错误方式" class="headerlink" title="启动线程的正确和错误方式"></a>启动线程的正确和错误方式</h2><h3 id="start-和run-的比较"><a href="#start-和run-的比较" class="headerlink" title="start()和run()的比较"></a>start()和run()的比较</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：对比start和run两种启动线程的方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartAndRunMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        runnable.run();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">Thread-0</span><br></pre></td></tr></table></figure>

<p>第一个输出的结果为<code>main</code>说明是主线程执行的<code>run()</code>方法中内部的代码，第二个输出结果为<code>Thread-0</code>说明是子线程<code>Thread-0</code>输出的结果</p>
<h3 id="start-方法原理解读"><a href="#start-方法原理解读" class="headerlink" title="start()方法原理解读"></a>start()方法原理解读</h3><h4 id="start-方法含义12"><a href="#start-方法含义12" class="headerlink" title="start()方法含义12"></a>start()方法含义12</h4><h5 id="1启动新线程"><a href="#1启动新线程" class="headerlink" title="1启动新线程"></a>1启动新线程</h5><p>线程对象在初始化之后调用start()方法，于是当前线程（通常是主线程）告诉JVM虚拟机，如果有空闲时间，就执行新的线程，至于何时能运行，并不是我们能决定的，而是由线程调度器决定的，即start()方法运行之后并不能确定线程已经运行了，可能稍后运行，也可能很长时间之后都不会运行（遇到饥饿的情况）</p>
<p>我们调用线程的顺序并不能决定线程执行的顺序，只是告诉JVM在合适的时候来启动</p>
<p>start()方法其实是父线程（主线程）执行的，start()方法被父线程（主线程）执行之后才会创建新线程</p>
<h5 id="2start-方法的准备工作"><a href="#2start-方法的准备工作" class="headerlink" title="2start()方法的准备工作"></a>2start()方法的准备工作</h5><p>start()方法被父线程（主线程）执行之后才会创建新线程，而新创建出来的线程需要做一些准备工作才能去执行，</p>
<p>首先新线程会处于就绪状态，即已经获取到除了CPU以外的所有资源</p>
<h5 id="不能重复执行start-方法"><a href="#不能重复执行start-方法" class="headerlink" title="不能重复执行start()方法"></a>不能重复执行start()方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 描述：演示不能两次调用start方法，否则会报错</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CantStartTwice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread();</span><br><span class="line">    thread.start();</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalThreadStateException</span><br><span class="line">	at java.lang.Thread.start(Thread.java:708)</span><br><span class="line">	at threadcoreknowledge.startthread.CantStartTwice.main(CantStartTwice.java:10)</span><br></pre></td></tr></table></figure>

<h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>1启动新线程检查线程状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Java thread status for tools,</span></span><br><span class="line"><span class="comment"> * initialized to indicate thread 'not yet started'</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> threadStatus = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br></pre></td></tr></table></figure>

<p>2加入线程组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">group.add(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<p>3调用start0()</p>
<p>start0()方法是native底层方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    start0();</span><br><span class="line">    started = <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">            group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">        <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">          it will be passed up the call stack */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="run-方法原理解读"><a href="#run-方法原理解读" class="headerlink" title="run()方法原理解读"></a>run()方法原理解读</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">		target.run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常见面试题-1"><a href="#常见面试题-1" class="headerlink" title="常见面试题"></a>常见面试题</h3><p>1一个线程两次调用start()方法会出现什么情况？为什么？</p>
<p>2既然start()方法会调用run()方法，为什么选择调用start()方法，而不是直接调用run()方法？</p>
<p>start()方法才是真正意义上的启动一个线程，才会经历线程生命的各个周期，而直接调用run()方法，它就是一个普通的方法，也不会用子线程调用</p>
<h2 id="如何正确停止线程"><a href="#如何正确停止线程" class="headerlink" title="如何正确停止线程"></a>如何正确停止线程</h2><h3 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h3><p>使用interrupet来通知，而不是强制，将停止线程的权利交个被停止的线程本身</p>
<h3 id="最佳实践：如何正确停止线程"><a href="#最佳实践：如何正确停止线程" class="headerlink" title="最佳实践：如何正确停止线程"></a>最佳实践：如何正确停止线程</h3><h4 id="通常线程会在什么情况下停止"><a href="#通常线程会在什么情况下停止" class="headerlink" title="通常线程会在什么情况下停止"></a>通常线程会在什么情况下停止</h4><ol>
<li>包含run()方法的所有方法都执行完毕，正常执行完</li>
<li>有异常出现，并且没有进行捕获，就会出现停止</li>
</ol>
<p><strong>正确的停止方式：使用interrupt</strong></p>
<h4 id="使用interrupt的几种情况"><a href="#使用interrupt的几种情况" class="headerlink" title="使用interrupt的几种情况"></a>使用interrupt的几种情况</h4><h5 id="1正常情况下停止线程"><a href="#1正常情况下停止线程" class="headerlink" title="1正常情况下停止线程"></a>1正常情况下停止线程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：run方法内没有sleep或wait方法时，停止线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightWayStopThreadWithoutSleep</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="comment">//打印出最大整数一半以内所有是10000的倍数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//注意这里</span></span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted() &amp;&amp; num &lt;= Integer.MAX_VALUE / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">10000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(num + <span class="string">"是10000的倍数"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"任务运行结束了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RightWayStopThreadWithoutSleep());</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在执行interrupt的同时还要添加<code>!Thread.currentThread().isInterrupted()</code>才能真正的执行终止操作</p>
<h5 id="2线程被阻塞的时候停止线程"><a href="#2线程被阻塞的时候停止线程" class="headerlink" title="2线程被阻塞的时候停止线程"></a>2线程被阻塞的时候停止线程</h5><p>在线程sleep的时候中断线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 描述：带有sleep的中断线程的写法，打出100的倍数，打出几个100的倍数之后，该线程进入等待，在等待的时候突  *  然被其他的线程中断</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightWayStopThreadWithSleep</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//注意这里</span></span><br><span class="line">                <span class="keyword">while</span> (num &lt;= <span class="number">300</span> &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (num % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(num + <span class="string">"是100的倍数"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0是100的倍数</span><br><span class="line">100是100的倍数</span><br><span class="line">200是100的倍数</span><br><span class="line">300是100的倍数</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">	at java.lang.Thread.sleep(Native Method)</span><br><span class="line">	at threadcoreknowledge.stopthreads.RightWayStopThreadWithSleep.lambda$main$0(RightWayStopThreadWithSleep.java:18)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>

<h5 id="3如果线程在每次迭代的时候都阻塞"><a href="#3如果线程在每次迭代的时候都阻塞" class="headerlink" title="3如果线程在每次迭代的时候都阻塞"></a>3如果线程在每次迭代的时候都阻塞</h5><p>在<code>Thread.sleep(10)</code>阻塞的过程中，在阻塞的过程中收到终止线程，此时就会抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：如果在执行过程中，每次循环都会调用sleep或wait等方法，那么不需要每次迭代都检查是否已中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightWayStopThreadWithSleepEveryLoop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//注意这里</span></span><br><span class="line">                <span class="keyword">while</span> (num &lt;= <span class="number">10000</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (num % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(num + <span class="string">"是100的倍数"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    num++;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0是100的倍数</span><br><span class="line">100是100的倍数</span><br><span class="line">200是100的倍数</span><br><span class="line">300是100的倍数</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">	at java.lang.Thread.sleep(Native Method)</span><br><span class="line">	at threadcoreknowledge.stopthreads.RightWayStopThreadWithSleepEveryLoop.lambda$main$0(RightWayStopThreadWithSleepEveryLoop.java:16)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>

<h5 id="4while内try-catch的问题"><a href="#4while内try-catch的问题" class="headerlink" title="4while内try/catch的问题"></a>4while内try/catch的问题</h5><p>如果while里面放try/catch，会导致中断失效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：如果while里面放try/catch，会导致中断失效</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CantInterrupt</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (num &lt;= <span class="number">10000</span> &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(num + <span class="string">"是100的倍数"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0是100的倍数</span><br><span class="line">100是100的倍数</span><br><span class="line">200是100的倍数</span><br><span class="line">300是100的倍数</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">	at java.lang.Thread.sleep(Native Method)</span><br><span class="line">	at threadcoreknowledge.stopthreads.CantInterrupt.lambda$main$0(CantInterrupt.java:17)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">400是100的倍数</span><br><span class="line">500是100的倍数</span><br><span class="line">600是100的倍数</span><br><span class="line">700是100的倍数</span><br><span class="line">800是100的倍数</span><br></pre></td></tr></table></figure>

<p>Java语言在设计sleep函数的时候有这样一个理念，就是当线程响应中断的时候，便会把线程的interrupt的标志位清除</p>
<h4 id="实际开发中的两种最佳实践"><a href="#实际开发中的两种最佳实践" class="headerlink" title="实际开发中的两种最佳实践"></a>实际开发中的两种最佳实践</h4><p><strong>1优先选择</strong></p>
<p>传递中断异常</p>
<p>错误情形：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightWayStopThreadInProd</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span> &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"go"</span>);</span><br><span class="line">            throwInMethod();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">throwInMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注意这里try/catch语句，异常要抛到run()方法层</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RightWayStopThreadInProd());</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">go</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">	at java.lang.Thread.sleep(Native Method)</span><br><span class="line">	at threadcoreknowledge.stopthreads.RightWayStopThreadInProd.throwInMethod(RightWayStopThreadInProd.java:20)</span><br><span class="line">	at threadcoreknowledge.stopthreads.RightWayStopThreadInProd.run(RightWayStopThreadInProd.java:14)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">go</span><br><span class="line">go</span><br><span class="line">go</span><br><span class="line">go</span><br><span class="line">go</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>因为数据太多导致很难注意到错误的结果，即使添加<code>Thread.currentThread().isInterrupted()</code>也无法进行中断，<code>throwInMethod()</code>把异常给吞了，没有进行上报处理，没有交给用户</p>
<p>正确情形：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：最佳实践：catch了InterruptedExcetion之后的优先选择在方法签名中抛出异常 </span></span><br><span class="line"><span class="comment"> *  如果这样做那么在run()就会强制对异常进行try/catch</span></span><br><span class="line"><span class="comment"> *	方法声明的两个组件构成了方法签名 - 方法的名称和参数类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightWayStopThreadInProd</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span> &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"go"</span>);</span><br><span class="line">            <span class="comment">//注意这里，抛出的异常应该在run()方法中</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                throwInMethod();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                <span class="comment">//保存日志、停止程序</span></span><br><span class="line">                <span class="comment">//以这种方式可以正确的处理响应中断请求的，如果被中断，就可以按照我们的业务逻辑去进行响应</span></span><br><span class="line">                System.out.println(<span class="string">"保存日志"</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意这里，如果要抛出异常，最好把异常抛出去，由顶层的调用方进行处理</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">throwInMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RightWayStopThreadInProd());</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>在run()中出现的异常最高只能在run()方法中进行处理，而不能继续向外抛，即在run()方法中只能使用try/catch而不能使用throw Exception</p>
<p>此时就会抛出异常</p>
<p><img src="/2020/03/06/4悟空Java并发编程/线程8大核心基础/image-20200304212936052.png" alt="image-20200304212936052"></p>
<p>在run()方法中进行try/carch处理，就不会抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：run无法抛出checked Exception，只能用try/catch</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunThrowException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aVoid</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2不想或无法传递异常</strong></p>
<p>恢复中断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：最佳实践2：在catch子语句中调用Thread.currentThread().interrupt()来恢复设置中断状态，以便于在后续的执行中，依然能够检查到刚才发生了中断</span></span><br><span class="line"><span class="comment"> * 回到刚才RightWayStopThreadInProd补上中断，让它跳出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightWayStopThreadInProd2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//此时要进行是否被中断的检测</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Interrupted，程序运行结束"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            reInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">//注意这里</span></span><br><span class="line">            <span class="comment">//抛出异常的时候重新设置中断，没有自我独吞，而是重新抛了出来</span></span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RightWayStopThreadInProd2());</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">	at java.lang.Thread.sleep(Native Method)</span><br><span class="line">	at threadcoreknowledge.stopthreads.RightWayStopThreadInProd2.reInterrupt(RightWayStopThreadInProd2.java:22)</span><br><span class="line">	at threadcoreknowledge.stopthreads.RightWayStopThreadInProd2.run(RightWayStopThreadInProd2.java:16)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">Interrupted，程序运行结束</span><br></pre></td></tr></table></figure>

<p>在获取到interrupt的时候应该在catch语句中再次调用Thread.currentThread().interrupt() ，这样就把中断重新设置了一遍，在后续的执行中就能检测出后续的中断，并由后续的逻辑继续处理</p>
<p><strong>3不应屏蔽中断</strong></p>
<p>此方法是最不应该做的，既不在方法中抛出，也不在catch语句中重新恢复中断，这样就屏蔽了中断请求，这绝对不是什么好事</p>
<h3 id="响应中断的方法总结列表"><a href="#响应中断的方法总结列表" class="headerlink" title="响应中断的方法总结列表"></a>响应中断的方法总结列表</h3><p>如果一个中断信号过来，wait/sleep/join是可以感知到的，这就是拥有响应中断的能力</p>
<p>一下这10种情况都是可以响应中断的，如果通过这10个方法使线程进入阻塞状态，我们又想让这些线程从阻塞状态恢复，就可以使用interrupt()方法来及时的中断线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object.wait()/wait(long)/wait(long,int)</span><br><span class="line">Thread.sleep(long)/sleep(long,int)</span><br><span class="line">Thread.join()/join(long)/join(long,int)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.BlockingQueue.take()/put(E)<span class="comment">//阻塞队列</span></span><br><span class="line">java.util.concurrent.locks.Lock.lockInterruptibly()<span class="comment">//锁</span></span><br><span class="line">java.util.concurrent.CountDownLatch.await()</span><br><span class="line">java.util.concurrent.CyclicBarrier.await()</span><br><span class="line">java.util.concurrent.Exchanger.exchange(V)</span><br><span class="line">java.nio.channels.InterruptibleChannel相关方法</span><br><span class="line">java.nio.channels.Selector的相关方法</span><br></pre></td></tr></table></figure>

<p>以上十个情况都可以响应我们的中断的，如果通过以上十个状态使线程进入阻塞状态，又想从阻塞状态恢复，就可以使用interrupt()方法来中断线程</p>
<h3 id="正确停止带来的好处"><a href="#正确停止带来的好处" class="headerlink" title="正确停止带来的好处"></a>正确停止带来的好处</h3><p>首先被中断的线程自身拥有响应中断的权利，因为有些线程的某些代码是非常重要的，我们必须等到这些线程处理完之后，或者这些线程准备好之后，再由它们主动终止，或者完全不理会中断也是可以的，而不是鲁莽的使用stop()方法，而是使用interrupt()方法来发出一个信号，让它们自己来处理，这样会更安全</p>
<h3 id="错误的停止方法"><a href="#错误的停止方法" class="headerlink" title="错误的停止方法"></a>错误的停止方法</h3><h4 id="1被弃用的stop方法"><a href="#1被弃用的stop方法" class="headerlink" title="1被弃用的stop方法"></a>1被弃用的stop方法</h4><p>正常情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//模拟指挥军队：一共有5个连队，每个连队10人，以连队为单位，发放武器弹药，叫到号的士兵前去领取</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"连队"</span> + i + <span class="string">"开始领取武器"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                System.out.println(j);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"连队"</span>+i+<span class="string">"已经领取完毕"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> StopThread());</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">连队0开始领取武器</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">连队0已经领取完毕</span><br><span class="line">连队1开始领取武器</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">连队1已经领取完毕</span><br><span class="line">连队2开始领取武器</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">连队2已经领取完毕</span><br><span class="line">连队3开始领取武器</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">连队3已经领取完毕</span><br><span class="line">连队4开始领取武器</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">连队4已经领取完毕</span><br></pre></td></tr></table></figure>

<p>错误情况</p>
<p>用stop()来停止线程，会导致线程运行一半突然停止，没办法完成一个基本单位的操作（一个连队），会造成脏数据（有的连队多领取少领取装备）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 描述：错误的停止方法：用stop()来停止线程，会导致线程运行一半突然停止，没办法完成一个基本单位的操作（一 </span></span><br><span class="line"><span class="comment">*个连队），会造成脏数据（有的连队会多领取或少领取装备）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//模拟指挥军队：一共有5个连队，每个连队10人，以连队为单位，发放武器弹药，叫到号的士兵前去领取</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"连队"</span> + i + <span class="string">"开始领取武器"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                System.out.println(j);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"连队"</span>+i+<span class="string">"已经领取完毕"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> StopThread());</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">连队0开始领取武器</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">连队0已经领取完毕</span><br><span class="line">连队1开始领取武器</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td></tr></table></figure>

<p>连队1的9号士兵没有领取到武器，系统会认为连队0和连队1的所有士兵都领取完了，这就是使用stop带来的数据错乱</p>
<p>Thread.stop本质上是不安全的，但停止线程会导致它释放之前已经锁定的所有监视器（锁）</p>
<h4 id="2suspend和resume方法"><a href="#2suspend和resume方法" class="headerlink" title="2suspend和resume方法"></a>2suspend和resume方法</h4><p>suspend将线程挂起，运行-&gt;阻塞，调用后并不释放所占用的锁</p>
<p>resume将线程解挂，阻塞-&gt;就绪</p>
<p>suspend并不会破坏，但是suspend和resume不会释放锁，是带着锁进行休息的，这样容易造成死锁</p>
<p>1独占：因为suspend在调用过程中不会释放所占用的锁，所以如果使用不当会造成对公共对象的独占，使得其他线程无法访问公共对象，严重的话造成死锁</p>
<p>2不同步：容易出现因线程暂停导致的数据不同步</p>
<h4 id="3用volatile设置boolean标记位"><a href="#3用volatile设置boolean标记位" class="headerlink" title="3用volatile设置boolean标记位"></a>3用volatile设置boolean标记位</h4><h5 id="看上去可行"><a href="#看上去可行" class="headerlink" title="看上去可行"></a>看上去可行</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：演示用volatile的局限：part1 看似可行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrongWayVolatile</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> canceled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &lt;= <span class="number">100000</span> &amp;&amp; !canceled) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(num + <span class="string">"是100的倍数。"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        WrongWayVolatile r = <span class="keyword">new</span> WrongWayVolatile();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        r.canceled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样是可以的</p>
<h5 id="错误之处"><a href="#错误之处" class="headerlink" title="错误之处"></a>错误之处</h5><p>如下情况不能停止线程</p>
<p>此例中，生产者的生产速度很快，消费者消费速度慢，所以阻塞队列满了以后，生产者会阻塞，等待消费者进一步消费</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述： 演示用volatile的局限part2 陷入阻塞时，volatile是无法线程的 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrongWayVolatileCantStop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ArrayBlockingQueue storage = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(storage);</span><br><span class="line">        Thread producerThread = <span class="keyword">new</span> Thread(producer);</span><br><span class="line">        producerThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(storage);</span><br><span class="line">        <span class="keyword">while</span> (consumer.needMoreNums()) &#123;</span><br><span class="line">            System.out.println(consumer.storage.take()+<span class="string">"被消费了"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"消费者不需要更多数据了。"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一旦消费不需要更多数据了，我们应该让生产者也停下来，但是实际情况</span></span><br><span class="line">        producer.canceled=<span class="keyword">true</span>;</span><br><span class="line">        System.out.println(producer.canceled);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> canceled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    BlockingQueue storage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue storage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//注意这里</span></span><br><span class="line">            <span class="keyword">while</span> (num &lt;= <span class="number">100000</span> &amp;&amp; !canceled) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//注意这里</span></span><br><span class="line">                    storage.put(num);</span><br><span class="line">                    System.out.println(num + <span class="string">"是100的倍数,被放到仓库中了。"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"生产者结束运行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BlockingQueue storage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue storage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">needMoreNums</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Math.random() &gt; <span class="number">0.95</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">0是100的倍数,被放到仓库中了。</span><br><span class="line">100是100的倍数,被放到仓库中了。</span><br><span class="line">200是100的倍数,被放到仓库中了。</span><br><span class="line">300是100的倍数,被放到仓库中了。</span><br><span class="line">400是100的倍数,被放到仓库中了。</span><br><span class="line">500是100的倍数,被放到仓库中了。</span><br><span class="line">600是100的倍数,被放到仓库中了。</span><br><span class="line">700是100的倍数,被放到仓库中了。</span><br><span class="line">800是100的倍数,被放到仓库中了。</span><br><span class="line">900是100的倍数,被放到仓库中了。</span><br><span class="line">1000是100的倍数,被放到仓库中了。</span><br><span class="line">0被消费了</span><br><span class="line">1100是100的倍数,被放到仓库中了。</span><br><span class="line">100被消费了</span><br><span class="line">1200是100的倍数,被放到仓库中了。</span><br><span class="line">200被消费了</span><br><span class="line">1300是100的倍数,被放到仓库中了。</span><br><span class="line">300被消费了</span><br><span class="line">1400是100的倍数,被放到仓库中了。</span><br><span class="line">400被消费了</span><br><span class="line">500被消费了</span><br><span class="line">1500是100的倍数,被放到仓库中了。</span><br><span class="line">1600是100的倍数,被放到仓库中了。</span><br><span class="line">600被消费了</span><br><span class="line">700被消费了</span><br><span class="line">1700是100的倍数,被放到仓库中了。</span><br><span class="line">1800是100的倍数,被放到仓库中了。</span><br><span class="line">800被消费了</span><br><span class="line">900被消费了</span><br><span class="line">1900是100的倍数,被放到仓库中了。</span><br><span class="line">2000是100的倍数,被放到仓库中了。</span><br><span class="line">1000被消费了</span><br><span class="line">2100是100的倍数,被放到仓库中了。</span><br><span class="line">1100被消费了</span><br><span class="line">1200被消费了</span><br><span class="line">2200是100的倍数,被放到仓库中了。</span><br><span class="line">2300是100的倍数,被放到仓库中了。</span><br><span class="line">1300被消费了</span><br><span class="line">1400被消费了</span><br><span class="line">2400是100的倍数,被放到仓库中了。</span><br><span class="line">2500是100的倍数,被放到仓库中了。</span><br><span class="line">1500被消费了</span><br><span class="line">2600是100的倍数,被放到仓库中了。</span><br><span class="line">1600被消费了</span><br><span class="line">1700被消费了</span><br><span class="line">2700是100的倍数,被放到仓库中了。</span><br><span class="line">2800是100的倍数,被放到仓库中了。</span><br><span class="line">1800被消费了</span><br><span class="line">1900被消费了</span><br><span class="line">2900是100的倍数,被放到仓库中了。</span><br><span class="line">3000是100的倍数,被放到仓库中了。</span><br><span class="line">2000被消费了</span><br><span class="line">3100是100的倍数,被放到仓库中了。</span><br><span class="line">2100被消费了</span><br><span class="line">消费者不需要更多数据了。</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<p>最后的时候canceled已经是true了，但是线程没有停止下来，根本没有执行finally</p>
<p><img src="/2020/03/06/4悟空Java并发编程/线程8大核心基础/image-20200305131453211.png" alt="image-20200305131453211"></p>
<p>一旦遇到线程长时间阻塞，这种办法就失效了，这是因为每一次 在执行<code>while (num &lt;= 100000 &amp;&amp; !canceled)</code>的时候才能检查canceled是否为true，而循环体的里面是没有检查是否阻塞的逻辑的，而代码是阻塞在<code>storage.put(num)</code>这里的，没有线程唤醒，自然不能继续执行，走到下一个<code>while (num &lt;= 100000 &amp;&amp; !canceled)</code>，所以就会不停的等待</p>
<h5 id="修正方案"><a href="#修正方案" class="headerlink" title="修正方案"></a>修正方案</h5><p>使用interrupt进行终止线程</p>
<p>如下使用ArrayBlockingQueue队列实现生产者消费者模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrongWayVolatileFixed</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        WrongWayVolatileFixed body = <span class="keyword">new</span> WrongWayVolatileFixed();</span><br><span class="line">        ArrayBlockingQueue storage = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        Producer producer = body.new Producer(storage);</span><br><span class="line">        Thread producerThread = <span class="keyword">new</span> Thread(producer);</span><br><span class="line">        producerThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        Consumer consumer = body.new Consumer(storage);</span><br><span class="line">        <span class="keyword">while</span> (consumer.needMoreNums()) &#123;</span><br><span class="line">            System.out.println(consumer.storage.take() + <span class="string">"被消费了"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"消费者不需要更多数据了。"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//注意这里</span></span><br><span class="line">        producerThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        BlockingQueue storage;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue storage)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.storage = storage;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//注意这里</span></span><br><span class="line">                <span class="keyword">while</span> (num &lt;= <span class="number">100000</span> &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (num % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        storage.put(num);</span><br><span class="line">                        System.out.println(num + <span class="string">"是100的倍数,被放到仓库中了。"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"生产者结束运行"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        BlockingQueue storage;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue storage)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.storage = storage;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">needMoreNums</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Math.random() &gt; <span class="number">0.95</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">0是100的倍数,被放到仓库中了。</span><br><span class="line">100是100的倍数,被放到仓库中了。</span><br><span class="line">200是100的倍数,被放到仓库中了。</span><br><span class="line">300是100的倍数,被放到仓库中了。</span><br><span class="line">400是100的倍数,被放到仓库中了。</span><br><span class="line">500是100的倍数,被放到仓库中了。</span><br><span class="line">600是100的倍数,被放到仓库中了。</span><br><span class="line">700是100的倍数,被放到仓库中了。</span><br><span class="line">800是100的倍数,被放到仓库中了。</span><br><span class="line">900是100的倍数,被放到仓库中了。</span><br><span class="line">0被消费了</span><br><span class="line">1000是100的倍数,被放到仓库中了。</span><br><span class="line">1100是100的倍数,被放到仓库中了。</span><br><span class="line">100被消费了</span><br><span class="line">200被消费了</span><br><span class="line">1200是100的倍数,被放到仓库中了。</span><br><span class="line">300被消费了</span><br><span class="line">1300是100的倍数,被放到仓库中了。</span><br><span class="line">1400是100的倍数,被放到仓库中了。</span><br><span class="line">400被消费了</span><br><span class="line">1500是100的倍数,被放到仓库中了。</span><br><span class="line">500被消费了</span><br><span class="line">1600是100的倍数,被放到仓库中了。</span><br><span class="line">600被消费了</span><br><span class="line">700被消费了</span><br><span class="line">1700是100的倍数,被放到仓库中了。</span><br><span class="line">1800是100的倍数,被放到仓库中了。</span><br><span class="line">800被消费了</span><br><span class="line">1900是100的倍数,被放到仓库中了。</span><br><span class="line">900被消费了</span><br><span class="line">1000被消费了</span><br><span class="line">2000是100的倍数,被放到仓库中了。</span><br><span class="line">消费者不需要更多数据了。</span><br><span class="line">java.lang.InterruptedException</span><br><span class="line">	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.reportInterruptAfterWait(AbstractQueuedSynchronizer.java:2014)</span><br><span class="line">	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2048)</span><br><span class="line">	at java.util.concurrent.ArrayBlockingQueue.put(ArrayBlockingQueue.java:353)</span><br><span class="line">	at threadcoreknowledge.stopthreads.volatiledemo.WrongWayVolatileFixed$Producer.run(WrongWayVolatileFixed.java:47)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">生产者结束运行</span><br></pre></td></tr></table></figure>

<h3 id="停止线程相关的重要函数解析"><a href="#停止线程相关的重要函数解析" class="headerlink" title="停止线程相关的重要函数解析"></a>停止线程相关的重要函数解析</h3><p><strong>static boolean interrupted()</strong></p>
<p>检测当前线程是否被中断，同时会把线程的中断状态直接设置为true，也就是将线程中断状态直接清除，这也是唯一能清除线程状态的办法，如果返回true，实际上是帮助我们清除了线程中断状态，此时要对这种行为做出处理，无论是抛出InterruptedException或者是再次执行interrupted来中断线程都可以</p>
<p><strong>boolean isInterrupted()</strong></p>
<p>检测当前线程是否被中断，但不会把线程的中断状态清除</p>
<p><strong>Thread.interrupted()的目标对象</strong></p>
<p>Thread.interrupted()方法的目标对象是当前执行它的线程，当前运行它的线程，而不管本方法来自于哪个对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：注意Thread.interrupted()方法的目标对象是“当前线程”，而不管本方法来自于哪个对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightWayInterrupted</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread threadOne = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        threadOne.start();</span><br><span class="line">        <span class="comment">//设置中断标志</span></span><br><span class="line">        <span class="comment">//返回true</span></span><br><span class="line">        threadOne.interrupt();</span><br><span class="line">        <span class="comment">//获取中断标志</span></span><br><span class="line">        <span class="comment">//返回true</span></span><br><span class="line">        System.out.println(<span class="string">"isInterrupted: "</span> + threadOne.isInterrupted());</span><br><span class="line">        <span class="comment">//获取中断标志并重置</span></span><br><span class="line">        <span class="comment">//执行这个线程的是main方法，main方法没有被中断，所以应该为false</span></span><br><span class="line">        System.out.println(<span class="string">"isInterrupted: "</span> + threadOne.interrupted());</span><br><span class="line">        <span class="comment">//获取中断标志并重直</span></span><br><span class="line">        <span class="comment">//不管是Thread还是threadOne，都返回当前主线程的状态，所以应该返回false</span></span><br><span class="line">        System.out.println(<span class="string">"isInterrupted: "</span> + Thread.interrupted());</span><br><span class="line">        <span class="comment">//获取中断标志</span></span><br><span class="line">        <span class="comment">//返回true</span></span><br><span class="line">        System.out.println(<span class="string">"isInterrupted: "</span> + threadOne.isInterrupted());</span><br><span class="line">        threadOne.join();</span><br><span class="line">        System.out.println(<span class="string">"Main thread is over."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">isInterrupted: true</span><br><span class="line">isInterrupted: false</span><br><span class="line">isInterrupted: false</span><br><span class="line">isInterrupted: true</span><br></pre></td></tr></table></figure>

<h3 id="常见面试题-2"><a href="#常见面试题-2" class="headerlink" title="常见面试题"></a>常见面试题</h3><h4 id="1如何停止线程"><a href="#1如何停止线程" class="headerlink" title="1如何停止线程"></a>1如何停止线程</h4><ol>
<li><p>原理：用interrupt来请求、好处</p>
</li>
<li><p>想停止线程、要请求方、被请求方、子方法被调用方相互配合</p>
<p>请求方发出终止线程的信号，被请求方必须在每次循环或者适当的时候去检查这个信号，在可能抛出interruptedException的时候去处理这个信号，每一个线程都应该去做这样的事情，以便于自己能够停止</p>
<p>如果我们是去写子方法的，这个子方法是会被我们的线程所调用的，那么有两点最佳实践，优先是在子方法中抛出这个异常，以便于其他人进行处理，或者收到异常之后，再次设置中断状态</p>
<p>如果这三方处理得当，就会得到完美的处理结果</p>
</li>
<li><p>最后再说错误的方法：stop/suspend已废弃，volatile的boolean无法处理长时间阻塞的情况</p>
</li>
</ol>
<h4 id="2如何处理不可中断的阻塞"><a href="#2如何处理不可中断的阻塞" class="headerlink" title="2如何处理不可中断的阻塞"></a>2如何处理不可中断的阻塞</h4><p>没有通用的解决方案，要针对不同的锁给出不同的解决方案</p>
<h2 id="线程的6个状态（生命周期）"><a href="#线程的6个状态（生命周期）" class="headerlink" title="线程的6个状态（生命周期）"></a>线程的6个状态（生命周期）</h2><h3 id="线程的6种状态"><a href="#线程的6种状态" class="headerlink" title="线程的6种状态"></a>线程的6种状态</h3><h3 id="每个状态的含义"><a href="#每个状态的含义" class="headerlink" title="每个状态的含义"></a>每个状态的含义</h3><h4 id="New"><a href="#New" class="headerlink" title="New"></a>New</h4><p>已创建但还没有启动的线程，new Thread()新建线程之后没有执行start()方法，此时线程处于New的状态</p>
<h4 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h4><p>可运行线程的线程状态。这里其实合并了两种状态（RUNNING、RUNABLE）</p>
<p>翻译过来为可运行的</p>
<p>从New状态调用start()方法就进入Runnable状态，Java中的Runnable状态实际上对应着操作系统中的两种状态，分别是Ready（可运行的）和Running（运行中的），此时的状态既可以表示可运行的，可运行的就是其他资源都准备好了，但是还差CPU资源去执行。也可以表示实际运行中的</p>
<p>注意：</p>
<p>线程的得到CPU资源时是Runnable状态，但是CPU资源是不停的被调度的，有的时候CPU资源会突然被拿走，此时这个线程还是Runnable状态，因为即使没有CPU资源，也是处于可运行的状态，这也是Runnable状态</p>
<h4 id="Blocked"><a href="#Blocked" class="headerlink" title="Blocked"></a>Blocked</h4><p>针对Blocked状态一定是针对synchronized修饰的，无论是synchronized修饰的代码块还是方法都可以</p>
<p>在synchronized修饰的代码中，且没有得到锁而陷入等待状态，这种情况下就是Blocked状态</p>
<h4 id="Waiting"><a href="#Waiting" class="headerlink" title="Waiting"></a>Waiting</h4><p>等待状态，表示线程进入状态。进入此状态后，会无限等待，直到其他线程做出一些特定的动作（唤醒通知、中断通知）才会再次运行</p>
<h4 id="Timed-Waiting"><a href="#Timed-Waiting" class="headerlink" title="Timed Waiting"></a>Timed Waiting</h4><p>计时等待状态，此状态与 WAITING 状态有些类似，但它是有时间限制的，即只会等待一段指定的时间，当时间到来前，没有被唤醒或或中断，那么时间到来了，就自动”醒来”，进入RUNNABLE状态</p>
<h4 id="Terminated"><a href="#Terminated" class="headerlink" title="Terminated"></a>Terminated</h4><p>终止状态，已终止线程的线程状态</p>
<p><strong>注意</strong></p>
<ol>
<li>当线程的run方法结束时，该线程就完成。即线程死亡。但注意，此时线程的状态是死亡了，而且是不可以复活的，但是死亡的线程的对象并没有立即消失（因为Thread是一个类，是一个记录、操作线程的类），特别是在别处被引用下，你可以继续调用这个Thread实例上的大部分方法，而对线程操作的方法基本上都会抛异常，如：start()、wait()、notify()不可以再调用</li>
<li>只要线程启动了，也就是调用start()方法，也就永远就不能再次启动</li>
<li>线程执行的顺序与线程启动的顺序无关，start()线程启动，线程首先由新建状态变成就绪状态，并不是直接就是运行状态，即不会马上就运行，何时进入CPU运行，得看调度算法</li>
<li>java 将操作系统当中的就绪 与 运行两个状态合并为运行状态</li>
<li>线程进入synchronize修饰的方法或代码块中，线程的状态变为阻塞状态。但如果线程进入的是Lock接口的代码块中，却是等待状态。这是因为Lock对于阻塞的本质实现是使用了LockSupport类中的相关方法</li>
<li>WAITING 、TIMED_WAITING 两种等待状态都是可以被”中断”打断的，所以那些将线程变为等待状态的方法，如wait()、sleep()等都要捕获 InterruptedException异常</li>
</ol>
<h3 id="状态间的转化图示"><a href="#状态间的转化图示" class="headerlink" title="状态间的转化图示"></a>状态间的转化图示</h3><p><img src="/2020/03/06/4悟空Java并发编程/线程8大核心基础/1.png" alt></p>
<h3 id="状态转化的特殊情况"><a href="#状态转化的特殊情况" class="headerlink" title="状态转化的特殊情况"></a>状态转化的特殊情况</h3><ul>
<li><p>从Object.wait()状态刚被唤醒时，通常不能立即抢到monitor锁，那就会从Waiting先进入Blocked状态，抢到锁后再转换到Runnable状态（官网文档）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static final Thread.State BLOCKED</span><br><span class="line">Thread state for a thread blocked waiting for a monitor lock. A thread in the blocked state is waiting for a monitor lock to enter a synchronized block/method or reenter a synchronized block/method after calling Object.wait</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果发生异常，可以直接跳到终止Terminated状态，不必再遵循路径，比如可以从Waiting直接到Terminated</p>
</li>
</ul>
<p><strong>展示线程的NEW、RUNNABLE、Terminated状态</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：展示线程的NEW、RUNNABLE、Terminated状态。即使是正在运行，也是Runnable状态，而不是Running。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewRunnableTerminated</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> NewRunnableTerminated());</span><br><span class="line">        <span class="comment">//打印出NEW的状态</span></span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">//打印出Runnable</span></span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印出RUNNABLE的状态，即使是正在运行，也是RUNNABLE，而不是RUNNING</span></span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印出TERMINATED状态</span></span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>展示Blocked, Waiting, TimedWaiting</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：展示Blocked, Waiting, TimedWaiting</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockedWaitingTimedWaiting</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockedWaitingTimedWaiting runnable = <span class="keyword">new</span> BlockedWaitingTimedWaiting();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread1.start();</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印出Timed_Waiting状态，因为正在执行Thread.sleep(1000);</span></span><br><span class="line">        System.out.println(thread1.getState());</span><br><span class="line">        <span class="comment">//打印出BLOCKED状态，因为thread2想拿得到sync()的锁却拿不到</span></span><br><span class="line">        System.out.println(thread2.getState());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1300</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印出WAITING状态，因为执行了wait()</span></span><br><span class="line">        System.out.println(thread1.getState());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        syn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="阻塞状态是什么"><a href="#阻塞状态是什么" class="headerlink" title="阻塞状态是什么"></a>阻塞状态是什么</h3><p>一般习惯而言，把Blocked（被阻塞）、Waiting（等待）、Timed_waiting（计时等待）都称为阻塞状态，不仅仅是Blocked状态</p>
<h3 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h3><p>线程有哪几种状态？线程的生命周期是什么？</p>
<h2 id="Thread类和Object类中的重要方法解析"><a href="#Thread类和Object类中的重要方法解析" class="headerlink" title="Thread类和Object类中的重要方法解析"></a>Thread类和Object类中的重要方法解析</h2><p><strong>考一考</strong></p>
<p>为什么线程通信的方法wait()、notify()和notifyAll()被定义在Object类里？而sleep()定义在Thread类里？</p>
<p>用3中方式实现生产者模式</p>
<p>JavaSE8和Java1.8和JDK8是什么关系，是同一个东西吗？</p>
<p>join和sleep和wait期间线程的状态分别是什么？为什么?</p>
<h3 id="方法概览"><a href="#方法概览" class="headerlink" title="方法概览"></a>方法概览</h3><table>
<thead>
<tr>
<th align="center">类</th>
<th align="center">方法名</th>
<th align="center">简介</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Thread</td>
<td align="center">sleep相关</td>
<td align="center">本表格的”相关“，指的是重载方法，也就是方法名相同，但是参数不同，例如sleep有多个方法，只是参数不同，实际作用大同小异</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">join</td>
<td align="center">等待其他线程执行完毕</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">yield相关</td>
<td align="center">方法已经获取到的CPU资源</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">currentThread</td>
<td align="center">获取当前执行线程的引用</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">start、run相关</td>
<td align="center">启动线程相关</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">interrupt</td>
<td align="center">中断线程</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">stop、suspend、resume相关</td>
<td align="center">已废弃</td>
</tr>
<tr>
<td align="center">Object</td>
<td align="center">wait、notify、notifyAll相关</td>
<td align="center">让线程暂时休息和唤醒</td>
</tr>
</tbody></table>
<h2 id="wait、notify、notifyAll方法详解"><a href="#wait、notify、notifyAll方法详解" class="headerlink" title="wait、notify、notifyAll方法详解"></a>wait、notify、notifyAll方法详解</h2><h3 id="作用与用法"><a href="#作用与用法" class="headerlink" title="作用与用法"></a>作用与用法</h3><p>用法主要分为3个阶段，即阻塞阶段、唤醒阶段、遇到中断</p>
<p><strong>阻塞阶段</strong></p>
<p>有的时候想要一个或多个线程暂时休息一下，等到我们后续需要的时候或者条件成熟的时候再去唤醒它，这就是wait、notify、notifyAll的作用，即它可以让我们控制其他线程去休息以及被唤醒，一旦执行了休息就意味着进入到了阻塞阶段。</p>
<p>关于阻塞阶段要注意，它执行wait方法的时候必须先拥有这个对象的monitor锁，调用wait方法首先是一个线程调用，调用它的对象自己就会进入阻塞状态，不再参与线程的调度。</p>
<p>直到以下4种情况之一发生，才会被唤醒</p>
<ol>
<li>另一个线程调用这个对象的notify()方法且刚好被唤醒的是本线程</li>
<li>另一个线程调用这个对象的notifyAll()方法</li>
<li>过了wait(long timeout)规定的超时时间。如果传入0就是永久等待</li>
<li>线程自身调用了interrupt()</li>
</ol>
<p><strong>唤醒阶段</strong></p>
<p>notify会唤醒单个正在等待monitor的线程，如果有多个线程在等待，则只会选取其中一个，而具体的唤醒的选择是任意的，java对此没有一个严格的规范</p>
<p>notify、wait、notifyAll他们都需要在synchronized代码块或方法中执行，如果在synchronized外面执行会抛出异常</p>
<p>一旦被唤醒，则线程不再是等待的状态，当前线程就会重新参与线程的调度当中，等待时机合适就会被继续执行</p>
<p>notifyAll会把等待的线程全部唤醒</p>
<p><strong>遇到中断</strong></p>
<p>若线程执行了wait方法，如果被中断，则会抛出InterrupterException，并且释放掉当前已经获取的monitor（锁）</p>
<h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><h4 id="1普通用法"><a href="#1普通用法" class="headerlink" title="1普通用法"></a>1普通用法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：展示wait和notify的基本用法 </span></span><br><span class="line"><span class="comment"> * 1. 研究代码执行顺序 </span></span><br><span class="line"><span class="comment"> * 2. 证明wait释放锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wait</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"开始执行了"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    object.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"获取到了锁。"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                object.notify();</span><br><span class="line">                System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"调用了notify()"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread1 thread1 = <span class="keyword">new</span> Thread1();</span><br><span class="line">        Thread2 thread2 = <span class="keyword">new</span> Thread2();</span><br><span class="line">        thread1.start();</span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread-0开始执行了</span><br><span class="line">线程Thread-1调用了notify()</span><br><span class="line">线程Thread-0获取到了锁。</span><br></pre></td></tr></table></figure>

<h4 id="2notify和notifyAll的用法"><a href="#2notify和notifyAll的用法" class="headerlink" title="2notify和notifyAll的用法"></a>2notify和notifyAll的用法</h4><p>start先执行不代表线程先启动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：3个线程，线程1和线程2首先被阻塞，线程3唤醒它们</span></span><br><span class="line"><span class="comment"> * notify, notifyAll</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyAll</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object resourceA = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runnable r = <span class="keyword">new</span> WaitNotifyAll();</span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread threadC = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">                    <span class="comment">//注意这里</span></span><br><span class="line">                    resourceA.notifyAll();</span><br><span class="line">                    System.out.println(<span class="string">"ThreadC notified."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        threadC.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" got resourceA lock."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" waits to start."</span>);</span><br><span class="line">                resourceA.wait();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"'s waiting to end."</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p><img src="/2020/03/06/4悟空Java并发编程/线程8大核心基础/image-20200305222403686.png" alt="image-20200305222403686"></p>
<p>注意此方法的运算结果在执行完的时候终止了</p>
<p><strong>第一个注意点</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyAll</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object resourceA = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runnable r = <span class="keyword">new</span> WaitNotifyAll();</span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread threadC = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">                    <span class="comment">//注意这里</span></span><br><span class="line">                    resourceA.notify();</span><br><span class="line">                    System.out.println(<span class="string">"ThreadC notified."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        threadC.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" got resourceA lock."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" waits to start."</span>);</span><br><span class="line">                resourceA.wait();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"'s waiting to end."</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p>可以看出程序没有停止，而是一直在执行，因为notify()只能唤醒一个线程，只唤醒了线程0，却不能唤醒线程1</p>
<p><img src="/2020/03/06/4悟空Java并发编程/线程8大核心基础/image-20200305223245960.png" alt="image-20200305223245960"></p>
<p><strong>第二个注意点</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyAll</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object resourceA = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runnable r = <span class="keyword">new</span> WaitNotifyAll();</span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread threadC = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">                    <span class="comment">//注意这里</span></span><br><span class="line">                    resourceA.notifyAll();</span><br><span class="line">                    System.out.println(<span class="string">"ThreadC notified."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        <span class="comment">//注意这里</span></span><br><span class="line">        <span class="comment">//Thread.sleep(200);</span></span><br><span class="line">        threadC.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" got resourceA lock."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" waits to start."</span>);</span><br><span class="line">                resourceA.wait();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"'s waiting to end."</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p><img src="/2020/03/06/4悟空Java并发编程/线程8大核心基础/image-20200306075851814.png" alt="image-20200306075851814"></p>
<p>线程的执行顺序与代码位置无关，不休眠就无法保证线程的执行顺序，如图，线程0获取锁之后进入等待，线程C就获取到了锁并唤醒，时候线程1获取到锁并进入等待，但是却没有线程去唤醒它，它就进入无尽的等待</p>
<h4 id="3只释放当前monitor的用法"><a href="#3只释放当前monitor的用法" class="headerlink" title="3只释放当前monitor的用法"></a>3只释放当前monitor的用法</h4><p>执行wait这个方法一定是一个对象，这个对象就代表那一把锁，哪一个对象执行wait，就会释放掉哪一个对象的锁，而不影响其他锁的行为，其他锁如果被锁住，则依然被锁住，每一个锁之间是独立的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：证明wait只释放当前的那把锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyReleaseOwnMonitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Object resourceA = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Object resourceB = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"ThreadA got resourceA lock."</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"ThreadA got resourceB lock."</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">"ThreadA releases resourceA lock."</span>);</span><br><span class="line">                            resourceA.wait();</span><br><span class="line"></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"ThreadB got resourceA lock."</span>);</span><br><span class="line">                    System.out.println(<span class="string">"ThreadB tries to resourceB lock."</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"ThreadB got resourceB lock."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ThreadA got resourceA lock.</span><br><span class="line">ThreadA got resourceB lock.</span><br><span class="line">ThreadA releases resourceA lock.</span><br><span class="line">ThreadB got resourceA lock.</span><br><span class="line">ThreadB tries to resourceB lock.</span><br></pre></td></tr></table></figure>

<h3 id="wait、notify、notifyAll特点"><a href="#wait、notify、notifyAll特点" class="headerlink" title="wait、notify、notifyAll特点"></a>wait、notify、notifyAll特点</h3><ol>
<li><p>使用之前必须先拥有monitor，否则会抛出异常</p>
</li>
<li><p>notify只会唤醒一个，并且是随机的，我们无法预知</p>
</li>
<li><p>这三个方法都属于Object类的</p>
</li>
<li><p>jdk已经帮忙封装好一个类似的功能Condition，Condition和wait、notify、notifyAll的功能非常类似</p>
</li>
<li><p>同时持有多个锁时，释放锁只会释放wait对应的对象的那一把锁，如果一个线程同时持有多把锁，要注意释放的顺序与获取的顺序非常重要，可能会导致死锁的发生</p>
</li>
</ol>
<h3 id="wait原理"><a href="#wait原理" class="headerlink" title="wait原理"></a>wait原理</h3><p><img src="/2020/03/06/4悟空Java并发编程/线程8大核心基础/2.png" alt>  </p>
<p>这个图想表达的是抢synchronized锁的一系列动作，在抢锁的过程中，从1开始逐步的往下，首先开始抢锁，于是进入Entry Set入口集，在入口集可能有多个线程，其中一个又一个圆圈代表线程，执行到3释放锁进入等待集，在Set区域里的线程都在等待其他线程对锁的释放，然后它们再来抢锁</p>
<h3 id="手写生产者消费者设计模式"><a href="#手写生产者消费者设计模式" class="headerlink" title="手写生产者消费者设计模式"></a>手写生产者消费者设计模式</h3><h4 id="为什么要使用生产者和消费者模式"><a href="#为什么要使用生产者和消费者模式" class="headerlink" title="为什么要使用生产者和消费者模式"></a>为什么要使用生产者和消费者模式</h4><p>生产者为生产数据，消费者为使用数据，但是它们的速度很有可能是不一致的，有的时候生产者比较块，有的时候生产者比较慢，如果能有一个设计模式解决它们之间相互等待的问题，而不至于一个过快一个过慢使得相互配合变得困难，就需要使用这样的设计模式</p>
<p>生产者消费者设计模式实际上是把消费方和生产方进行了解耦，通过解耦可以达到更加流畅的配合</p>
<p>如图所示</p>
<p><img src="/2020/03/06/4悟空Java并发编程/线程8大核心基础/3.png" alt></p>
<p>首先生产者消费者会利用一个容器（通常是阻塞队列）来解决它们之间的耦合问题，有了中间的媒介，左边是消费者，右边是生产者，它们之间不需要直接通信，所有的通信都是通过中间的队列，右边生产对象之后放在队列里，而左边从队列中获取对象，这样就有了缓冲区，这就把生产者消费者之间的能力进行了平衡</p>
<p>当生产者发现队列满了，它就停止生产，并通知消费者消费，因为中间的队列是有一定容量的，左边的消费者发现队列满了，就停止消费，并通知消费者继续生产</p>
<p><img src="/2020/03/06/4悟空Java并发编程/线程8大核心基础/4.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：用wait/notify来实现生产者消费者模式，不允许使用阻塞队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerModel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EventStorage eventStorage = <span class="keyword">new</span> EventStorage();</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(eventStorage);</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(eventStorage);</span><br><span class="line">        <span class="keyword">new</span> Thread(producer).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(consumer).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EventStorage storage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(EventStorage storage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            storage.put();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EventStorage storage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(EventStorage storage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            storage.take();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventStorage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Date&gt; storage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventStorage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        maxSize = <span class="number">10</span>;</span><br><span class="line">        storage = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (storage.size() == maxSize) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        storage.add(<span class="keyword">new</span> Date());</span><br><span class="line">        System.out.println(<span class="string">"仓库里有了"</span> + storage.size() + <span class="string">"个产品。"</span>);</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (storage.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"拿到了"</span> + storage.poll() + <span class="string">"，现在仓库还剩下"</span> + storage.size());</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line">仓库里有了1个产品。</span><br><span class="line">仓库里有了2个产品。</span><br><span class="line">仓库里有了3个产品。</span><br><span class="line">仓库里有了4个产品。</span><br><span class="line">仓库里有了5个产品。</span><br><span class="line">仓库里有了6个产品。</span><br><span class="line">仓库里有了7个产品。</span><br><span class="line">仓库里有了8个产品。</span><br><span class="line">仓库里有了9个产品。</span><br><span class="line">仓库里有了10个产品。</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下9</span><br><span class="line">仓库里有了10个产品。</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下9</span><br><span class="line">仓库里有了10个产品。</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下9</span><br><span class="line">仓库里有了10个产品。</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下9</span><br><span class="line">仓库里有了10个产品。</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下9</span><br><span class="line">仓库里有了10个产品。</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下9</span><br><span class="line">仓库里有了10个产品。</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下9</span><br><span class="line">仓库里有了10个产品。</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下9</span><br><span class="line">仓库里有了10个产品。</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下9</span><br><span class="line">仓库里有了10个产品。</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下9</span><br><span class="line">仓库里有了10个产品。</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下9</span><br><span class="line">仓库里有了10个产品。</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下9</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下8</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下7</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下6</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下5</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下4</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下3</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下2</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下1</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下0</span><br><span class="line">仓库里有了1个产品。</span><br><span class="line">仓库里有了2个产品。</span><br><span class="line">仓库里有了3个产品。</span><br><span class="line">仓库里有了4个产品。</span><br><span class="line">仓库里有了5个产品。</span><br><span class="line">仓库里有了6个产品。</span><br><span class="line">仓库里有了7个产品。</span><br><span class="line">仓库里有了8个产品。</span><br><span class="line">仓库里有了9个产品。</span><br><span class="line">仓库里有了10个产品。</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下9</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下8</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下7</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下6</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下5</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下4</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下3</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下2</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下1</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下0</span><br><span class="line">仓库里有了1个产品。</span><br><span class="line">仓库里有了2个产品。</span><br><span class="line">仓库里有了3个产品。</span><br><span class="line">仓库里有了4个产品。</span><br><span class="line">仓库里有了5个产品。</span><br><span class="line">仓库里有了6个产品。</span><br><span class="line">仓库里有了7个产品。</span><br><span class="line">仓库里有了8个产品。</span><br><span class="line">仓库里有了9个产品。</span><br><span class="line">仓库里有了10个产品。</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下9</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下8</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下7</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下6</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下5</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下4</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下3</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下2</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下1</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下0</span><br><span class="line">仓库里有了1个产品。</span><br><span class="line">仓库里有了2个产品。</span><br><span class="line">仓库里有了3个产品。</span><br><span class="line">仓库里有了4个产品。</span><br><span class="line">仓库里有了5个产品。</span><br><span class="line">仓库里有了6个产品。</span><br><span class="line">仓库里有了7个产品。</span><br><span class="line">仓库里有了8个产品。</span><br><span class="line">仓库里有了9个产品。</span><br><span class="line">仓库里有了10个产品。</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下9</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下8</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下7</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下6</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下5</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下4</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下3</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下2</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下1</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下0</span><br><span class="line">仓库里有了1个产品。</span><br><span class="line">仓库里有了2个产品。</span><br><span class="line">仓库里有了3个产品。</span><br><span class="line">仓库里有了4个产品。</span><br><span class="line">仓库里有了5个产品。</span><br><span class="line">仓库里有了6个产品。</span><br><span class="line">仓库里有了7个产品。</span><br><span class="line">仓库里有了8个产品。</span><br><span class="line">仓库里有了9个产品。</span><br><span class="line">仓库里有了10个产品。</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下9</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下8</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下7</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下6</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下5</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下4</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下3</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下2</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下1</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下0</span><br><span class="line">仓库里有了1个产品。</span><br><span class="line">仓库里有了2个产品。</span><br><span class="line">仓库里有了3个产品。</span><br><span class="line">仓库里有了4个产品。</span><br><span class="line">仓库里有了5个产品。</span><br><span class="line">仓库里有了6个产品。</span><br><span class="line">仓库里有了7个产品。</span><br><span class="line">仓库里有了8个产品。</span><br><span class="line">仓库里有了9个产品。</span><br><span class="line">仓库里有了10个产品。</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下9</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下8</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下7</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下6</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下5</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下4</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下3</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下2</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下1</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下0</span><br><span class="line">仓库里有了1个产品。</span><br><span class="line">仓库里有了2个产品。</span><br><span class="line">仓库里有了3个产品。</span><br><span class="line">仓库里有了4个产品。</span><br><span class="line">仓库里有了5个产品。</span><br><span class="line">仓库里有了6个产品。</span><br><span class="line">仓库里有了7个产品。</span><br><span class="line">仓库里有了8个产品。</span><br><span class="line">仓库里有了9个产品。</span><br><span class="line">仓库里有了10个产品。</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下9</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下8</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下7</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下6</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下5</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下4</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下3</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下2</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下1</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下0</span><br><span class="line">仓库里有了1个产品。</span><br><span class="line">仓库里有了2个产品。</span><br><span class="line">仓库里有了3个产品。</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下2</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下1</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下0</span><br><span class="line">仓库里有了1个产品。</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下0</span><br><span class="line">仓库里有了1个产品。</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下0</span><br><span class="line">仓库里有了1个产品。</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下0</span><br><span class="line">仓库里有了1个产品。</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下0</span><br><span class="line">仓库里有了1个产品。</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下0</span><br><span class="line">仓库里有了1个产品。</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下0</span><br><span class="line">仓库里有了1个产品。</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下0</span><br><span class="line">仓库里有了1个产品。</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下0</span><br><span class="line">仓库里有了1个产品。</span><br><span class="line">仓库里有了2个产品。</span><br><span class="line">仓库里有了3个产品。</span><br><span class="line">仓库里有了4个产品。</span><br><span class="line">仓库里有了5个产品。</span><br><span class="line">仓库里有了6个产品。</span><br><span class="line">仓库里有了7个产品。</span><br><span class="line">仓库里有了8个产品。</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下7</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下6</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下5</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下4</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下3</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下2</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下1</span><br><span class="line">拿到了Fri Mar 06 11:14:49 CST 2020，现在仓库还剩下0</span><br></pre></td></tr></table></figure>

<h3 id="常见面试问题-1"><a href="#常见面试问题-1" class="headerlink" title="常见面试问题"></a>常见面试问题</h3><h4 id="用程序实现两个线程交替打印0-100的奇偶数"><a href="#用程序实现两个线程交替打印0-100的奇偶数" class="headerlink" title="用程序实现两个线程交替打印0~100的奇偶数"></a>用程序实现两个线程交替打印0~100的奇偶数</h4><p>偶线程打印偶数</p>
<p>奇线程打印奇数</p>
<p><strong>实现方式1</strong></p>
<p>基本思路：synchronized</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：两个线程交替打印0~100的奇偶数，用synchronized关键字实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyPrintOddEvenSyn</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新建2个线程</span></span><br><span class="line">    <span class="comment">//第一个只处理偶数，第二个只处理奇数（用位运算）</span></span><br><span class="line">    <span class="comment">//用synchronized来通信</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (count &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                        <span class="comment">//表示偶数</span></span><br><span class="line">                        <span class="keyword">if</span> ((count &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + count++);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"偶数"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (count &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                        <span class="comment">//表示奇数</span></span><br><span class="line">                        <span class="keyword">if</span> ((count &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + count++);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"奇数"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这其中两个线程相互之间抢夺资源，而不是你先执行我再执行这样平稳的运行</p>
<p><strong>实现方式2</strong></p>
<p>更好的方法：wait/notify</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：两个线程交替打印0~100的奇偶数，用wait和notify</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyPrintOddEveWait</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先启动的线程并不一定先去执行，可以让主线程先进行休眠</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TurningRunner(), <span class="string">"偶数"</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TurningRunner(), <span class="string">"奇数"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 拿到锁，我们就打印</span></span><br><span class="line">    <span class="comment">//2. 打印完，唤醒其他线程，自己就休眠</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TurningRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="comment">//拿到锁就打印</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + count++);</span><br><span class="line">                    lock.notify();</span><br><span class="line">                    <span class="keyword">if</span> (count &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;  </span><br><span class="line">                            <span class="comment">//如果任务还没结束，就让出当前的锁，并且自己休眠</span></span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法的每一次的执行都是有意义的，没有第一个方法的浪费的缺点，即拿到锁但可能浪费</p>
<h4 id="手写生产者消费者设计模式-1"><a href="#手写生产者消费者设计模式-1" class="headerlink" title="手写生产者消费者设计模式"></a>手写生产者消费者设计模式</h4><h4 id="为什么wait-需要在同步代码块内使用，而sleep-不需要"><a href="#为什么wait-需要在同步代码块内使用，而sleep-不需要" class="headerlink" title="为什么wait()需要在同步代码块内使用，而sleep()不需要"></a>为什么wait()需要在同步代码块内使用，而sleep()不需要</h4><p>主要是为了让通信变得可靠，防止死锁与永久等待的发生，如果不把wait和notify都放在代码块中，很有可能在执行wait之前，线程突然切换到执行notify的线程，就改变了逻辑，容易造成死锁</p>
<p>而sleep主要是针对自己单独的线程，和其他线程没有什么关系</p>
<h4 id="为什么线程通信的方法wait、notify和notifyAll被定义在Object类里？而sleep定义在Thread类里？"><a href="#为什么线程通信的方法wait、notify和notifyAll被定义在Object类里？而sleep定义在Thread类里？" class="headerlink" title="为什么线程通信的方法wait、notify和notifyAll被定义在Object类里？而sleep定义在Thread类里？"></a>为什么线程通信的方法wait、notify和notifyAll被定义在Object类里？而sleep定义在Thread类里？</h4><p>因为Java中的wait、notify和notifyAll属于锁机别的操作，而锁是属于某一个对象的，而并不是线程中</p>
<p>如果wait、notify和notifyAll定义在Thread中，就会造成很大的局限性，每一个线程确实可以唤醒等待，但当某个线程持有多个锁，并且这些锁之间是相互配合的。实际上某一个线程可以持有多把锁，如果把wait、notify和notifyAll定义在Thread类中，就没有办法实现这样灵活的逻辑了，所以Java所提供的锁是对于每一个对象都适用的</p>
<h4 id="wait方法是属于Object对象的，那调用Thread-wait会怎么样？"><a href="#wait方法是属于Object对象的，那调用Thread-wait会怎么样？" class="headerlink" title="wait方法是属于Object对象的，那调用Thread.wait会怎么样？"></a>wait方法是属于Object对象的，那调用Thread.wait会怎么样？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread();</span><br><span class="line">thread.wait();</span><br></pre></td></tr></table></figure>

<p>Thread也是一个对象，它也继承于Object类，可以把Thread作为锁去执行wait()/notify方法，但是对于Thread类它非常特殊，在线程退出的时候这个线程会自动的执行notify()方法，这样使我们的设计流程受到干扰，因为它自动的去执行notify()方法，所以这样就会使整个设计流程都会受到影响，所以Thread类不适合作为锁对象</p>
<h4 id="如何选择用notify还是notifyAll"><a href="#如何选择用notify还是notifyAll" class="headerlink" title="如何选择用notify还是notifyAll?"></a>如何选择用notify还是notifyAll?</h4><p>选择notify的话，因为要唤醒的线程比较少，程序处理速度当然比notifyAll高出一些</p>
<p>但选择notify的时候，若这部分处理得不好，可能会有程序挂掉的危险性。一般来说，选择notifyAll所写出来的程序代码会比选择notify可靠。</p>
<p> 除非你能确定程序员对程序代码的意义和能力限度一清二楚，否则选择notifyAll应该更稳妥一些</p>
<h4 id="notifyAll之后所有的线程都会再次抢夺锁，如果某线程抢夺失败怎么办？"><a href="#notifyAll之后所有的线程都会再次抢夺锁，如果某线程抢夺失败怎么办？" class="headerlink" title="notifyAll之后所有的线程都会再次抢夺锁，如果某线程抢夺失败怎么办？"></a>notifyAll之后所有的线程都会再次抢夺锁，如果某线程抢夺失败怎么办？</h4><p>没有抢到锁的线程会等待，等待持有者去释放这把锁，然后再去抢</p>
<h4 id="用suspend和resume来阻塞线程可以吗？为什么？"><a href="#用suspend和resume来阻塞线程可以吗？为什么？" class="headerlink" title="用suspend和resume来阻塞线程可以吗？为什么？"></a>用suspend和resume来阻塞线程可以吗？为什么？</h4><p>由于安全问题已经被弃用了，不推荐</p>
<p>suspend并不会破坏，但是suspend和resume不会释放锁，是带着锁进行休息的，这样容易造成死锁</p>
<p>1独占：因为suspend在调用过程中不会释放所占用的锁，所以如果使用不当会造成对公共对象的独占，使得其他线程无法访问公共对象，严重的话造成死锁</p>
<p>2不同步：容易出现因线程暂停导致的数据不同步</p>
<h2 id="彩蛋：Java相关概念"><a href="#彩蛋：Java相关概念" class="headerlink" title="彩蛋：Java相关概念"></a>彩蛋：Java相关概念</h2><p><strong>JavaSE、JavaEE、JavaME是什么？</strong></p>
<p>SE是标准版    EE是企业版    ME是移动版</p>
<p>而现在来说，只要是Java就是JavaSE</p>
<p><strong>JRE和JDK和JVM是什么关系？</strong></p>
<p>JRE包含JVM</p>
<p>JDK包含JRE</p>
<p><strong>Java版本升级都包含了哪些东西的升级</strong></p>
<p>不仅有代码的升级，还有JVM的升级，Java8的代码要去Java8的虚拟机上跑，两者打包一起组合成JRE</p>
<p><strong>Java8和Java1.8和JDK8是什么关系，是同一个东西吗？</strong></p>
<p>Java1.5就是Java5</p>
<p>JDK8是开发包，可理解为同一个东西</p>
<p>Java8和Java1.8和JDK8理解为同一个东西就可以了</p>
<h2 id="sleep方法详解"><a href="#sleep方法详解" class="headerlink" title="sleep方法详解"></a>sleep方法详解</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>只想让线程在预期的时间执行，其他时间不要占用CPU资源</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>不释放锁，无论是synchronized的monitor锁，还是普通的Lock都不释放，和wait不同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 展示线程sleep的时候不释放synchronized的monitor，等sleep时间到了以后，正常结束后才释放锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepDontReleaseMonitor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SleepDontReleaseMonitor sleepDontReleaseMonitor = <span class="keyword">new</span> SleepDontReleaseMonitor();</span><br><span class="line">        <span class="keyword">new</span> Thread(sleepDontReleaseMonitor).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(sleepDontReleaseMonitor).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        syn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"获取到了monitor。"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"退出了同步代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">线程Thread-0获取到了monitor。</span><br><span class="line">线程Thread-0退出了同步代码块</span><br><span class="line">线程Thread-1获取到了monitor。</span><br><span class="line">线程Thread-1退出了同步代码块</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：演示sleep不释放lock（lock需要手动释放）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepDontReleaseLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"获取到了锁"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"已经苏醒"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SleepDontReleaseLock sleepDontReleaseLock = <span class="keyword">new</span> SleepDontReleaseLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(sleepDontReleaseLock).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(sleepDontReleaseLock).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">线程Thread-0获取到了锁</span><br><span class="line">线程Thread-0已经苏醒</span><br><span class="line">线程Thread-1获取到了锁</span><br><span class="line">线程Thread-1已经苏醒</span><br></pre></td></tr></table></figure>

<h3 id="sleep方法响应中断"><a href="#sleep方法响应中断" class="headerlink" title="sleep方法响应中断"></a>sleep方法响应中断</h3><p>第一步：抛出InterruptedException</p>
<p>第二步：清除中断状态</p>
<h3 id="sleep的更优雅的写法"><a href="#sleep的更优雅的写法" class="headerlink" title="sleep的更优雅的写法"></a>sleep的更优雅的写法</h3><p>TimeUnit.SECONDS.sleep()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：每个1秒钟输出当前时间，被中断，观察。</span></span><br><span class="line"><span class="comment"> * Thread.sleep()</span></span><br><span class="line"><span class="comment"> * TimeUnit.SECONDS.sleep()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepInterrupted</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SleepInterrupted());</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">6500</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> Date());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.HOURS.sleep(<span class="number">3</span>);</span><br><span class="line">                TimeUnit.MINUTES.sleep(<span class="number">25</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"我被中断了！"</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种sleep中的内部代码，不会抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> ms = toMillis(timeout);</span><br><span class="line">        <span class="keyword">int</span> ns = excessNanos(timeout, ms);</span><br><span class="line">        Thread.sleep(ms, ns);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>普通的写法如果数值小于0则抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis, <span class="keyword">int</span> nanos)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt;= <span class="number">500000</span> || (nanos != <span class="number">0</span> &amp;&amp; millis == <span class="number">0</span>)) &#123;</span><br><span class="line">        millis++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(millis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>sleep方法可以让线程进入Waiting状态，并且不占用CPU资源，但是不释放锁，直到规定时间后再执行，休眠期间如果被中断，会抛出异常并清除中断状态</p>
<h3 id="常见面试问题-2"><a href="#常见面试问题-2" class="headerlink" title="常见面试问题"></a>常见面试问题</h3><p><strong>wait/notify与sleep的异同</strong></p>
<p>相同</p>
<ol>
<li><p>都会让线程进入阻塞状态</p>
</li>
<li><p>可以响应中断</p>
</li>
</ol>
<p>不同</p>
<ol>
<li>wait/notify必须在同步方法中执行，而sleep不需要</li>
<li>wait/notify会释放锁，而sleep不释放锁</li>
<li>wait/notify不必传递参数，则阻塞到直到被唤醒的时候，sleep必须有参数</li>
<li>所属的类不同</li>
</ol>
<h2 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>因为新的线程加入我们，所以我们要等待它执行完成再出发</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>main等待thread1执行完毕，注意谁等谁</p>
<h3 id="三个例子"><a href="#三个例子" class="headerlink" title="三个例子"></a>三个例子</h3><h4 id="普通用法"><a href="#普通用法" class="headerlink" title="普通用法"></a>普通用法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：演示join，注意语句输出顺序，会变化。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Join</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"执行完毕"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"执行完毕"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        System.out.println(<span class="string">"开始等待子线程运行完毕"</span>);</span><br><span class="line">        thread.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">"所有子线程执行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">开始等待子线程运行完毕</span><br><span class="line">Thread-1执行完毕</span><br><span class="line">Thread-0执行完毕</span><br><span class="line">所有子线程执行完毕</span><br></pre></td></tr></table></figure>

<h4 id="在join遇到中断的时候"><a href="#在join遇到中断的时候" class="headerlink" title="在join遇到中断的时候"></a>在join遇到中断的时候</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     演示join期间被中断的效果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinInterrupt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread mainThread = Thread.currentThread();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mainThread.interrupt();</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    System.out.println(<span class="string">"Thread1 finished."</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"子线程中断"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        System.out.println(<span class="string">"等待子线程运行完毕"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread1.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"主线程中断了"</span>);</span><br><span class="line">            <span class="comment">//注意这里</span></span><br><span class="line">            thread1.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"子线程已运行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">等待子线程运行完毕</span><br><span class="line">main主线程中断了</span><br><span class="line">子线程已运行完毕</span><br><span class="line">子线程中断</span><br></pre></td></tr></table></figure>

<h4 id="在一个线程join期间，另一个线程是什么状态"><a href="#在一个线程join期间，另一个线程是什么状态" class="headerlink" title="在一个线程join期间，另一个线程是什么状态"></a>在一个线程join期间，另一个线程是什么状态</h4><p>Waiting</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：先join再mainThread.getState()</span></span><br><span class="line"><span class="comment"> * 通过debugger看线程join前后状态的对比</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinThreadState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread mainThread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    System.out.println(mainThread.getState());</span><br><span class="line">                    System.out.println(<span class="string">"Thread-0运行结束"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">"等待子线程运行完毕"</span>);</span><br><span class="line">        thread.join();</span><br><span class="line">        System.out.println(<span class="string">"子线程运行完毕"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">等待子线程运行完毕</span><br><span class="line">WAITING</span><br><span class="line">Thread-0运行结束</span><br><span class="line">子线程运行完毕</span><br></pre></td></tr></table></figure>

<h3 id="join的注意点"><a href="#join的注意点" class="headerlink" title="join的注意点"></a>join的注意点</h3><p>CountDownLatch或CycliBarrier同样能达到join的效果</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，每一个Thread类在run方法结束后会自动的执行notify的类似操作，不提倡Thread类的实例去执行wait，因为它会打乱我们自己的计划</p>
<h3 id="join的等价代码"><a href="#join的等价代码" class="headerlink" title="join的等价代码"></a>join的等价代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     通过讲解join原理，分析出join的代替写法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinPrinciple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"执行完毕"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">"开始等待子线程运行完毕"</span>);</span><br><span class="line">        <span class="comment">//thread.join();</span></span><br><span class="line">        <span class="comment">//注意这里，等价替换</span></span><br><span class="line">        <span class="keyword">synchronized</span> (thread) &#123;</span><br><span class="line">            thread.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"所有子线程执行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开始等待子线程运行完毕</span><br><span class="line">Thread-0执行完毕</span><br><span class="line">所有子线程执行完毕</span><br></pre></td></tr></table></figure>

<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p><strong>在join期间，线程处于哪种线程状态</strong></p>
<p>Waiting</p>
<h2 id="yield方法"><a href="#yield方法" class="headerlink" title="yield方法"></a>yield方法</h2><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>释放当前线程CPU的时间片，此时这个线程的状态依然是Runnable，而不是Block，也不是Waiting，这是因为线程yield释放时间片，但不会释放锁，也不会陷入阻塞，下一次CPU调度依然会可能把这个线程调度起来</p>
<h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>JVM并不保证遵循yield的原则，一般开发中不使用yield</p>
<h3 id="yield和sleep的区别"><a href="#yield和sleep的区别" class="headerlink" title="yield和sleep的区别"></a>yield和sleep的区别</h3><p>是否随时可能再次被调度</p>
<p>线程sleep期间，线程调度的时候认为这个线程已经被阻塞了，不会在调度这个线程</p>
<p>线程yield期间，它只是暂时的把资源让给别的线程，但是可以立刻处于竞争者状态，可以随时被调度</p>
<h2 id="线程的各个属性"><a href="#线程的各个属性" class="headerlink" title="线程的各个属性"></a>线程的各个属性</h2><p>什么时候需要设置守护线程？</p>
<p>应该如何应用线程优先级来帮助程序运行？有哪些禁忌？</p>
<p>不同的操作系统如何处理优先级问题？</p>
<h3 id="线程各属性纵览"><a href="#线程各属性纵览" class="headerlink" title="线程各属性纵览"></a>线程各属性纵览</h3><table>
<thead>
<tr>
<th align="center">属性名称</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">编号（ID）</td>
<td align="center">每个线程有自己的ID，用于标识不同的线程，给系统使用的</td>
</tr>
<tr>
<td align="center">名字（Name）</td>
<td align="center">在开发、调试或运行的过程中，更容易区分每个不同的线程、定位问题等，给用户使用的</td>
</tr>
<tr>
<td align="center">是否是守护线程（isDaemon）</td>
<td align="center">true代表该线程是守护线程，false代表线程是非守护线程，也就是用户线程</td>
</tr>
<tr>
<td align="center">优先级（Priority）</td>
<td align="center">优先级这个属性的目的是告诉线程调度器，用户希望哪些线程相对的多运行，哪些少运行</td>
</tr>
</tbody></table>
<h3 id="线程ID"><a href="#线程ID" class="headerlink" title="线程ID"></a>线程ID</h3><p>每个线程有自己的ID，并且ID是不能修改的，线程的ID会从1开始不停的往上自加，mian函数就是第一个线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：ID从1开始，JVM运行起来后，我们自己创建的线程的ID早已不是2.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Id</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread();</span><br><span class="line">        System.out.println(<span class="string">"主线程的ID"</span>+Thread.currentThread().getId());</span><br><span class="line">        System.out.println(<span class="string">"子线程的ID"</span>+thread.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主线程的ID1</span><br><span class="line">子线程的ID11</span><br></pre></td></tr></table></figure>

<p>在Thread类的init方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set thread ID */</span></span><br><span class="line">tid = nextThreadID();</span><br></pre></td></tr></table></figure>

<p>而nextThreadID方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Thread ID</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> tid;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* For generating thread ID */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> threadSeqNumber;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextThreadID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ++threadSeqNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由nextThreadID()方法可以看出，第一个线程是从1开始而不是0</p>
<p>而在运行程序的时候，JVM同时帮助创建多个线程，所以子线程会从11开始</p>
<h3 id="线程名字"><a href="#线程名字" class="headerlink" title="线程名字"></a>线程名字</h3><h4 id="默认线程名字源码分析"><a href="#默认线程名字源码分析" class="headerlink" title="默认线程名字源码分析"></a>默认线程名字源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于没有指定名字的线程，在初始化的时候会传入一个默认的名字</p>
<p>nextThreadNum方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static synchronized int nextThreadNum() &#123;</span><br><span class="line">    return threadInitNumber++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为方法使用synchronized来修饰，所以就不会产生重名的情况</p>
<h4 id="修改线程的名字"><a href="#修改线程的名字" class="headerlink" title="修改线程的名字"></a>修改线程的名字</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>) &#123;</span><br><span class="line">        setNativeName(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果开始的时候忘记设置线程的名字，则依然可以使用setName()来设置线程的名字</p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>作用：给用户线程提供服务</p>
<p>垃圾处理线程就是守护线程</p>
<h4 id="守护线程的三个特性"><a href="#守护线程的三个特性" class="headerlink" title="守护线程的三个特性"></a>守护线程的三个特性</h4><p>1.线程类型默认继承自父线程</p>
<p>我们自己创建的线程还是用户线程，父线程就是用户线程</p>
<p>用户线程创建的线程还是用户线程，守护线程创建的线程还是守护线程</p>
<p>如果用用户线程去创建守护线程，则需要认为的修改属性，使用setDaemon来进行修改</p>
<p>2.通常而言所有的守护线程是由JVM自动启动的，而不是由用户启动的，在JVM启动的时候会有一个非守护线程，就是main函数</p>
<p>3.不影响JVM退出</p>
<p>对于JVM而言，它想退出的时候只看有没有用户线程，不看有没有守护线程</p>
<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>线程一共10个优先级，默认为5</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The minimum priority that a thread can have.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The default priority that is assigned to a thread.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The maximum priority that a thread can have.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>程序设计不应该依赖于优先级</p>
<p>因为不同操作系统不一样，并且优先级会被操作系统改变</p>
<p>在开发过程中，没有必要对线程的优先级进行修改</p>
<h3 id="各属性总结"><a href="#各属性总结" class="headerlink" title="各属性总结"></a>各属性总结</h3><table>
<thead>
<tr>
<th align="center">属性名称</th>
<th align="center">用途</th>
<th align="center">注意事项</th>
</tr>
</thead>
<tbody><tr>
<td align="center">编号（ID）</td>
<td align="center">标识不同的线程</td>
<td align="center">被后续创建的线程使用，唯一性，不允许被修改，系统使用</td>
</tr>
<tr>
<td align="center">名字（Name）</td>
<td align="center">定位问题</td>
<td align="center">清晰有意义的名字，默认的名字，用户使用</td>
</tr>
<tr>
<td align="center">是否是守护线程（isDaemon）</td>
<td align="center">守护线程、用户线程</td>
<td align="center">二选一，默认继承父线程，想修改使用setDaemon但没有必要</td>
</tr>
<tr>
<td align="center">优先级（Priority）</td>
<td align="center">相对多运行</td>
<td align="center">默认和父线程的优先级相等，共有10个等级，默认值是5，不应依赖优先级去做业务逻辑</td>
</tr>
</tbody></table>
<h3 id="面试常见问题"><a href="#面试常见问题" class="headerlink" title="面试常见问题"></a>面试常见问题</h3><p><strong>守护线程和普通线程的区别</strong></p>
<p>1整体无区别，用户线程是处理逻辑的，而守护线程是给用户线程提供服务的</p>
<p>2唯一区别在于JVM的离开</p>
<p>如果是用户线程则会影响到JVM是否退出，守护线程不会影响JVM是否退出</p>
<p><strong>是否需要给线程设置为守护线程</strong></p>
<p>不应该把线程设置为守护线程，设置为守护线程会非常危险，可能会让JVM强制终止，开发过程中不需要使用守护线程，因为JVM自身为用户提供的守护线程足够服务于用户</p>
<p><strong>什么时候我们需要设置守护线程</strong></p>
<p>通常情况下，我们不需要设置守护线程，JVM所提供的守护线程足够使用</p>
<h2 id="未捕获异常UncaughtException如何处理"><a href="#未捕获异常UncaughtException如何处理" class="headerlink" title="未捕获异常UncaughtException如何处理"></a>未捕获异常UncaughtException如何处理</h2><p><strong>考考你</strong></p>
<p>Java异常体系图</p>
<p>实际工作中，如何全局处理异常？为什么要全局处理？不处理行不行?</p>
<h3 id="为什么需要UncaughtExceptionHandler"><a href="#为什么需要UncaughtExceptionHandler" class="headerlink" title="为什么需要UncaughtExceptionHandler"></a>为什么需要UncaughtExceptionHandler</h3><h4 id="1主线程可以轻松发现异常，子线程却不行"><a href="#1主线程可以轻松发现异常，子线程却不行" class="headerlink" title="1主线程可以轻松发现异常，子线程却不行"></a>1主线程可以轻松发现异常，子线程却不行</h4><p>单线程的时候抛出异常，并进行处理，打印出异常堆栈，但是在多线程的情况下，子线程如果抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  子线程发生异常，会有什么不同？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionInChildThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ExceptionInChildThread()).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126Exception in thread &quot;Thread-0&quot; </span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">java.lang.RuntimeException</span><br><span class="line">158	at threadcoreknowledge.uncaughtexception.ExceptionInChildThread.run(ExceptionInChildThread.java:17)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td></tr></table></figure>

<p>子线程会抛出异常，但是对主线程丝毫没有影响，主线程依然会执行</p>
<h4 id="2子线程异常无法用传统方法捕获"><a href="#2子线程异常无法用传统方法捕获" class="headerlink" title="2子线程异常无法用传统方法捕获"></a>2子线程异常无法用传统方法捕获</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：1. 不加try/catch抛出4个异常，都带线程名字</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 说明线程的异常不能用传统方法捕获</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CantCatchDirectly</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> CantCatchDirectly(), <span class="string">"MyThread-1"</span>).start();</span><br><span class="line">            Thread.sleep(<span class="number">300</span>);</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> CantCatchDirectly(), <span class="string">"MyThread-2"</span>).start();</span><br><span class="line">            Thread.sleep(<span class="number">300</span>);</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> CantCatchDirectly(), <span class="string">"MyThread-3"</span>).start();</span><br><span class="line">            Thread.sleep(<span class="number">300</span>);</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> CantCatchDirectly(), <span class="string">"MyThread-4"</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;MyThread-1&quot; java.lang.RuntimeException</span><br><span class="line">	at threadcoreknowledge.uncaughtexception.CantCatchDirectly.run(CantCatchDirectly.java:26)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">Exception in thread &quot;MyThread-2&quot; java.lang.RuntimeException</span><br><span class="line">	at threadcoreknowledge.uncaughtexception.CantCatchDirectly.run(CantCatchDirectly.java:26)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">Exception in thread &quot;MyThread-3&quot; java.lang.RuntimeException</span><br><span class="line">	at threadcoreknowledge.uncaughtexception.CantCatchDirectly.run(CantCatchDirectly.java:26)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">Exception in thread &quot;MyThread-4&quot; java.lang.RuntimeException</span><br><span class="line">	at threadcoreknowledge.uncaughtexception.CantCatchDirectly.run(CantCatchDirectly.java:26)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>

<p>如上结果可以看出，不加try/catch抛出4个异常，都带线程名字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CantCatchDirectly</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> CantCatchDirectly(), <span class="string">"MyThread-1"</span>).start();</span><br><span class="line">            Thread.sleep(<span class="number">300</span>);</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> CantCatchDirectly(), <span class="string">"MyThread-2"</span>).start();</span><br><span class="line">            Thread.sleep(<span class="number">300</span>);</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> CantCatchDirectly(), <span class="string">"MyThread-3"</span>).start();</span><br><span class="line">            Thread.sleep(<span class="number">300</span>);</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> CantCatchDirectly(), <span class="string">"MyThread-4"</span>).start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Caught Exception."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;MyThread-1&quot; java.lang.RuntimeException</span><br><span class="line">	at threadcoreknowledge.uncaughtexception.CantCatchDirectly.run(CantCatchDirectly.java:30)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">Exception in thread &quot;MyThread-2&quot; java.lang.RuntimeException</span><br><span class="line">	at threadcoreknowledge.uncaughtexception.CantCatchDirectly.run(CantCatchDirectly.java:30)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">Exception in thread &quot;MyThread-3&quot; java.lang.RuntimeException</span><br><span class="line">	at threadcoreknowledge.uncaughtexception.CantCatchDirectly.run(CantCatchDirectly.java:30)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">Exception in thread &quot;MyThread-4&quot; java.lang.RuntimeException</span><br><span class="line">	at threadcoreknowledge.uncaughtexception.CantCatchDirectly.run(CantCatchDirectly.java:30)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>

<p>加了try/catch,期望捕获到第一个线程的异常，线程234不应该运行，希望看到打印出CaughtException，执行时发现，根本没有CaughtException，线程234依然运行并且抛出异常</p>
<p>try-catch只能捕获对应线程类的异常，但不能捕获到子线程的异常</p>
<h4 id="3使用UncaughtExceptionHandler可以提高程序的健壮性"><a href="#3使用UncaughtExceptionHandler可以提高程序的健壮性" class="headerlink" title="3使用UncaughtExceptionHandler可以提高程序的健壮性"></a>3使用UncaughtExceptionHandler可以提高程序的健壮性</h4><p>如果不能直接捕获，子线程终止，但是不能处理子线程的异常</p>
<h3 id="两种解决办法"><a href="#两种解决办法" class="headerlink" title="两种解决办法"></a>两种解决办法</h3><h4 id="方案一（不推荐）"><a href="#方案一（不推荐）" class="headerlink" title="方案一（不推荐）"></a>方案一（不推荐）</h4><p>手动在每个run方法里进行try-catch</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CantCatchDirectly</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> CantCatchDirectly(), <span class="string">"MyThread-1"</span>).start();</span><br><span class="line">            Thread.sleep(<span class="number">300</span>);</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> CantCatchDirectly(), <span class="string">"MyThread-2"</span>).start();</span><br><span class="line">            Thread.sleep(<span class="number">300</span>);</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> CantCatchDirectly(), <span class="string">"MyThread-3"</span>).start();</span><br><span class="line">            Thread.sleep(<span class="number">300</span>);</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> CantCatchDirectly(), <span class="string">"MyThread-4"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Caught Exception."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Caught Exception.</span><br><span class="line">Caught Exception.</span><br><span class="line">Caught Exception.</span><br><span class="line">Caught Exception.</span><br></pre></td></tr></table></figure>

<h4 id="方案二（推荐）"><a href="#方案二（推荐）" class="headerlink" title="方案二（推荐）"></a>方案二（推荐）</h4><p>利用UncaughtExceptionHandler来处理异常，它是Thread类所提供的处理器，他能够检查出线程由于未捕获异常而终止的情况，并且对此进行处理</p>
<p>UncaughtExceptionHandler接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Method invoked when the given thread terminates due to the</span></span><br><span class="line"><span class="comment">    * given uncaught exception.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Any exception thrown by this method will be ignored by the</span></span><br><span class="line"><span class="comment">    * Java Virtual Machine.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> t the thread</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> e the exception</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//哪个线程抛出哪个异常</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异常处理器调用策略</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadGroup</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//默认情况下parent是null</span></span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent.uncaughtException(t, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//调用Thread.setDefaultUncaughtExceptionHandler(...)</span></span><br><span class="line">            <span class="comment">//方法设置全局的Handler进行处理</span></span><br><span class="line">            Thread.UncaughtExceptionHandler ueh =</span><br><span class="line">                Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">            <span class="keyword">if</span> (ueh != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ueh.uncaughtException(t, e);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> ThreadDeath)) &#123;</span><br><span class="line">                <span class="comment">//全局Handler也不存在就输出异常栈</span></span><br><span class="line">                System.err.print(<span class="string">"Exception in thread \""</span></span><br><span class="line">                                 + t.getName() + <span class="string">"\" "</span>);</span><br><span class="line">                e.printStackTrace(System.err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有实现DefaultUncaughtExceptionHandler，则此对象为空，如果不为空，则可以对该线程的异常进行处理</p>
<p>其中setDefaultUncaughtExceptionHandler方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDefaultUncaughtExceptionHandler</span><span class="params">(UncaughtExceptionHandler eh)</span> </span>&#123;</span><br><span class="line">	SecurityManager sm = System.getSecurityManager();</span><br><span class="line">	<span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">		sm.checkPermission(<span class="keyword">new</span> RuntimePermission(<span class="string">"setDefaultUncaughtExceptionHandler"</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	defaultUncaughtExceptionHandler = eh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>三种实现方式</p>
<p>1.给程序统一设置（推荐）</p>
<p>2.给每个线程单独设置</p>
<p>3.给线程池设置</p>
<p>给每个线程和给线程池设置相当于精细化处理，开发中使用并不多</p>
<p>自己设置MyUncaughtExceptionHanlder</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：自己的MyUncaughtExceptionHanlder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyUncaughtExceptionHandler</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        Logger logger = Logger.getAnonymousLogger();</span><br><span class="line">        logger.log(Level.WARNING, <span class="string">"线程异常，终止啦"</span> + t.getName(),e);</span><br><span class="line">        System.out.println(name + <span class="string">"捕获了异常"</span> + t.getName() + <span class="string">"异常"</span>+e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建新线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：使用刚才自己写的UncaughtExceptionHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseOwnUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> MyUncaughtExceptionHandler(<span class="string">"捕获器1"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> UseOwnUncaughtExceptionHandler(), <span class="string">"MyThread-1"</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">300</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> UseOwnUncaughtExceptionHandler(), <span class="string">"MyThread-2"</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">300</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> UseOwnUncaughtExceptionHandler(), <span class="string">"MyThread-3"</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">300</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> UseOwnUncaughtExceptionHandler(), <span class="string">"MyThread-4"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p><img src="/2020/03/06/4悟空Java并发编程/线程8大核心基础/image-20200307131526595.png" alt="image-20200307131526595"></p>
<h3 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h3><p>Java异常体系</p>
<p>如何全局处理异常？为什么要全局处理？不处理行不行？</p>
<p>run方法是否可以抛出异常？如果抛出异常，线程的状态会怎么样？</p>
<p>线程中如何处理某个未处理异常？</p>
<h2 id="双刃剑：多线程会导致的问题"><a href="#双刃剑：多线程会导致的问题" class="headerlink" title="双刃剑：多线程会导致的问题"></a>双刃剑：多线程会导致的问题</h2><p><img src="/2020/03/06/4悟空Java并发编程/线程8大核心基础/image-20200202005758106.png" alt="image-20200202005758106"></p>
<p>多线程的弊端主要分为两大部分：线程安全与性能问题</p>
<p><strong>考一考</strong></p>
<p>一共有哪几种线程安全问题？3种</p>
<p>哪些场景需要额外注意线程安全问题？</p>
<p>什么是多线程带来的上下文切换？</p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><h4 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h4><p>&lt;&lt;Java Concurrency In Practice&gt;&gt;的作者Brian Goetz对“线程安全”有一个比较恰当的定义：</p>
<p>当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协作操作，调用这个对象的行为都可以获得正确的结果，那这个对象时线程安全的</p>
<p>翻译：</p>
<p>不管业务中遇到怎样的多线程访问某个对象或某个方法的情况，而在编写这个业务逻辑的时候，都不需要额外做任何处理（也就是可以像单线程编程一样），程序也可以正常运行（不会因为多线程而出错），就可以称为线程安全</p>
<h4 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h4><p>不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据</p>
<p>如果一个类完全不用于多线程，就没有必要设计成线程安全的</p>
<h2 id="什么情况下会出现线程安全问题，如何避免"><a href="#什么情况下会出现线程安全问题，如何避免" class="headerlink" title="什么情况下会出现线程安全问题，如何避免"></a>什么情况下会出现线程安全问题，如何避免</h2><p>第一种情况就是数据争用，最典型的案例就是两个线程同时去写，同时写就会导致其中一个线程中的数据要么被丢弃，要么写入错误，最终造成错误数据</p>
<p>第二种情况就是竞争条件，竞争条件主要指的是执行顺序，比如想要读取一个文件的内容，自然应该是写入文件之后的，但如果线程之间配合不好，在一个线程没有写完另一个线程就去读取，这就会造成顺序上的错误</p>
<h3 id="案例1运行结果错误"><a href="#案例1运行结果错误" class="headerlink" title="案例1运行结果错误"></a>案例1运行结果错误</h3><p>a++多先查下出现消失的请求现象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：第一种：运行结果出错。</span></span><br><span class="line"><span class="comment"> * 演示计数不准确（减少），找出具体出错的位置。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadsError</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> MultiThreadsError instance=<span class="keyword">new</span> MultiThreadsError();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(instance.index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">19485</span><br></pre></td></tr></table></figure>

<p>如图</p>
<img src="/2020/03/06/4悟空Java并发编程/线程8大核心基础/image-20200307192244172.png" alt="image-20200307192244172" style="zoom:50%;">

<p>现在知道确实得到的数据要比20000要少，但是哪几次少，少在哪里，就像得出的结果是19485，则少了515次，现在想知道少的这515次是在哪一次少的，当这些少的次数一旦发生的时候，希望能够得到发生的问题的位置</p>
<p><strong>升级1</strong></p>
<p>既然两个线程会出现线程的争抢，出现数据的错误，则在每一个线程执行<code>index++</code>之后，就立刻对线程进行检查</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadsError</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//真正所加的数量</span></span><br><span class="line">    <span class="keyword">static</span> AtomicInteger realIndex = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="comment">//出错的数量</span></span><br><span class="line">    <span class="keyword">static</span> AtomicInteger wrongCount = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span>[] marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">10000000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> MultiThreadsError instance = <span class="keyword">new</span> MultiThreadsError();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">"表面上结果是"</span> + instance.index);</span><br><span class="line">        System.out.println(<span class="string">"真正运行的次数"</span> + realIndex.get());</span><br><span class="line">        System.out.println(<span class="string">"错误运行的次数"</span> + wrongCount.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="comment">//正确的数量增加</span></span><br><span class="line">            realIndex.incrementAndGet();</span><br><span class="line">            <span class="comment">//第一个线程进来执行index++，并将index设置为true，第二个线程进来在执行index++之后检查marked[index]是否为true，如果为true则说明使用的是第一个线程所使用过的数值，则这个数值发生了错误，所以先检查是否marked[index]被标记过</span></span><br><span class="line">            <span class="keyword">if</span> (marked[index]) &#123;</span><br><span class="line">                System.out.println(<span class="string">"发生了错误"</span> + index);</span><br><span class="line">                <span class="comment">//错误的数量进行增加</span></span><br><span class="line">                wrongCount.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">            marked[index] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">发生了错误241</span><br><span class="line">发生了错误1535</span><br><span class="line">发生了错误2118</span><br><span class="line">发生了错误2118</span><br><span class="line">发生了错误3782</span><br><span class="line">发生了错误4543</span><br><span class="line">发生了错误5872</span><br><span class="line">发生了错误7100</span><br><span class="line">发生了错误8236</span><br><span class="line">发生了错误9480</span><br><span class="line">发生了错误10694</span><br><span class="line">发生了错误11762</span><br><span class="line">发生了错误12919</span><br><span class="line">表面上结果是19976</span><br><span class="line">真正运行的次数20000</span><br><span class="line">错误运行的次数13</span><br></pre></td></tr></table></figure>

<p>此时得到的结果发现<code>表面上结果是</code>中的值，与<code>错误运行的次数</code>中的值相加之后得到的结果不为2000，可能发生的原因是当第一个线程执行<code>realIndex.incrementAndGet();</code>语句，之后执行<code>if (marked[index]) {</code>,，因为为false所以没有进入其中执行，当要执行<code>marked[index] = true;</code>的时候，此时第二个线程抢夺了资源，执行到<code>if (marked[index]) {</code>的时候也是false，没有进入执行，所以会出现表面上结果是与错误运行的次数相加结果少于20000的情况</p>
<p><strong>升级2</strong></p>
<p>添加闸门</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadsError</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//真正所加的数量</span></span><br><span class="line">    <span class="keyword">static</span> AtomicInteger realIndex = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="comment">//出错的数量</span></span><br><span class="line">    <span class="keyword">static</span> AtomicInteger wrongCount = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> CyclicBarrier cyclicBarrier1 = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span>[] marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">10000000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> MultiThreadsError instance = <span class="keyword">new</span> MultiThreadsError();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">"表面上结果是"</span> + instance.index);</span><br><span class="line">        System.out.println(<span class="string">"真正运行的次数"</span> + realIndex.get());</span><br><span class="line">        System.out.println(<span class="string">"错误运行的次数"</span> + wrongCount.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        marked[<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//如果有两个线程都执行过await()，代表所等待的内容都到齐了，就会放行</span></span><br><span class="line">                cyclicBarrier1.await();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//正确的数量增加</span></span><br><span class="line">            realIndex.incrementAndGet();</span><br><span class="line">            <span class="keyword">synchronized</span> (instance) &#123;</span><br><span class="line">                <span class="comment">//第一个线程进来执行index++，并将index设置为true，第二个线程进来在执行index++之后检查marked[index]是否为true，如果为true则说明使用的是第一个线程所使用过的数值，则这个数值发生了错误，所以先检查是否marked[index]被标记过</span></span><br><span class="line">                <span class="comment">//要求前一个位置的marked[index-1]也为true</span></span><br><span class="line">                <span class="keyword">if</span> (marked[index]&amp;&amp;marked[index-<span class="number">1</span>]) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"发生了错误"</span> + index);</span><br><span class="line">                    <span class="comment">//错误的数量进行增加</span></span><br><span class="line">                    wrongCount.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line">                marked[index] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">发生了错误13071</span><br><span class="line">发生了错误19712</span><br><span class="line">表面上结果是19998</span><br><span class="line">真正运行的次数20000</span><br><span class="line">错误运行的次数2</span><br></pre></td></tr></table></figure>

<h3 id="案例2死锁、活锁、饥饿"><a href="#案例2死锁、活锁、饥饿" class="headerlink" title="案例2死锁、活锁、饥饿"></a>案例2死锁、活锁、饥饿</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：演示死锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadError</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flag ;</span><br><span class="line">    <span class="keyword">static</span> Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> Object o2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MultiThreadError r1 = <span class="keyword">new</span> MultiThreadError();</span><br><span class="line">        MultiThreadError r2 = <span class="keyword">new</span> MultiThreadError();</span><br><span class="line">        r1.flag = <span class="number">1</span>;</span><br><span class="line">        r2.flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(r1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r2).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"flag = "</span> + flag);</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"1"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"0"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flag = 1</span><br><span class="line">flag = 0</span><br><span class="line">Thread-0</span><br><span class="line">Thread-1</span><br></pre></td></tr></table></figure>

<h3 id="案例3对象发布和初始化的时候的安全问题"><a href="#案例3对象发布和初始化的时候的安全问题" class="headerlink" title="案例3对象发布和初始化的时候的安全问题"></a>案例3对象发布和初始化的时候的安全问题</h3><h4 id="什么是对象发布"><a href="#什么是对象发布" class="headerlink" title="什么是对象发布"></a>什么是对象发布</h4><p>使对象能够被当前范围之外的代码所看见。比如通过类的非私有方法返回对象的引用</p>
<h4 id="什么是逸出"><a href="#什么是逸出" class="headerlink" title="什么是逸出"></a>什么是逸出</h4><p>一种错误的发布。当一个对象还没有构造完成时，就被其他线程所看见</p>
<h4 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h4><p><strong>方法返回一个private对象，private的本意是不让外部访问对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadsError3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; states;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiThreadsError3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        states = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        states.put(<span class="string">"1"</span>, <span class="string">"周一"</span>);</span><br><span class="line">        states.put(<span class="string">"2"</span>, <span class="string">"周二"</span>);</span><br><span class="line">        states.put(<span class="string">"3"</span>, <span class="string">"周三"</span>);</span><br><span class="line">        states.put(<span class="string">"4"</span>, <span class="string">"周四"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">getStates</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> states;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MultiThreadsError3 multiThreadsError3 = <span class="keyword">new</span> MultiThreadsError3();</span><br><span class="line">        Map&lt;String, String&gt; states = multiThreadsError3.getStates();</span><br><span class="line">        System.out.println(states.get(<span class="string">"1"</span>));</span><br><span class="line">        <span class="comment">//注意这里可以将声明为private的states删除掉</span></span><br><span class="line">        states.remove(<span class="string">"1"</span>);</span><br><span class="line">        System.out.println(states.get(<span class="string">"1"</span>));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">周一</span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<p>由于外部的操作造成这样的原因就是因为通过构造函数把本应该私有的变量states给发布出去了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">getStates</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> states;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h4><p><strong>还未完成初始化（构造函数没完全执行完毕）就把对象提供给外界，如下</strong></p>
<p><strong>1在构造函数中未初始化完毕就this赋值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：初始化未完毕，就this赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadsError4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Point point;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> PointMaker().start();</span><br><span class="line">        <span class="comment">//注意这里</span></span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (point != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(point);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        MultiThreadsError4.point = <span class="keyword">this</span>;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + <span class="string">","</span> + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PointMaker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1,0</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadsError4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Point point;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> PointMaker().start();</span><br><span class="line">        Thread.sleep(<span class="number">105</span>);</span><br><span class="line">        <span class="keyword">if</span> (point != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(point);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        MultiThreadsError4.point = <span class="keyword">this</span>;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + <span class="string">","</span> + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PointMaker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1,1</span><br></pre></td></tr></table></figure>

<p>出现以上的原因是因为对y的初始化是比较迟的，对x初始化是比较早的，x的值与y的值有先有后，由于过早的把</p>
<p><code>MultiThreadsError4.point = this;</code>发布出来了，所以导致看到的x与y在不同的时刻是不一样的</p>
<p><strong>2隐式逸出，注册监听事件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     观察者模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadsError5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiThreadsError5</span><span class="params">(MySource source)</span> </span>&#123;</span><br><span class="line">        source.registerListener(<span class="keyword">new</span> EventListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"\n我得到的数字是"</span> + count);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            System.out.print(i);</span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MySource mySource = <span class="keyword">new</span> MySource();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                mySource.eventCome(<span class="keyword">new</span> Event() &#123;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        MultiThreadsError5 multiThreadsError5 = <span class="keyword">new</span> MultiThreadsError5(mySource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MySource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> EventListener listener;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">registerListener</span><span class="params">(EventListener eventListener)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.listener = eventListener;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">eventCome</span><span class="params">(Event e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                listener.onEvent(e);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"还未初始化完毕"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3构造函数中运行线程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：构造函数中新建线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadsError6</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; states;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiThreadsError6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在构造函数中开启了一个线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                states = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                states.put(<span class="string">"1"</span>, <span class="string">"周一"</span>);</span><br><span class="line">                states.put(<span class="string">"2"</span>, <span class="string">"周二"</span>);</span><br><span class="line">                states.put(<span class="string">"3"</span>, <span class="string">"周三"</span>);</span><br><span class="line">                states.put(<span class="string">"4"</span>, <span class="string">"周四"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">getStates</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> states;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MultiThreadsError6 multiThreadsError6 = <span class="keyword">new</span> MultiThreadsError6();</span><br><span class="line">        System.out.println(multiThreadsError6.getStates().get(<span class="string">"1"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException</span><br><span class="line">	at background.MultiThreadsError6.main</span><br></pre></td></tr></table></figure>

<p>构造函数中不应该以新建线程的方式做初始化，因为初始化的工作在另外一个线程中还没有初始化完毕，所以会报空指针异常</p>
<p>如果有一定时间的等待，则会取到正确的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadsError6</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; states;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiThreadsError6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在构造函数中开启了一个线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                states = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                states.put(<span class="string">"1"</span>, <span class="string">"周一"</span>);</span><br><span class="line">                states.put(<span class="string">"2"</span>, <span class="string">"周二"</span>);</span><br><span class="line">                states.put(<span class="string">"3"</span>, <span class="string">"周三"</span>);</span><br><span class="line">                states.put(<span class="string">"4"</span>, <span class="string">"周四"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">getStates</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> states;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MultiThreadsError6 multiThreadsError6 = <span class="keyword">new</span> MultiThreadsError6();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(multiThreadsError6.getStates().get(<span class="string">"1"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">周一</span><br></pre></td></tr></table></figure>

<h4 id="如何解决逸出"><a href="#如何解决逸出" class="headerlink" title="如何解决逸出"></a>如何解决逸出</h4><p>针对第一种可以采用返回“副本”的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadsError3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; states;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiThreadsError3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        states = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        states.put(<span class="string">"1"</span>, <span class="string">"周一"</span>);</span><br><span class="line">        states.put(<span class="string">"2"</span>, <span class="string">"周二"</span>);</span><br><span class="line">        states.put(<span class="string">"3"</span>, <span class="string">"周三"</span>);</span><br><span class="line">        states.put(<span class="string">"4"</span>, <span class="string">"周四"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">getStates</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> states;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,String&gt; <span class="title">getStatesImproved</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;&gt;(states);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MultiThreadsError3 multiThreadsError3 = <span class="keyword">new</span> MultiThreadsError3();</span><br><span class="line">        System.out.println(multiThreadsError3.getStatesImproved().get(<span class="string">"1"</span>));</span><br><span class="line">        multiThreadsError3.getStatesImproved().remove(<span class="string">"1"</span>);</span><br><span class="line">        System.out.println(multiThreadsError3.getStatesImproved().get(<span class="string">"1"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">周一</span><br><span class="line">周一</span><br></pre></td></tr></table></figure>

<p>针对第二种可以采用工厂模式的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：用工厂模式修复刚才的初始化问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadsError7</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> EventListener listener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MultiThreadsError7</span><span class="params">(MySource source)</span> </span>&#123;</span><br><span class="line">        listener = <span class="keyword">new</span> EventListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(MultiThreadsError5.Event e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"\n我得到的数字是"</span> + count);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            System.out.print(i);</span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MultiThreadsError7 <span class="title">getInstance</span><span class="params">(MySource source)</span> </span>&#123;</span><br><span class="line">        MultiThreadsError7 safeListener = <span class="keyword">new</span> MultiThreadsError7(source);</span><br><span class="line">        source.registerListener(safeListener.listener);</span><br><span class="line">        <span class="keyword">return</span> safeListener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MySource mySource = <span class="keyword">new</span> MySource();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                mySource.eventCome(<span class="keyword">new</span> MultiThreadsError5.Event() &#123;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        MultiThreadsError7 multiThreadsError7 = <span class="keyword">new</span> MultiThreadsError7(mySource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MySource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> EventListener listener;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">registerListener</span><span class="params">(EventListener eventListener)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.listener = eventListener;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">eventCome</span><span class="params">(MultiThreadsError5.Event e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                listener.onEvent(e);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"还未初始化完毕"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(MultiThreadsError5.Event e)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>各种需要考虑线程安全的情况</p>
<ul>
<li><p>访问共享的变量或资源，会有并发风险，比如对象的属性、静态变量、共享缓存、数据库等</p>
</li>
<li><p>所有依赖时序的操作，即使每一步操作都是线程安全的，还是存在并发问题，主要有两种，一个是先读取再修改，一个是先检查再执行</p>
</li>
<li><p>不同的数据之间存在绑定关系的时候，一个非常典型的例子就是IP和端口号，它们之间不能说是只修改一个不修改另一个</p>
</li>
<li><p>使用其他类的时候，如果对方没有声明自己是线程安全的会出现线程安全的情况，所以应该考虑，如果是线程安全的类，应该标记为安全的，如果是线程不安全的类，也应该标记为不安全的</p>
</li>
</ul>
<h2 id="多线程带来的性能问题"><a href="#多线程带来的性能问题" class="headerlink" title="多线程带来的性能问题"></a>多线程带来的性能问题</h2><h3 id="为什么多线程会带来性能问题"><a href="#为什么多线程会带来性能问题" class="headerlink" title="为什么多线程会带来性能问题"></a>为什么多线程会带来性能问题</h3><p>第一个是调度原因，上下文切换</p>
<p>第二个是协作原因，内存同步</p>
<h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><h4 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换"></a>什么是上下文切换</h4><p><strong>上下文</strong></p>
<p>首先，需要讲清楚什么是上下文。</p>
<p>每个任务运行前，CPU 都需要知道任务从哪里加载、又从哪里开始运行，这就涉及到 CPU 寄存器 和 程序计数器（PC）：</p>
<ul>
<li>CPU 寄存器是 CPU 内置的容量小、但速度极快的内存</li>
<li>程序计数器会存储 CPU 正在执行的指令位置，或者即将执行的指令位置</li>
</ul>
<p>这两个是 CPU 运行任何任务前都必须依赖的环境，因此叫做 CPU 上下文。</p>
<p><strong>上下文切换</strong></p>
<p>那么，什么是上下文切换呢？下面是一个上下文切换时需要履行的步骤：</p>
<ol>
<li><p>将前一个 CPU 的上下文（也就是 CPU 寄存器和程序计数器里边的内容）保存起来</p>
</li>
<li><p>然后加载新任务的上下文到寄存器和程序计数器</p>
</li>
<li><p>最后跳转到程序计数器所指的新位置，运行新任务</p>
</li>
</ol>
<p>被保存起来的上下文会存储到系统内核中，等待任务重新调度执行时再次加载进来。</p>
<p>CPU 的上下文切换分三种：进程上下文切换、线程上下文切换、中断上下文切换。</p>
<h4 id="何谓缓存失效"><a href="#何谓缓存失效" class="headerlink" title="何谓缓存失效"></a>何谓缓存失效</h4><p>对于一个并发量大的项目，缓存是必须的，如果没有缓存，所有的请求将直击数据库，数据库很有可能抗不住，所以建立缓存势在不行。</p>
<p>那么建立缓存后就有可能出现缓存失效的问题：</p>
<ol>
<li>大面积的缓存key失效</li>
<li>热点key失效</li>
</ol>
<p>类似12306网站，因为用户频繁的查询车次信息，假设所有车次信息都建立对应的缓存，那么如果所有车次建立缓存的时间一样，失效时间也一样，那么在缓存失效的这一刻，也就意味着所有车次的缓存都失效。通常当缓存失效的时候我们需要重构缓存，这时所有的车次都将面临重构缓存，即出现问题1的场景，此时数据库就将面临大规模的访问。<br>针对以上这种情况，可以将建立缓存的时间进行分布，使得缓存失效时间尽量不同，从而避免大面积的缓存失效。</p>
<h4 id="何时会导致密集的上下文切换"><a href="#何时会导致密集的上下文切换" class="headerlink" title="何时会导致密集的上下文切换"></a>何时会导致密集的上下文切换</h4><p>抢锁、IO</p>
<h2 id="常见面试问题-3"><a href="#常见面试问题-3" class="headerlink" title="常见面试问题"></a>常见面试问题</h2><p>有多少种实现线程的方法？思路有5点</p>
<p>实现Runnable接口和继承Thread类哪种方式更好</p>
<p>一个线程两次调用start()方法会调用run()方法，为什么选择调用start()方法，而不是直接调用run()方法？</p>
<p>如何停止线程？</p>
<p>如何处理不可中断的阻塞？</p>
<p>用程序实现两个线程交替打印0~100的奇偶数</p>
<p>手写生产者消费者模式</p>
<p>为什么wait()需要在同步代码块中使用，而sleep()不需要</p>
<p>为什么线程通信的方法wait()，notify()和notifyAll()被定义在Object类里，而sleep定义在Thread类里？</p>
<p>wait()方法属于Object对象的，那调用Thread.wait()会怎么样？</p>
<p>如何选择用notify还是notifyAll?</p>
<p>notifyAll之后所有的线程都会再次抢夺锁，如果某线程抢夺失败会怎么样？</p>
<p>用suspend()和resume()来阻塞线程可以吗？为什么？</p>
<p>wait()/notify()、sleep()异同</p>
<p>在join期间，线程处于哪种线程状态</p>
<p>守护线程和普通线程的区别</p>
<p>是否需要给线程设置为守护线程</p>
<p>run()方法是否可以抛出异常，如果抛出异常，线程的状态会怎么样</p>
<p>线程中如何处理某个未处理异常</p>
<p>什么是多线程的上下文切换</p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2020/03/06/4悟空Java并发编程/线程8大核心基础/">多线程三之线程8大核心基础</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">爱吃鱼的呆先生</a></p>
        <p><span>发布时间:</span>2020-03-06, 17:41:28</p>
        <p><span>最后更新:</span>2020-03-09, 19:16:25</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2020/03/06/4悟空Java并发编程/线程8大核心基础/" title="多线程三之线程8大核心基础">http://yoursite.com/2020/03/06/4悟空Java并发编程/线程8大核心基础/</a>
            <span class="copy-path" data-clipboard-text="原文: http://yoursite.com/2020/03/06/4悟空Java并发编程/线程8大核心基础/　　作者: 爱吃鱼的呆先生" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2020/03/06/4悟空Java并发编程/详解之同步synchronized/">
                    多线程二之高并发详解之同步synchronized关键字
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2020/03/06/4悟空Java并发编程/治理线程的第二法宝/">
                    
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#线程8大核心基础"><span class="toc-number">1.</span> <span class="toc-text">线程8大核心基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#实现多线程的方法到底有1种还是2种还是4种"><span class="toc-number">1.1.</span> <span class="toc-text">实现多线程的方法到底有1种还是2种还是4种</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#网上说法"><span class="toc-number">1.1.1.</span> <span class="toc-text">网上说法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#正确说法"><span class="toc-number">1.1.2.</span> <span class="toc-text">正确说法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#方法一"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">方法一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法二"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">方法二</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#两种方法的对比"><span class="toc-number">1.1.3.</span> <span class="toc-text">两种方法的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#两种方法的本质区别"><span class="toc-number">1.1.4.</span> <span class="toc-text">两种方法的本质区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#思考题"><span class="toc-number">1.1.5.</span> <span class="toc-text">思考题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">1.1.6.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#经典错误观点"><span class="toc-number">1.1.7.</span> <span class="toc-text">经典错误观点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#彩蛋"><span class="toc-number">1.1.8.</span> <span class="toc-text">彩蛋</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#如何从宏观和微观两个方面来提高技术"><span class="toc-number">1.1.8.1.</span> <span class="toc-text">如何从宏观和微观两个方面来提高技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何了解技术领域的前沿动态"><span class="toc-number">1.1.8.2.</span> <span class="toc-text">如何了解技术领域的前沿动态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见面试题"><span class="toc-number">1.1.9.</span> <span class="toc-text">常见面试题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#启动线程的正确和错误方式"><span class="toc-number">1.2.</span> <span class="toc-text">启动线程的正确和错误方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#start-和run-的比较"><span class="toc-number">1.2.1.</span> <span class="toc-text">start()和run()的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#start-方法原理解读"><span class="toc-number">1.2.2.</span> <span class="toc-text">start()方法原理解读</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#start-方法含义12"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">start()方法含义12</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1启动新线程"><span class="toc-number">1.2.2.1.1.</span> <span class="toc-text">1启动新线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2start-方法的准备工作"><span class="toc-number">1.2.2.1.2.</span> <span class="toc-text">2start()方法的准备工作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#不能重复执行start-方法"><span class="toc-number">1.2.2.1.3.</span> <span class="toc-text">不能重复执行start()方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#源码解析"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">源码解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#run-方法原理解读"><span class="toc-number">1.2.3.</span> <span class="toc-text">run()方法原理解读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见面试题-1"><span class="toc-number">1.2.4.</span> <span class="toc-text">常见面试题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何正确停止线程"><span class="toc-number">1.3.</span> <span class="toc-text">如何正确停止线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原理介绍"><span class="toc-number">1.3.1.</span> <span class="toc-text">原理介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最佳实践：如何正确停止线程"><span class="toc-number">1.3.2.</span> <span class="toc-text">最佳实践：如何正确停止线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#通常线程会在什么情况下停止"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">通常线程会在什么情况下停止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用interrupt的几种情况"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">使用interrupt的几种情况</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1正常情况下停止线程"><span class="toc-number">1.3.2.2.1.</span> <span class="toc-text">1正常情况下停止线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2线程被阻塞的时候停止线程"><span class="toc-number">1.3.2.2.2.</span> <span class="toc-text">2线程被阻塞的时候停止线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3如果线程在每次迭代的时候都阻塞"><span class="toc-number">1.3.2.2.3.</span> <span class="toc-text">3如果线程在每次迭代的时候都阻塞</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4while内try-catch的问题"><span class="toc-number">1.3.2.2.4.</span> <span class="toc-text">4while内try/catch的问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实际开发中的两种最佳实践"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">实际开发中的两种最佳实践</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#响应中断的方法总结列表"><span class="toc-number">1.3.3.</span> <span class="toc-text">响应中断的方法总结列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#正确停止带来的好处"><span class="toc-number">1.3.4.</span> <span class="toc-text">正确停止带来的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#错误的停止方法"><span class="toc-number">1.3.5.</span> <span class="toc-text">错误的停止方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1被弃用的stop方法"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">1被弃用的stop方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2suspend和resume方法"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">2suspend和resume方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3用volatile设置boolean标记位"><span class="toc-number">1.3.5.3.</span> <span class="toc-text">3用volatile设置boolean标记位</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#看上去可行"><span class="toc-number">1.3.5.3.1.</span> <span class="toc-text">看上去可行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#错误之处"><span class="toc-number">1.3.5.3.2.</span> <span class="toc-text">错误之处</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#修正方案"><span class="toc-number">1.3.5.3.3.</span> <span class="toc-text">修正方案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#停止线程相关的重要函数解析"><span class="toc-number">1.3.6.</span> <span class="toc-text">停止线程相关的重要函数解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见面试题-2"><span class="toc-number">1.3.7.</span> <span class="toc-text">常见面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1如何停止线程"><span class="toc-number">1.3.7.1.</span> <span class="toc-text">1如何停止线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2如何处理不可中断的阻塞"><span class="toc-number">1.3.7.2.</span> <span class="toc-text">2如何处理不可中断的阻塞</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程的6个状态（生命周期）"><span class="toc-number">1.4.</span> <span class="toc-text">线程的6个状态（生命周期）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的6种状态"><span class="toc-number">1.4.1.</span> <span class="toc-text">线程的6种状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#每个状态的含义"><span class="toc-number">1.4.2.</span> <span class="toc-text">每个状态的含义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#New"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">New</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Runnable"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">Runnable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Blocked"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">Blocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Waiting"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">Waiting</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Timed-Waiting"><span class="toc-number">1.4.2.5.</span> <span class="toc-text">Timed Waiting</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Terminated"><span class="toc-number">1.4.2.6.</span> <span class="toc-text">Terminated</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#状态间的转化图示"><span class="toc-number">1.4.3.</span> <span class="toc-text">状态间的转化图示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#状态转化的特殊情况"><span class="toc-number">1.4.4.</span> <span class="toc-text">状态转化的特殊情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阻塞状态是什么"><span class="toc-number">1.4.5.</span> <span class="toc-text">阻塞状态是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见面试问题"><span class="toc-number">1.4.6.</span> <span class="toc-text">常见面试问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Thread类和Object类中的重要方法解析"><span class="toc-number">1.5.</span> <span class="toc-text">Thread类和Object类中的重要方法解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#方法概览"><span class="toc-number">1.5.1.</span> <span class="toc-text">方法概览</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wait、notify、notifyAll方法详解"><span class="toc-number">1.6.</span> <span class="toc-text">wait、notify、notifyAll方法详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#作用与用法"><span class="toc-number">1.6.1.</span> <span class="toc-text">作用与用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码演示"><span class="toc-number">1.6.2.</span> <span class="toc-text">代码演示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1普通用法"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">1普通用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2notify和notifyAll的用法"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">2notify和notifyAll的用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3只释放当前monitor的用法"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">3只释放当前monitor的用法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait、notify、notifyAll特点"><span class="toc-number">1.6.3.</span> <span class="toc-text">wait、notify、notifyAll特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait原理"><span class="toc-number">1.6.4.</span> <span class="toc-text">wait原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#手写生产者消费者设计模式"><span class="toc-number">1.6.5.</span> <span class="toc-text">手写生产者消费者设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么要使用生产者和消费者模式"><span class="toc-number">1.6.5.1.</span> <span class="toc-text">为什么要使用生产者和消费者模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见面试问题-1"><span class="toc-number">1.6.6.</span> <span class="toc-text">常见面试问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用程序实现两个线程交替打印0-100的奇偶数"><span class="toc-number">1.6.6.1.</span> <span class="toc-text">用程序实现两个线程交替打印0~100的奇偶数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#手写生产者消费者设计模式-1"><span class="toc-number">1.6.6.2.</span> <span class="toc-text">手写生产者消费者设计模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么wait-需要在同步代码块内使用，而sleep-不需要"><span class="toc-number">1.6.6.3.</span> <span class="toc-text">为什么wait()需要在同步代码块内使用，而sleep()不需要</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么线程通信的方法wait、notify和notifyAll被定义在Object类里？而sleep定义在Thread类里？"><span class="toc-number">1.6.6.4.</span> <span class="toc-text">为什么线程通信的方法wait、notify和notifyAll被定义在Object类里？而sleep定义在Thread类里？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wait方法是属于Object对象的，那调用Thread-wait会怎么样？"><span class="toc-number">1.6.6.5.</span> <span class="toc-text">wait方法是属于Object对象的，那调用Thread.wait会怎么样？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何选择用notify还是notifyAll"><span class="toc-number">1.6.6.6.</span> <span class="toc-text">如何选择用notify还是notifyAll?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#notifyAll之后所有的线程都会再次抢夺锁，如果某线程抢夺失败怎么办？"><span class="toc-number">1.6.6.7.</span> <span class="toc-text">notifyAll之后所有的线程都会再次抢夺锁，如果某线程抢夺失败怎么办？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#用suspend和resume来阻塞线程可以吗？为什么？"><span class="toc-number">1.6.6.8.</span> <span class="toc-text">用suspend和resume来阻塞线程可以吗？为什么？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#彩蛋：Java相关概念"><span class="toc-number">1.7.</span> <span class="toc-text">彩蛋：Java相关概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sleep方法详解"><span class="toc-number">1.8.</span> <span class="toc-text">sleep方法详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#作用"><span class="toc-number">1.8.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特点"><span class="toc-number">1.8.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep方法响应中断"><span class="toc-number">1.8.3.</span> <span class="toc-text">sleep方法响应中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep的更优雅的写法"><span class="toc-number">1.8.4.</span> <span class="toc-text">sleep的更优雅的写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结-1"><span class="toc-number">1.8.5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见面试问题-2"><span class="toc-number">1.8.6.</span> <span class="toc-text">常见面试问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#join方法"><span class="toc-number">1.9.</span> <span class="toc-text">join方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#作用-1"><span class="toc-number">1.9.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用法"><span class="toc-number">1.9.2.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三个例子"><span class="toc-number">1.9.3.</span> <span class="toc-text">三个例子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#普通用法"><span class="toc-number">1.9.3.1.</span> <span class="toc-text">普通用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在join遇到中断的时候"><span class="toc-number">1.9.3.2.</span> <span class="toc-text">在join遇到中断的时候</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在一个线程join期间，另一个线程是什么状态"><span class="toc-number">1.9.3.3.</span> <span class="toc-text">在一个线程join期间，另一个线程是什么状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join的注意点"><span class="toc-number">1.9.4.</span> <span class="toc-text">join的注意点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原理"><span class="toc-number">1.9.5.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join的等价代码"><span class="toc-number">1.9.6.</span> <span class="toc-text">join的等价代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题"><span class="toc-number">1.9.7.</span> <span class="toc-text">面试题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#yield方法"><span class="toc-number">1.10.</span> <span class="toc-text">yield方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#作用-2"><span class="toc-number">1.10.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定位"><span class="toc-number">1.10.2.</span> <span class="toc-text">定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yield和sleep的区别"><span class="toc-number">1.10.3.</span> <span class="toc-text">yield和sleep的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程的各个属性"><span class="toc-number">1.11.</span> <span class="toc-text">线程的各个属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程各属性纵览"><span class="toc-number">1.11.1.</span> <span class="toc-text">线程各属性纵览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程ID"><span class="toc-number">1.11.2.</span> <span class="toc-text">线程ID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程名字"><span class="toc-number">1.11.3.</span> <span class="toc-text">线程名字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#默认线程名字源码分析"><span class="toc-number">1.11.3.1.</span> <span class="toc-text">默认线程名字源码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#修改线程的名字"><span class="toc-number">1.11.3.2.</span> <span class="toc-text">修改线程的名字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#守护线程"><span class="toc-number">1.11.4.</span> <span class="toc-text">守护线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#守护线程的三个特性"><span class="toc-number">1.11.4.1.</span> <span class="toc-text">守护线程的三个特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程优先级"><span class="toc-number">1.11.5.</span> <span class="toc-text">线程优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#各属性总结"><span class="toc-number">1.11.6.</span> <span class="toc-text">各属性总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试常见问题"><span class="toc-number">1.11.7.</span> <span class="toc-text">面试常见问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#未捕获异常UncaughtException如何处理"><span class="toc-number">1.12.</span> <span class="toc-text">未捕获异常UncaughtException如何处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么需要UncaughtExceptionHandler"><span class="toc-number">1.12.1.</span> <span class="toc-text">为什么需要UncaughtExceptionHandler</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1主线程可以轻松发现异常，子线程却不行"><span class="toc-number">1.12.1.1.</span> <span class="toc-text">1主线程可以轻松发现异常，子线程却不行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2子线程异常无法用传统方法捕获"><span class="toc-number">1.12.1.2.</span> <span class="toc-text">2子线程异常无法用传统方法捕获</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3使用UncaughtExceptionHandler可以提高程序的健壮性"><span class="toc-number">1.12.1.3.</span> <span class="toc-text">3使用UncaughtExceptionHandler可以提高程序的健壮性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#两种解决办法"><span class="toc-number">1.12.2.</span> <span class="toc-text">两种解决办法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#方案一（不推荐）"><span class="toc-number">1.12.2.1.</span> <span class="toc-text">方案一（不推荐）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方案二（推荐）"><span class="toc-number">1.12.2.2.</span> <span class="toc-text">方案二（推荐）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现方式"><span class="toc-number">1.12.3.</span> <span class="toc-text">实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题-1"><span class="toc-number">1.12.4.</span> <span class="toc-text">面试题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#双刃剑：多线程会导致的问题"><span class="toc-number">1.13.</span> <span class="toc-text">双刃剑：多线程会导致的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程安全"><span class="toc-number">1.13.1.</span> <span class="toc-text">线程安全</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是线程安全"><span class="toc-number">1.13.1.1.</span> <span class="toc-text">什么是线程安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程不安全"><span class="toc-number">1.13.1.2.</span> <span class="toc-text">线程不安全</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么情况下会出现线程安全问题，如何避免"><span class="toc-number">1.14.</span> <span class="toc-text">什么情况下会出现线程安全问题，如何避免</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#案例1运行结果错误"><span class="toc-number">1.14.1.</span> <span class="toc-text">案例1运行结果错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#案例2死锁、活锁、饥饿"><span class="toc-number">1.14.2.</span> <span class="toc-text">案例2死锁、活锁、饥饿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#案例3对象发布和初始化的时候的安全问题"><span class="toc-number">1.14.3.</span> <span class="toc-text">案例3对象发布和初始化的时候的安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是对象发布"><span class="toc-number">1.14.3.1.</span> <span class="toc-text">什么是对象发布</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是逸出"><span class="toc-number">1.14.3.2.</span> <span class="toc-text">什么是逸出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#案例1"><span class="toc-number">1.14.3.3.</span> <span class="toc-text">案例1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#案例2"><span class="toc-number">1.14.3.4.</span> <span class="toc-text">案例2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何解决逸出"><span class="toc-number">1.14.3.5.</span> <span class="toc-text">如何解决逸出</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结-2"><span class="toc-number">1.14.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程带来的性能问题"><span class="toc-number">1.15.</span> <span class="toc-text">多线程带来的性能问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么多线程会带来性能问题"><span class="toc-number">1.15.1.</span> <span class="toc-text">为什么多线程会带来性能问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调度"><span class="toc-number">1.15.2.</span> <span class="toc-text">调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是上下文切换"><span class="toc-number">1.15.2.1.</span> <span class="toc-text">什么是上下文切换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#何谓缓存失效"><span class="toc-number">1.15.2.2.</span> <span class="toc-text">何谓缓存失效</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#何时会导致密集的上下文切换"><span class="toc-number">1.15.2.3.</span> <span class="toc-text">何时会导致密集的上下文切换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见面试问题-3"><span class="toc-number">1.16.</span> <span class="toc-text">常见面试问题</span></a></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"多线程三之线程8大核心基础　| 爱吃鱼的呆先生　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2020/03/06/4悟空Java并发编程/详解之同步synchronized/" title="上一篇: 多线程二之高并发详解之同步synchronized关键字">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2020/03/06/4悟空Java并发编程/治理线程的第二法宝/" title="下一篇: ">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/05/07/Mybatis/1mybatis高级原理分析/">1mybatis高级原理分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/07/Mybatis/Mybatis基础1/">mybatis基础详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/04/Vue/Vue1/">Vue/Vue1</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/03/面试/简历/">面试/简历</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/01/SpringDataJPA/SpringDataJPA/">SpringDataJPA</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/01/ELK/Logstash/">Logstash</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/01/ELK/ElasticSearch/">ElasticSearch</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/29/0编程工具/easyExcel/">easyExcel</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/28/ZooKeeper/3Zookeeper/">第1章Zookeeper理论基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/24/Spring/2Spring核心理解/">Spring/2Spring核心理解</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/23/数据结构/动态规划/">数据结构/动态规划</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/21/Json/Json/">Json详解以及fastjson使用教程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/18/SpringMVC/SpringMVC/">SpringMVC/SpringMVC</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/18/Kafka/Kafka/">Kafka/Kafka</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/14/0编程工具/Idea/">Idea</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/31/9Redis/1Redis/">Redis1</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/29/SpringCloud/1SpringCloud/">Spring Cloud基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/29/ZooKeeper/1Zookeeper/">第1章Zookeeper理论基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/8MySQL/4MySQL/">8MySQL/4MySQL</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/24/8MySQL/3MySQL/">8MySQL/3MySQL</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/21/8MySQL/2MySQL/">8MySQL/2MySQL</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/20/8MySQL/1MySQL/">MySQL介绍和基本的SQL编写及解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/19/0编程工具/Linux5/">0编程工具/Linux5</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/17/0编程工具/Linux3/">Linux3</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/15/0编程工具/Linux2/">Linux2</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/15/数据结构/2栈和队列/">栈和队列</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/15/数据结构/1数组/">数组</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/10/0编程工具/Linux/">Linux1</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/锁/">锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/详解之同步synchronized/">多线程二之高并发详解之同步synchronized关键字</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/线程8大核心基础/">多线程三之线程8大核心基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/治理线程的第二法宝/">4悟空Java并发编程/治理线程的第二法宝</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/控制并发流程/">4悟空Java并发编程/控制并发流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/并发编程的基石/">多线程一之并发编程的基石</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/并发工具类纵览/">并发工具类</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/并发容器精讲/">4悟空Java并发编程/并发容器精讲</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/实战项目/">4悟空Java并发编程/实战项目</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/原子类/">原子类</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/ThreadLocal详解/">ThreadLocal详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/Java内存模型之底层原理/">Java内存模型之底层原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/4悟空Java并发编程/AQS/">4悟空Java并发编程/AQS</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/3Java高级/Java反射机制/">Java反射机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/3Java高级/Java8新特性/">Java8新特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/3Java高级/IO流/">IO流</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/2Java常用类/String类型相关习题/">String类型相关习题</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/2Java常用类/StringBuffer与StringBuilder/">StringBuffer与StringBuilder</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/2Java常用类/1String与String相关的类/">String详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/1Java基础/面向对象二5/">面向对象二</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/1Java基础/面向对象三6/">面向对象三</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/1Java基础/面向对象一4/">面向对象一</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/1Java基础/数组8/">数组</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/1Java基础/排序算法/">十大排序算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/1Java基础/异常7/">异常处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/1Java基础/八大排序算法9/">八大排序算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/1Java基础/代码简洁之道/">代码简洁之道</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/1Java基础/java3流程控制/">1Java基础/java3流程控制</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/1Java基础/Java2基本语法/">1Java基础/Java2基本语法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/1Java基础/Java1概述/">Java概述</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/06/0编程工具/Git&GitHub/">Git&GitHub</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/13/MybatisPlus/MyBatisPlus/">MyBatisPlus</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2019-2020 爱吃鱼的呆先生
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>