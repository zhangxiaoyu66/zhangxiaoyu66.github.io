<!DOCTYPE html>
<html lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="爱吃鱼的呆先生">


    
    


<meta property="og:type" content="website">
<meta property="og:title" content="爱吃鱼的呆先生">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="爱吃鱼的呆先生">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="爱吃鱼的呆先生">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="爱吃鱼的呆先生" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>爱吃鱼的呆先生</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: false
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">爱吃鱼的呆先生</a></h1>
        </hgroup>

        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云与分类</a></li>
                        
                            <li><a href="/pdfdocuments/">pdf文档笔记</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="https://mail.163.com/" title="Email"></a>
                            
                                <a class="fa CSDN" href="https://www.csdn.net/" title="CSDN"></a>
                            
                                <a class="fa Coding" href="https://coding.net/login" title="Coding"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElasticSearch/">ElasticSearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Idea/">Idea</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Json/">Json</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Logstash/">Logstash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatisPlus/">MyBatisPlus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL基础/">MySQL基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Cloud/">Spring Cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringDataJPA/">SpringDataJPA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/String/">String</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zookeeper/">Zookeeper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/easyExcel/">easyExcel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://mybatis.org/mybatis-3/zh/index.html">Mybatis</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://spring.io/projects/spring-framework#overview">Spring</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://spring.io/projects/spring-boot">SpringBoot</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">真正的大师永远保持一颗学徒的心</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">爱吃鱼的呆先生</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">爱吃鱼的呆先生</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云与分类</a></li>
                
                    <li><a href="/pdfdocuments/">pdf文档笔记</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="https://mail.163.com/" title="Email"></a>
                            
                                <a class="fa CSDN" target="_blank" href="https://www.csdn.net/" title="CSDN"></a>
                            
                                <a class="fa Coding" target="_blank" href="https://coding.net/login" title="Coding"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-4悟空Java并发编程/线程8大核心基础" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/06/4悟空Java并发编程/线程8大核心基础/" class="article-date">
      <time datetime="2020-03-06T09:41:28.653Z" itemprop="datePublished">2020-03-06</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/06/4悟空Java并发编程/线程8大核心基础/">多线程三之线程8大核心基础</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <h1 id="线程8大核心基础"><a href="#线程8大核心基础" class="headerlink" title="线程8大核心基础"></a>线程8大核心基础</h1><h2 id="实现多线程的方法到底有1种还是2种还是4种"><a href="#实现多线程的方法到底有1种还是2种还是4种" class="headerlink" title="实现多线程的方法到底有1种还是2种还是4种"></a>实现多线程的方法到底有1种还是2种还是4种</h2><h3 id="网上说法"><a href="#网上说法" class="headerlink" title="网上说法"></a>网上说法</h3><p>1种的观点，2种的观点，4种的观点，其他观点</p>
<h3 id="正确说法"><a href="#正确说法" class="headerlink" title="正确说法"></a>正确说法</h3><p>Oracle官网的文档是如何写的？</p>
<p>正确答案是2种</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">There are two ways to create a new thread of execution. One is to declare a class to be a subclass of Thread. This subclass should override the run method of class Thread. An instance of the subclass can then be allocated and started.</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The other way to create a thread is to declare a class that implements the Runnable interface. That class then implements the run method. An instance of the class can then be allocated, passed as an argument when creating Thread, and started.</span><br></pre></td></tr></table></figure>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java多线程/">Java多线程</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/2020/03/06/4悟空Java并发编程/线程8大核心基础/#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-4悟空Java并发编程/治理线程的第二法宝" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/06/4悟空Java并发编程/治理线程的第二法宝/" class="article-date">
      <time datetime="2020-03-06T09:41:28.648Z" itemprop="datePublished">2020-03-06</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="治理线程的第二法宝"><a href="#治理线程的第二法宝" class="headerlink" title="治理线程的第二法宝"></a>治理线程的第二法宝</h1><p>Future和Callable</p>
<h2 id="Runnable的缺陷"><a href="#Runnable的缺陷" class="headerlink" title="Runnable的缺陷"></a>Runnable的缺陷</h2><p>不能返回一个返回值</p>
<p>不能抛出checked Exception异常</p>
<h2 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h2><p>类似于Runnable，被其他线程执行的任务</p>
<p>实现call方法</p>
<p>有返回值</p>
<p>看源码</p>
<h2 id="Future类"><a href="#Future类" class="headerlink" title="Future类"></a>Future类</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><h3 id="Callable和Future的关系"><a href="#Callable和Future的关系" class="headerlink" title="Callable和Future的关系"></a>Callable和Future的关系</h3><p>可以用<code>Future.get()</code>来获取Callable接口返回的执行结果，可以通过<code>Future.isDone()</code>来判断任务是否已经执行完，以及取消这个任务，限时获取任务的结果等</p>
<p>在call()未执行完毕之前，调用get()的线程会阻塞，直到call()方法返回了结果后，此时Future.get()才会得到该结果，然后主线程才会切换到Runnable状态</p>
<p>Future是一个存储器，它存储了call()这个任务的结果，而这个任务的执行时间是无法提前确定的，因为这完全取决于call()方法执行的情况</p>
<h3 id="Future的主要方法"><a href="#Future的主要方法" class="headerlink" title="Future的主要方法"></a>Future的主要方法</h3><p>一共5个</p>
<p><strong>get()</strong></p>
<p>获取结果，get()方法的行为取决于Callable任务的执行状态，只有以下这5种状况</p>
<ol>
<li>任务正常完成：get()方法会立即返回结果</li>
<li>任务尚未完成（任务还没开始或进行中）：get()将阻塞并直接完成任务</li>
<li>任务执行过程中抛出Exception：get()方法会抛出ExecutionException，这里的抛出异常，是call()执行时产生的那个异常，这个异常类型是java.util.concurrent.Exception，不论call()执行时抛出的异常类型是什么，最后get方法抛出的异常类型都是ExectionException</li>
<li>任务被取消：get()方法会抛出CancellationException</li>
<li>任务超时：get()方法有一个重载方法，是传入一个延时时间。如果时间到了还没有获得结果，get方法就会抛出TimeoutException</li>
</ol>
<p><strong>get(long timeout,TimeUnit unit)</strong></p>
<p>有超时时间的获取</p>
<p>超时的需求很常见</p>
<p>用<code>get(long timeout,TimeUnit unit)</code>方法时，如果call()在规定时间内完成了任务，那么就会正常获取到返回值，如果在指定时间内没有计算出结果，就会抛出TimeoutException</p>
<p>超时不获取则任务需要取消</p>
<p><strong>cancel()</strong></p>
<p>取消任务的执行</p>
<p><strong>isDone()</strong></p>
<p>判断线程是否执行完毕</p>
<p><strong>isCancelled()</strong></p>
<p>判断是否被取消</p>
<h3 id="get-基本用法"><a href="#get-基本用法" class="headerlink" title="get()基本用法"></a>get()基本用法</h3><p>线程池的submit方法返回Future对象</p>
<img src="/2020/03/06/4悟空Java并发编程/治理线程的第二法宝/1.png" style="zoom:67%;">

<p>首先要给线程池提交任务，提交过后线程池会立即返回一个空的Future容器，当线程的任务执行完毕，也就是可以获取结果的时候，线程池便会把该结果填入之前的Future中，而不是创建一个新的Future，此时便可以从该Future中获得任务的执行结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     演示一个Future的使用方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneFuture</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        Future&lt;Integer&gt; future = service.submit(<span class="keyword">new</span> CallableTask());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="多个任务用Future数组来获取结果"><a href="#多个任务用Future数组来获取结果" class="headerlink" title="多个任务用Future数组来获取结果"></a>多个任务用Future数组来获取结果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     演示批量提交任务时，用List来批量接收结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiFutures</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">        ArrayList&lt;Future&gt; futures = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            Future&lt;Integer&gt; future = service.submit(<span class="keyword">new</span> CallableTask());</span><br><span class="line">            futures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            Future&lt;Integer&gt; future = futures.get(i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Integer integer = future.get();</span><br><span class="line">                System.out.println(integer);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="任务执行过程中抛出异常Exception和isDone"><a href="#任务执行过程中抛出异常Exception和isDone" class="headerlink" title="任务执行过程中抛出异常Exception和isDone"></a>任务执行过程中抛出异常Exception和isDone</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     演示get方法过程中抛出异常，for循环为了演示抛出Exception的时机：并不是说一产生异常就抛出，直到我们get执行时，才会抛出。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">        Future&lt;Integer&gt; future = service.submit(<span class="keyword">new</span> CallableTask());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(future.isDone());</span><br><span class="line">            future.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"InterruptedException异常"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"ExecutionException异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Callable抛出异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">true</span><br><span class="line">java.util.concurrent.ExecutionException: java.lang.IllegalArgumentException: Callable抛出异常</span><br><span class="line">	at java.util.concurrent.FutureTask.report(FutureTask.java:122)</span><br><span class="line">	at java.util.concurrent.FutureTask.get(FutureTask.java:192)</span><br><span class="line">	at future.GetException.main(GetException.java:26)</span><br><span class="line">Caused by: java.lang.IllegalArgumentException: Callable抛出异常</span><br><span class="line">ExecutionException异常</span><br></pre></td></tr></table></figure>

<h3 id="获取任务超时"><a href="#获取任务超时" class="headerlink" title="获取任务超时"></a>获取任务超时</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     演示get的超时方法，需要注意超时后处理，调用future.cancel()。</span></span><br><span class="line"><span class="comment"> * 演示cancel传入true和false的区别，future.cancel()代表是否中断正在执行的任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Timeout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Ad DEFAULT_AD = <span class="keyword">new</span> Ad(<span class="string">"无网络时候的默认广告"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService exec = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Ad</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Ad</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Ad&#123;"</span> +</span><br><span class="line">                    <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                    <span class="string">'&#125;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FetchAdTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Ad</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Ad <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"sleep期间被中断了"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Ad(<span class="string">"被中断时候的默认广告"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Ad(<span class="string">"旅游订票哪家强？找某程"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Future&lt;Ad&gt; f = exec.submit(<span class="keyword">new</span> FetchAdTask());</span><br><span class="line">        Ad ad;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ad = f.get(<span class="number">2000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            ad = <span class="keyword">new</span> Ad(<span class="string">"被中断时候的默认广告"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            ad = <span class="keyword">new</span> Ad(<span class="string">"异常时候的默认广告"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            ad = <span class="keyword">new</span> Ad(<span class="string">"超时时候的默认广告"</span>);</span><br><span class="line">            System.out.println(<span class="string">"超时，未获取到广告"</span>);</span><br><span class="line">            <span class="keyword">boolean</span> cancel = f.cancel(<span class="keyword">true</span>);</span><br><span class="line">            System.out.println(<span class="string">"cancel的结果："</span> + cancel);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">        System.out.println(ad);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Timeout timeout = <span class="keyword">new</span> Timeout();</span><br><span class="line">        timeout.printAd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="cancel-方法"><a href="#cancel-方法" class="headerlink" title="cancel()方法"></a>cancel()方法</h3><p>取消任务的执行</p>
<ol>
<li>如果这个任务还没有开始执行，任务会被正常取消，以后也不会被执行，方法返回true</li>
<li>如果任务已完成或者已取消，那么cancel()方法会执行失败，方法返回false</li>
<li>如果这个任务已经开始执行了，那么这个取消方法将不会直接取消该任务，而是会根据填的参数mayInterruptIfRunning做判断</li>
</ol>
<p>Future.cancel(true)适用于</p>
<ol>
<li>任务能够处理interrupt</li>
</ol>
<p>Future.cancel(false)仅用于避免启动尚未启动的任务，适用于</p>
<ol>
<li>未能处理interrupt的任务</li>
<li>不清楚任务是否支持取消</li>
<li>需要等待已经开始的任务执行完成</li>
</ol>
<h3 id="用FutureTasK来创建Future"><a href="#用FutureTasK来创建Future" class="headerlink" title="用FutureTasK来创建Future"></a>用FutureTasK来创建Future</h3><p>用FutureTask来获取Future和任务的结果</p>
<p>FutureTask是一种包装器，可以把Callable转化成Future和Runnable，它同时实现二者的接口</p>
<img src="/2020/03/06/4悟空Java并发编程/治理线程的第二法宝/image-20200227085312718.png" alt="image-20200227085312718" style="zoom:50%;">

<p>所以它即可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值</p>
<p>把Callable实例当做参数，生成FutureTask的对象，然后把这个对象当做一个Runnable对象，用线程池或另起一个线程去执行这个Runnable对象，最后通过FutureTask获取刚才执行的结果</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>当for循环批量获Future的结果时，容易发生一部分线程很慢的情况，get()方法调用时应该使用timeout限制</p>
<img src="/2020/03/06/4悟空Java并发编程/治理线程的第二法宝/image-20200227090342711.png" alt="image-20200227090342711" style="zoom:50%;">

<p>Future的声明周期不能后退，生命周期只能前进，不能后退</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-4悟空Java并发编程/控制并发流程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/06/4悟空Java并发编程/控制并发流程/" class="article-date">
      <time datetime="2020-03-06T09:41:28.643Z" itemprop="datePublished">2020-03-06</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="控制并发流程"><a href="#控制并发流程" class="headerlink" title="控制并发流程"></a>控制并发流程</h1><h2 id="什么是控制并发流程"><a href="#什么是控制并发流程" class="headerlink" title="什么是控制并发流程"></a>什么是控制并发流程</h2><p>控制并发流程的工具类，作用就是帮助程序员更容易让线程之间进行合作，让线程之间相互配合，来满足业务需求，比如让线程A等待线程B执行完毕后再执行等合作策略</p>
<p><img src="/2020/03/06/4悟空Java并发编程/控制并发流程/image-20200225092105118.png" alt="image-20200225092105118"></p>
<h2 id="CountDownLatch倒计时门闩"><a href="#CountDownLatch倒计时门闩" class="headerlink" title="CountDownLatch倒计时门闩"></a>CountDownLatch倒计时门闩</h2><h3 id="CountDownLatch类的作用"><a href="#CountDownLatch类的作用" class="headerlink" title="CountDownLatch类的作用"></a>CountDownLatch类的作用</h3><p>并发流程控制的工具</p>
<p>倒数门闩，例子：购物拼团，大巴（游乐园坐过山车排队），人满发车</p>
<p>流程：倒数结束之前，一直处于等待状态，直到倒计时结束了，此程序才继续工作</p>
<p><img src="/2020/03/06/4悟空Java并发编程/控制并发流程/image-20200225093115937.png" alt="image-20200225093115937"></p>
<h3 id="类的主要方法介绍"><a href="#类的主要方法介绍" class="headerlink" title="类的主要方法介绍"></a>类的主要方法介绍</h3><p>CountDownLatch(int count)</p>
<p>仅有一个构造函数，参数count为需要倒数的数值</p>
<p>await()</p>
<p>调用await()方法的线程会被挂起，他会等待直到count值为0才继续执行</p>
<p>countDown()</p>
<p>将count值减1，直到为0时，等待的线程会被唤醒</p>
<h3 id="图解await和countDown方法"><a href="#图解await和countDown方法" class="headerlink" title="图解await和countDown方法"></a>图解await和countDown方法</h3><p><img src="/2020/03/06/4悟空Java并发编程/控制并发流程/image-20200225094810249.png" alt="image-20200225094810249"></p>
<h3 id="两种典型用法"><a href="#两种典型用法" class="headerlink" title="两种典型用法"></a>两种典型用法</h3><h4 id="用法一"><a href="#用法一" class="headerlink" title="用法一"></a>用法一</h4><p>一个线程等待多个线程都执行完毕，在继续执行自己的工作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     工厂中，质检，5个工人检查，所有人都认为通过，才通过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">CountDownLatchDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> no = i + <span class="number">1</span>;</span><br><span class="line">            Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line">                        System.out.println(<span class="string">"No."</span> + no + <span class="string">"完成了检查。"</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        latch.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            service.submit(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"等待5个人检查完....."</span>);</span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">"所有人都完成了工作，进入下一个环节。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">等待5个人检查完.....</span><br><span class="line">No.5完成了检查。</span><br><span class="line">No.3完成了检查。</span><br><span class="line">No.2完成了检查。</span><br><span class="line">No.1完成了检查。</span><br><span class="line">No.4完成了检查。</span><br><span class="line">所有人都完成了工作，进入下一个环节。</span><br></pre></td></tr></table></figure>

<h4 id="用法二"><a href="#用法二" class="headerlink" title="用法二"></a>用法二</h4><p>多个线程等待某一个线程的信号，同时开始执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     模拟100米跑步，5名选手都准备好了，只等裁判员一声令下，所有人同时开始跑步。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch begin = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> no = i + <span class="number">1</span>;</span><br><span class="line">            Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"No."</span> + no + <span class="string">"准备完毕，等待发令枪"</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        begin.await();</span><br><span class="line">                        System.out.println(<span class="string">"No."</span> + no + <span class="string">"开始跑步了"</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            service.submit(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//裁判员检查发令枪...</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(<span class="string">"发令枪响，比赛开始！"</span>);</span><br><span class="line">        begin.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">No.1准备完毕，等待发令枪</span><br><span class="line">No.2准备完毕，等待发令枪</span><br><span class="line">No.3准备完毕，等待发令枪</span><br><span class="line">No.4准备完毕，等待发令枪</span><br><span class="line">No.5准备完毕，等待发令枪</span><br><span class="line">发令枪响，比赛开始！</span><br><span class="line">No.1开始跑步了</span><br><span class="line">No.5开始跑步了</span><br><span class="line">No.4开始跑步了</span><br><span class="line">No.3开始跑步了</span><br><span class="line">No.2开始跑步了</span><br></pre></td></tr></table></figure>

<p>一等多与多等一结合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     模拟100米跑步，5名选手都准备好了，只等裁判员一声令下，所有人同时开始跑步。当所有人都到终点后，比赛结束。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo1And2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch begin = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        CountDownLatch end = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> no = i + <span class="number">1</span>;</span><br><span class="line">            Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"No."</span> + no + <span class="string">"准备完毕，等待发令枪"</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        begin.await();</span><br><span class="line">                        System.out.println(<span class="string">"No."</span> + no + <span class="string">"开始跑步了"</span>);</span><br><span class="line">                        Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line">                        System.out.println(<span class="string">"No."</span> + no + <span class="string">"跑到终点了"</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        end.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            service.submit(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//裁判员检查发令枪...</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(<span class="string">"发令枪响，比赛开始！"</span>);</span><br><span class="line">        begin.countDown();</span><br><span class="line"></span><br><span class="line">        end.await();</span><br><span class="line">        System.out.println(<span class="string">"所有人到达终点，比赛结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">No.1准备完毕，等待发令枪</span><br><span class="line">No.3准备完毕，等待发令枪</span><br><span class="line">No.2准备完毕，等待发令枪</span><br><span class="line">No.4准备完毕，等待发令枪</span><br><span class="line">No.5准备完毕，等待发令枪</span><br><span class="line">发令枪响，比赛开始！</span><br><span class="line">No.1开始跑步了</span><br><span class="line">No.2开始跑步了</span><br><span class="line">No.3开始跑步了</span><br><span class="line">No.5开始跑步了</span><br><span class="line">No.4开始跑步了</span><br><span class="line">No.3跑到终点了</span><br><span class="line">No.4跑到终点了</span><br><span class="line">No.1跑到终点了</span><br><span class="line">No.2跑到终点了</span><br><span class="line">No.s</span><br><span class="line">所有人到达终点，比赛结束</span><br></pre></td></tr></table></figure>

<p>注意点</p>
<p>扩展用法：多个线程等多个线程完成执行后，再同时执行</p>
<p>CountDownLatch是不能够重用的，如果需要重新计算，可以考虑使用CyclicBarrier或者创建新的CountDownLatch实例</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>两个典型用法：一等多和多等一</p>
<p>CountDownLatch类在创建实例的时候，需要传递倒数次数，倒数到0的时候，之前等待的线程会继续执行</p>
<p>CountDownLatch不能回滚重置</p>
<h2 id="Semaphore信号量"><a href="#Semaphore信号量" class="headerlink" title="Semaphore信号量"></a>Semaphore信号量</h2><p>Semaphore可以用来限制或管理数量有限的资源的使用情况</p>
<p>例子：工厂污水排放，污染不能太多，污染许可证只能发3张</p>
<p>信号量的作用是维护一个“许可证”的计数，线程可以获取”许可证“，那信号量剩余的许可证就减一，线程也可以释放一个”许可证“，那信号量剩余的许可证就加一，当信号量所拥有的许可证数量为0，那么下一个还想要获取许可证的线程，就需要等待，直到有另外的线程释放了许可证</p>
<p><img src="/2020/03/06/4悟空Java并发编程/控制并发流程/image-20200225103525920.png" alt="image-20200225103525920"></p>
<h3 id="Semaphore应用实例"><a href="#Semaphore应用实例" class="headerlink" title="Semaphore应用实例"></a>Semaphore应用实例</h3><p><img src="/2020/03/06/4悟空Java并发编程/控制并发流程/image-20200225103946103.png" alt="image-20200225103946103"></p>
<p><strong>没有使用信号量</strong></p>
<p><img src="/2020/03/06/4悟空Java并发编程/控制并发流程/image-20200225104104867.png" alt="image-20200225104104867"></p>
<p><strong>使用信号量</strong></p>
<p>正常情况下获取许可证</p>
<p>线程1</p>
<img src="/2020/03/06/4悟空Java并发编程/控制并发流程/image-20200225104243810.png" alt="image-20200225104243810" style="zoom: 80%;">

<img src="/2020/03/06/4悟空Java并发编程/控制并发流程/image-20200225104317178.png" alt="image-20200225104317178" style="zoom: 80%;"> 

<p>线程2</p>
<img src="/2020/03/06/4悟空Java并发编程/控制并发流程/image-20200225104357416.png" alt="image-20200225104357416" style="zoom: 80%;">

<p>线程3</p>
<img src="/2020/03/06/4悟空Java并发编程/控制并发流程/image-20200225104708377.png" alt="image-20200225104708377" style="zoom: 80%;">

<p>线程4</p>
<p>线程4就被挡住了</p>
 <img src="/2020/03/06/4悟空Java并发编程/控制并发流程/image-20200225104846249.png" alt="image-20200225104846249" style="zoom:80%;">

<p>直到线程1归还许可证</p>
<img src="/2020/03/06/4悟空Java并发编程/控制并发流程/image-20200225105016379.png" alt="image-20200225105016379" style="zoom:80%;">

<p>更多的线程进来</p>
<img src="/2020/03/06/4悟空Java并发编程/控制并发流程/image-20200225105211821.png" alt="image-20200225105211821" style="zoom:80%;">

<p>总结</p>
<img src="/2020/03/06/4悟空Java并发编程/控制并发流程/image-20200225105250007.png" alt="image-20200225105250007" style="zoom:80%;">

<h3 id="信号量使用流程"><a href="#信号量使用流程" class="headerlink" title="信号量使用流程"></a>信号量使用流程</h3><ol>
<li>初始化Semaphore，并指定许可证的数量</li>
<li>在需要被执行的代码前加acquire()或者acquireUninterruptibly()方法，以acquire()为主</li>
<li>在任务执行结束后，调用release()来释放许可证</li>
</ol>
<h3 id="信号量主要方法介绍"><a href="#信号量主要方法介绍" class="headerlink" title="信号量主要方法介绍"></a>信号量主要方法介绍</h3><p>new Semaphore(int permits,boolean fair)</p>
<p>这里可以设置是否要使用公平策略，如果传入true，那么Semaphore会把之前等待的线程放到FIFO的队列里，以便于当有了新的许可证时，可以分发给之前等了最长时间的线程</p>
<p>accquire()</p>
<p>获取许可</p>
<p>accquireUninterruptibly()</p>
<p>tryAcquire()</p>
<p>看现在有没有空闲的许可证，如果有的话就去获取，如果没有也不必进入阻塞，可以去做别的事，过一段时间再来查看许可证的空闲情况，返回的boolean类型</p>
<p>tryAcquire(timeout)</p>
<p>和tryAcquire()一样，但是多了一个超时时间，如在3秒内获取不到许可证，就去做别的事</p>
<p>release()</p>
<p>归还许可证</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     演示Semaphore用法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">50</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            service.submit(<span class="keyword">new</span> Task());</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"拿到了许可证"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"释放了许可证"</span>);</span><br><span class="line">            semaphore.release(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1拿到了许可证</span><br><span class="line">pool-1-thread-1释放了许可证</span><br><span class="line">pool-1-thread-2拿到了许可证</span><br><span class="line">pool-1-thread-2释放了许可证</span><br><span class="line">pool-1-thread-3拿到了许可证</span><br><span class="line">pool-1-thread-3释放了许可证</span><br><span class="line">pool-1-thread-4拿到了许可证</span><br><span class="line">pool-1-thread-4释放了许可证</span><br><span class="line">pool-1-thread-5拿到了许可证</span><br><span class="line">pool-1-thread-5释放了许可证</span><br><span class="line">pool-1-thread-6拿到了许可证</span><br><span class="line">pool-1-thread-6释放了许可证</span><br><span class="line">pool-1-thread-7拿到了许可证</span><br><span class="line">pool-1-thread-7释放了许可证</span><br><span class="line">pool-1-thread-8拿到了许可证</span><br><span class="line">pool-1-thread-8释放了许可证</span><br><span class="line">pool-1-thread-9拿到了许可证</span><br><span class="line">pool-1-thread-9释放了许可证</span><br><span class="line">pool-1-thread-10拿到了许可证</span><br><span class="line">pool-1-thread-10释放了许可证</span><br><span class="line">pool-1-thread-11拿到了许可证</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="信号量的特殊用法"><a href="#信号量的特殊用法" class="headerlink" title="信号量的特殊用法"></a>信号量的特殊用法</h3><p>一次性获取或释放多个许可证</p>
<p>比如TaskA会调用很消耗资源的method1()，而TaskB()调用的是不太消耗资源的method2()，假设一共有5个许可证，那么就要求TaskA获取5个许可证才能执行，而TaskB只需要获取到一个许可证就能执行，这样就避免了A和B同时运行的情况，用户可以根据自己的需求合理分配资源</p>
<p>获取和释放的许可证数量必须一致，如果每次都获取2个但是只释放一个甚至不释放，随着时间的推移，到最后许可证的数量不够用，就会使程序卡死</p>
<p>虽然信号量类并不对是否和获取数量做规范，但是这是程序员的编程规范，否则容易报错</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li><p>在初始化Semaphore的时候设置公平性，一般设置为true会更合理</p>
</li>
<li><p>并不是必须由获取许可证的线程释放那个许可证，事实上，获取和释放许可证对新安村并无要求，也许是A获取了，然后由B释放，只要逻辑合理即可</p>
</li>
<li><p>信号量的作用，除了处理临界区最多同时有N个线程访问外，另一个作用是可以实现“条件等待”，例如线程1需要在线程2完成准备工作后才开始工作，那么就线程1acquire()，而线程2完成任务后release()，这样的话，相当于轻量级的CountDownLatch</p>
</li>
</ol>
<h2 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h2><p>又称条件对象，是绑定在锁上的</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>当线程1需要等待某个条件的时候，就去执行<code>condition.await()</code>方法，一旦执行了<code>await()</code>方法，线程1就会进入阻塞状态</p>
<p>这时通常会有另一个线程，假设是线程2，线程2去执行对应的条件，直到这个条件达成的时候，线程2就会去执行<code>condition.signal()</code>方法，这时JVM就会从被阻塞的线程里寻找等待该<code>condition</code>的线程，当线程1收到可执行的信号的时候，线程1的线程状态就会变成Runnable状态</p>
<img src="/2020/03/06/4悟空Java并发编程/控制并发流程/image-20200225151524469.png" alt="image-20200225151524469" style="zoom:80%;">

<h3 id="signalAll-和signal-区别"><a href="#signalAll-和signal-区别" class="headerlink" title="signalAll()和signal()区别"></a>signalAll()和signal()区别</h3><p>signalAll()会唤醒所有的正在等待的线程</p>
<p>signal()是公平的，只会唤醒等待时间最长的线程</p>
<h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><p><strong>普通用法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     演示Condition的基本用法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionDemo1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//利用锁来新建Condition</span></span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"条件不满足，开始await"</span>);</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(<span class="string">"条件满足了，开始执行后续的任务"</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"准备工作完成，唤醒其他的线程"</span>);</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ConditionDemo1 conditionDemo1 = <span class="keyword">new</span> ConditionDemo1();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    conditionDemo1.method2();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        conditionDemo1.method1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">条件不满足，开始await</span><br><span class="line">准备工作完成，唤醒其他的线程</span><br><span class="line">条件满足了，开始执行后续的任务</span><br></pre></td></tr></table></figure>

<p><strong>用Condition实现生产者消费者模式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     演示用Condition实现生产者消费者模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionDemo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueSize = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(queueSize);</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition notFull = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConditionDemo2 conditionDemo2 = <span class="keyword">new</span> ConditionDemo2();</span><br><span class="line">        Producer producer = conditionDemo2.new Producer();</span><br><span class="line">        Consumer consumer = conditionDemo2.new Consumer();</span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            consume();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"队列空，等待数据"</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            notEmpty.await();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                    notFull.signalAll();</span><br><span class="line">                    System.out.println(<span class="string">"从队列里取走了一个数据，队列剩余"</span> + queue.size() + <span class="string">"个元素"</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            produce();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.size() == queueSize) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"队列满，等待有空余"</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            notFull.await();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.offer(<span class="number">1</span>);</span><br><span class="line">                    notEmpty.signalAll();</span><br><span class="line">                    System.out.println(<span class="string">"向队列插入了一个元素，队列剩余空间"</span> + (queueSize - queue.size()));</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">向队列插入了一个元素，队列剩余空间9</span><br><span class="line">向队列插入了一个元素，队列剩余空间8</span><br><span class="line">向队列插入了一个元素，队列剩余空间7</span><br><span class="line">向队列插入了一个元素，队列剩余空间6</span><br><span class="line">向队列插入了一个元素，队列剩余空间5</span><br><span class="line">向队列插入了一个元素，队列剩余空间4</span><br><span class="line">向队列插入了一个元素，队列剩余空间3</span><br><span class="line">向队列插入了一个元素，队列剩余空间2</span><br><span class="line">向队列插入了一个元素，队列剩余空间1</span><br><span class="line">向队列插入了一个元素，队列剩余空间0</span><br><span class="line">队列满，等待有空余</span><br><span class="line">从队列里取走了一个数据，队列剩余9个元素</span><br><span class="line">从队列里取走了一个数据，队列剩余8个元素</span><br><span class="line">从队列里取走了一个数据，队列剩余7个元素</span><br><span class="line">从队列里取走了一个数据，队列剩余6个元素</span><br><span class="line">从队列里取走了一个数据，队列剩余5个元素</span><br><span class="line">从队列里取走了一个数据，队列剩余4个元素</span><br><span class="line">从队列里取走了一个数据，队列剩余3个元素</span><br><span class="line">从队列里取走了一个数据，队列剩余2个元素</span><br><span class="line">从队列里取走了一个数据，队列剩余1个元素</span><br><span class="line">从队列里取走了一个数据，队列剩余0个元素</span><br><span class="line">队列空，等待数据</span><br><span class="line">向队列插入了一个元素，队列剩余空间9</span><br><span class="line">向队列插入了一个元素，队列剩余空间8</span><br><span class="line">向队列插入了一个元素，队列剩余空间7</span><br><span class="line">向队列插入了一个元素，队列剩余空间6</span><br><span class="line">向队列插入了一个元素，队列剩余空间5</span><br><span class="line">向队列插入了一个元素，队列剩余空间4</span><br><span class="line">向队列插入了一个元素，队列剩余空间3</span><br><span class="line">向队列插入了一个元素，队列剩余空间2</span><br><span class="line">向队列插入了一个元素，队列剩余空间1</span><br><span class="line">向队列插入了一个元素，队列剩余空间0</span><br><span class="line">队列满，等待有空余</span><br><span class="line">从队列里取走了一个数据，队列剩余9个元素</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h3><p>实际上，如果说Lock用来代替synchronized，那么Condition就是用来代替相应的<code>Object.wait/notify</code>的，所以在用法和性质上，几乎都是一样的</p>
<p>await()方法会自动释放持有的Lock锁，和<code>Object.wait()</code>一样，不需要自己动手先释放锁</p>
<p>调用await()的时候，必须持有锁，否则会抛出异常，和<code>Object.wait()</code>一样</p>
<h2 id="CyclicBarrier循环栅栏"><a href="#CyclicBarrier循环栅栏" class="headerlink" title="CyclicBarrier循环栅栏"></a>CyclicBarrier循环栅栏</h2><p>CyclicBarrier循环栅栏和CountDownLatch很类似，都能阻塞一组线程</p>
<p>当有大量线程相互配合的时候，分别计算不同任务，并且需要最后统一汇总的时候，可以使用CycliBarrier</p>
<p>CycliBarrier可以构造一个集结点，当某一个线程执行完毕，它就会到集结点等待，直到所有线程都到了集结点，那么该栅栏就被撤销，所有线程再统一出发，继续执行剩下的任务</p>
<h3 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：    演示CyclicBarrier</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"所有人都到场了， 大家统一出发！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(i, cyclicBarrier)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(<span class="keyword">int</span> id, CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"线程"</span> + id + <span class="string">"现在前往集合地点"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="keyword">long</span>) (Math.random()*<span class="number">10000</span>));</span><br><span class="line">                System.out.println(<span class="string">"线程"</span>+id+<span class="string">"到了集合地点，开始等待其他人到达"</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                System.out.println(<span class="string">"线程"</span>+id+<span class="string">"出发了"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">线程1现在前往集合地点</span><br><span class="line">线程0现在前往集合地点</span><br><span class="line">线程2现在前往集合地点</span><br><span class="line">线程3现在前往集合地点</span><br><span class="line">线程4现在前往集合地点</span><br><span class="line">线程6现在前往集合地点</span><br><span class="line">线程5现在前往集合地点</span><br><span class="line">线程7现在前往集合地点</span><br><span class="line">线程8现在前往集合地点</span><br><span class="line">线程9现在前往集合地点</span><br><span class="line">线程5到了集合地点，开始等待其他人到达</span><br><span class="line">线程0到了集合地点，开始等待其他人到达</span><br><span class="line">线程9到了集合地点，开始等待其他人到达</span><br><span class="line">线程1到了集合地点，开始等待其他人到达</span><br><span class="line">线程7到了集合地点，开始等待其他人到达</span><br><span class="line">所有人都到场了， 大家统一出发！</span><br><span class="line">线程7出发了</span><br><span class="line">线程5出发了</span><br><span class="line">线程9出发了</span><br><span class="line">线程0出发了</span><br><span class="line">线程1出发了</span><br><span class="line">线程4到了集合地点，开始等待其他人到达</span><br><span class="line">线程2到了集合地点，开始等待其他人到达</span><br><span class="line">线程6到了集合地点，开始等待其他人到达</span><br><span class="line">线程3到了集合地点，开始等待其他人到达</span><br><span class="line">线程8到了集合地点，开始等待其他人到达</span><br><span class="line">所有人都到场了， 大家统一出发！</span><br><span class="line">线程8出发了</span><br><span class="line">线程3出发了</span><br><span class="line">线程6出发了</span><br><span class="line">线程2出发了</span><br><span class="line">线程4出发了</span><br></pre></td></tr></table></figure>

<h3 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h3><h4 id="作用不同"><a href="#作用不同" class="headerlink" title="作用不同"></a>作用不同</h4><p>CyclicBarrier要等固定数量的线程都达到类栅栏的位置才能继续执行，额CountDownLatch只需要等待数字为0，也就是说，CountDownLatch用于事件，但是CyclicBarrier用于线程</p>
<h4 id="可重用性不同"><a href="#可重用性不同" class="headerlink" title="可重用性不同"></a>可重用性不同</h4><p>CountDownLatch在倒数到0并触发门闩打开后，就不能再次使用了，除非新建新的实例，而CyclicBarrier可以重复使用</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-4悟空Java并发编程/并发编程的基石" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/06/4悟空Java并发编程/并发编程的基石/" class="article-date">
      <time datetime="2020-03-06T09:41:28.638Z" itemprop="datePublished">2020-03-06</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/06/4悟空Java并发编程/并发编程的基石/">多线程一之并发编程的基石</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <h1 id="并发编程的基石之多线程概念建立"><a href="#并发编程的基石之多线程概念建立" class="headerlink" title="并发编程的基石之多线程概念建立"></a>并发编程的基石之多线程概念建立</h1><p><img src="/2020/03/06/4悟空Java并发编程/并发编程的基石/image-20200131110622023.png" alt="image-20200131110622023"></p>
<h2 id="什么是线程、进程"><a href="#什么是线程、进程" class="headerlink" title="什么是线程、进程"></a>什么是线程、进程</h2><h3 id="操作系统、进程、线程的包含关系"><a href="#操作系统、进程、线程的包含关系" class="headerlink" title="操作系统、进程、线程的包含关系"></a>操作系统、进程、线程的包含关系</h3><p>操作系统是包含多个进程的容器，而每个进程又都是容纳多个线程的容器</p>
<p>单核CPU可以执行多个进程，是因为操作系统的调度</p>
<p>cpu里的一个核，在某一个时间点只能处理一个进程中的一个线程，正是因为这样，所以单核处理器无法并行执行，而多核处理器可以并行</p>
<p>并行并发串行针对进程里的线程之间的运行状态来说的，而同步异步阻塞非阻塞是针对执行线程的被调用者和调用者来说的，两者没有联系</p>
<p><img src="/2020/03/06/4悟空Java并发编程/并发编程的基石/image-20200124010930922.png" alt></p>
<h3 id="Oracle文档的官方定义"><a href="#Oracle文档的官方定义" class="headerlink" title="Oracle文档的官方定义"></a>Oracle文档的官方定义</h3><p>进程：使用fork(2)系统调用创建的UNIX环境（例如文件描述符、用户ID等），它被设置为运行程序</p>
<p>线程：在进程上下文中执行的一系列指令</p>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java多线程/">Java多线程</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/2020/03/06/4悟空Java并发编程/并发编程的基石/#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-4悟空Java并发编程/并发工具类纵览" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/06/4悟空Java并发编程/并发工具类纵览/" class="article-date">
      <time datetime="2020-03-06T09:41:28.633Z" itemprop="datePublished">2020-03-06</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/06/4悟空Java并发编程/并发工具类纵览/">并发工具类</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <h1 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h1><h2 id="并发工具类的分类"><a href="#并发工具类的分类" class="headerlink" title="并发工具类的分类"></a>并发工具类的分类</h2><h4 id="1-为了并发安全的工具类"><a href="#1-为了并发安全的工具类" class="headerlink" title="1. 为了并发安全的工具类"></a>1. 为了并发安全的工具类</h4><p>而为了并发安全 的工具类可以分为3个小部分</p>
<p><strong>1）互斥同步</strong></p>
<p>最简单的理解就是锁，一个线程获取资源的时候，另一个线程不能获取资源，线程之间相互敌对的  </p>
<p><strong>2）非互斥同步</strong></p>
<p>可以两个线程同时获取资源，不要求资源独占，最典型的就是原子类</p>
<p><strong>3）无同步方案</strong></p>
<p>包含ThreadLocal、final关键字</p>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java多线程/">Java多线程</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/2020/03/06/4悟空Java并发编程/并发工具类纵览/#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-4悟空Java并发编程/并发容器精讲" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/06/4悟空Java并发编程/并发容器精讲/" class="article-date">
      <time datetime="2020-03-06T09:41:28.623Z" itemprop="datePublished">2020-03-06</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="并发容器精讲"><a href="#并发容器精讲" class="headerlink" title="并发容器精讲"></a>并发容器精讲</h1><p>面试杀手锏</p>
<p>ConcurrentHashMap、CopyOnWriteArrayList、阻塞队列</p>
<h2 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h2><h3 id="并发容器概览"><a href="#并发容器概览" class="headerlink" title="并发容器概览"></a>并发容器概览</h3><p>ConcurrentHashMap：线程安全的HashMap</p>
<p>CopyOnWriteArrayList：线程安全的List</p>
<p>BlockingQueue：这是一个接口，表示阻塞队列，非常适合用于作为数据共享的通道</p>
<p>ConcurrentLinkedQueue：高效的非阻塞并发队列，使用链表实现。可以看做一个线程安全的LinkedList</p>
<p>ConcurrentSkipListMap：是一个Map，使用跳表的数据结构进行快速查询</p>
<h2 id="古老和过时的同步容器"><a href="#古老和过时的同步容器" class="headerlink" title="古老和过时的同步容器"></a>古老和过时的同步容器</h2><h3 id="Vector和Hashtable"><a href="#Vector和Hashtable" class="headerlink" title="Vector和Hashtable"></a>Vector和Hashtable</h3><p><strong>Vector</strong></p>
<p>是jdk早期的一部分，目标也是提供一个线程安全的集合类，但是随着jdk的发展已经不能满足需求了，性能不够好</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Vector&lt;String&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">        vector.add(<span class="string">"test"</span>);</span><br><span class="line">        System.out.println(vector.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test</span><br></pre></td></tr></table></figure>

<p>Vector中的很多方法都是由synchronized修饰的，在多线程下线程性能不够好</p>
<p><strong>Hashtable</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashtableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hashtable&lt;String, String&gt; hashtable = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line">        hashtable.put(<span class="string">"学完以后跳槽涨薪幅度"</span>, <span class="string">"80%"</span>);</span><br><span class="line">        System.out.println(hashtable.get(<span class="string">"学完以后跳槽涨薪幅度"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">80%</span><br></pre></td></tr></table></figure>

<p>同样，Hashtable中的很多方法都是由synchronized修饰的，在多线程下线程性能不够好</p>
<h3 id="HashMap和ArrayList"><a href="#HashMap和ArrayList" class="headerlink" title="HashMap和ArrayList"></a>HashMap和ArrayList</h3><p>虽然这两个类不是线程安全的，但是可以用<code>Collections.synchronizedList(new ArrayList\&lt;E&gt;())</code>和<code>Collections.synchronizedMap(new HashMap&lt;K,V&gt;)</code>使之变成线程安全的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：演示Collections.synchronizedList(new ArrayList&lt;E&gt;())</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        list.add(<span class="number">5</span>);</span><br><span class="line">        System.out.println(list.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        Map&lt;Object, Object&gt; objectObjectMap = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样使用synchronized来修饰，与上面的方法差不多</p>
<h3 id="ConcurrentHashMap和CopyOnWriteArrayList"><a href="#ConcurrentHashMap和CopyOnWriteArrayList" class="headerlink" title="ConcurrentHashMap和CopyOnWriteArrayList"></a>ConcurrentHashMap和CopyOnWriteArrayList</h3><p>取代同步的HashMap和同步的ArrayList</p>
<p>绝大多数并发情况下，ConcurrentHashMap和CopyOnWriteArrayList的性能都更好</p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>重点、面试常考</p>
<h3 id="Map简介"><a href="#Map简介" class="headerlink" title="Map简介"></a>Map简介</h3><p>HashMap、Hashtabe、LinkedHashMap、TreeMap</p>
<img src="/2020/03/06/4悟空Java并发编程/并发容器精讲/1.png" style="zoom: 67%;">

<img src="/2020/03/06/4悟空Java并发编程/并发容器精讲/2.png" style="zoom:50%;">

<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>HashMap会根据键的HashCode来存储，由于可以直接算出HashCode的值，所以可以直接定位到需要找到的位置，它的访问速度是非常快的，允许键（key）为null来写入的，值也可以是null，但是是线程不安全的</p>
<h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><p>是历史遗留类，很多功能与HashMap是一致的，但是线程安全的，任何时刻只有一个线程能对它进行操作，不建议使用</p>
<h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p>HashMap的一个子类，保存了记录的插入顺序，在遍历的时候有用，遍历的顺序与插入的顺序一致</p>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>由于实现了SortedMap接口，所以可以根据键来排序，默认是升序，也可以自定义排序条件</p>
<p>以上一种实现都要求key是不可变对象，即key在创建后它的hash值不会改变</p>
<h3 id="Map的基本用法"><a href="#Map的基本用法" class="headerlink" title="Map的基本用法"></a>Map的基本用法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     演示Map的基本用法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        System.out.println(map.isEmpty());</span><br><span class="line">        map.put(<span class="string">"东哥"</span>, <span class="number">38</span>);</span><br><span class="line">        map.put(<span class="string">"西哥"</span>, <span class="number">28</span>);</span><br><span class="line">        System.out.println(map.keySet());</span><br><span class="line">        System.out.println(map.get(<span class="string">"西哥"</span>));</span><br><span class="line">        System.out.println(map.size());</span><br><span class="line">        System.out.println(map.containsKey(<span class="string">"东哥"</span>));</span><br><span class="line">        map.remove(<span class="string">"东哥"</span>);</span><br><span class="line">        System.out.println(map.containsKey(<span class="string">"东哥"</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line">[东哥, 西哥]</span><br><span class="line"><span class="number">28</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<h3 id="为什么需要ConcurrentHashMap"><a href="#为什么需要ConcurrentHashMap" class="headerlink" title="为什么需要ConcurrentHashMap"></a>为什么需要ConcurrentHashMap</h3><h4 id="为什么不用Collections-synchronizedMap"><a href="#为什么不用Collections-synchronizedMap" class="headerlink" title="为什么不用Collections.synchronizedMap()"></a>为什么不用Collections.synchronizedMap()</h4><p>它是通过锁来保证线程的安全访问的，但是由于synchronized对于并发量高的时候并不理想，所以不采用这样的方法</p>
<h4 id="为什么HashMap是线程不安全的"><a href="#为什么HashMap是线程不安全的" class="headerlink" title="为什么HashMap是线程不安全的"></a>为什么HashMap是线程不安全的</h4><p>注意：HashMap本来就不是用于并发的</p>
<p><strong>同时put碰撞导致数据丢失</strong></p>
<p>如果多个线程同时put，如果计算出来的hash值是一样的话，那么这几个key会放到同一个位置，但是多个线程放在同一个位置，只能保留一个线程的数据，其他线程的数据都会丢失的，所以会丢失一部分数据</p>
<p><strong>同时put扩容导致数据丢失</strong></p>
<p>如果多个线程同时put，并且发现需要同时扩容，那么扩容之后的数组，也只有一个会保留下来，所以也会造成某些数据的丢失</p>
<p><strong>死循环造成CPU100%</strong></p>
<p>HashMap在高并发下的死循环（仅在JDK7及以前存在）</p>
<p>原因：在多个线程同时扩容的时候会造成链表的死循环，这样一来就没有尽头了</p>
<h3 id="HashMap的分析"><a href="#HashMap的分析" class="headerlink" title="HashMap的分析"></a>HashMap的分析</h3><p><img src="/2020/03/06/4悟空Java并发编程/并发容器精讲/image-20200223222538740.png" alt="image-20200223222538740"></p>
<p><img src="/2020/03/06/4悟空Java并发编程/并发容器精讲/image-20200223222640457.png" alt="image-20200223222640457"></p>
<p>红黑树</p>
<p>对二叉查找树BST的一种平衡策略，会自动平衡，防止极端不平衡从而影响查找效率的情况发生</p>
<p>特点</p>
<p>每个节点要么是红色的，要么是黑色的，但根节点永远是黑色的</p>
<p>红色节点不能连续，即红色节点的孩子和父亲都不能是红色</p>
<p>从任意节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点</p>
<p>所有的叶结点都是黑色的</p>
<p>HashMap关于并发的特点</p>
<ol>
<li>非线程安全</li>
<li>迭代时不允许改变内容</li>
<li>只读的并发是安全的</li>
<li>如果一定要把HashMap用在并发环境，用Collections.synchronizedMap(new HashMap())</li>
</ol>
<h3 id="JDK1-7的ConcurrentHashMap实现和分析"><a href="#JDK1-7的ConcurrentHashMap实现和分析" class="headerlink" title="JDK1.7的ConcurrentHashMap实现和分析"></a>JDK1.7的ConcurrentHashMap实现和分析</h3><img src="/2020/03/06/4悟空Java并发编程/并发容器精讲/image-20200223230321759.png" alt="image-20200223230321759" style="zoom: 67%;">

<ol>
<li><p>Java7中的ConcurrentHashMap最外层是多个segment，每个segment的底层数据结构与HashMap类似，仍然是数组和链表组成的拉链法</p>
</li>
<li><p>每个segment设置了独立的ReentrantLock锁，每个segment之间互不影响，提高了并发效率</p>
</li>
<li><p>ConcurrentHashMap默认有16个Segments，所以最多可以同时支持16个线程并发的写（操作分别分布在不同的Segment），这个默认值可以在初始化的时候设置为其他值，但是一旦初始化以后，是不可以扩容的</p>
</li>
</ol>
<h3 id="JDK1-8的ConcurrentHashMap实现和分析"><a href="#JDK1-8的ConcurrentHashMap实现和分析" class="headerlink" title="JDK1.8的ConcurrentHashMap实现和分析"></a>JDK1.8的ConcurrentHashMap实现和分析</h3><p> <img src="/2020/03/06/4悟空Java并发编程/并发容器精讲/image-20200224095604376.png" alt="image-20200224095604376"></p>
<p>putVal()流程</p>
<ol>
<li>判断key、value不为空</li>
<li>计算hash值</li>
<li>根据对应位置节点的类型来赋值，或者helpTransfer，或者增长链表，或者给红黑树增加节点</li>
<li>检查满足阈值就红黑树化</li>
<li>返回oldVal</li>
</ol>
<p>get()流程</p>
<ol>
<li>计算hash值</li>
<li>找到对应的位置，根据情况进行：直接取值、或红黑树里找值、或遍历链表取值</li>
<li>返回找到的结果 </li>
</ol>
<h3 id="为什么要把1-7结构改成1-8的结构"><a href="#为什么要把1-7结构改成1-8的结构" class="headerlink" title="为什么要把1.7结构改成1.8的结构"></a>为什么要把1.7结构改成1.8的结构</h3><p>数据结构</p>
<p>Hash碰撞</p>
<p>保证并发安全</p>
<p>为什么超过8要转为红黑树</p>
<p>默认不是红黑树节点，默认是链表的形式，这是因为它所占用的内存更少</p>
<p>想要达到冲突为8是很难的，如果达到8就会转为红黑树，依然能提高效率</p>
<h3 id="组合操作"><a href="#组合操作" class="headerlink" title="组合操作"></a>组合操作</h3><p>ConcurrentHashMap为什么也不是线程安全的</p>
<p>replace操作</p>
<p>putIfAbsent</p>
<p>if(!map.containsKey(key)){</p>
<p>​    return map.put(key,value);</p>
<p>}else{</p>
<p>​    return map.get(key);</p>
<p>}</p>
<h3 id="实际生产案例"><a href="#实际生产案例" class="headerlink" title="实际生产案例"></a>实际生产案例</h3><p>线程安全问题需要时刻注意</p>
<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><h3 id="诞生的历史和原因"><a href="#诞生的历史和原因" class="headerlink" title="诞生的历史和原因"></a>诞生的历史和原因</h3><p>在JDK5引入，是List中最主要的并发工具，用来代替Vector和SynchronizedList，就和ConcurrentHashMap代替SynchronizedMap的原因是一样的</p>
<p>Vector和SynchronizedList的锁的粒度太大，并发效率相对比较低，并且迭代时无法编辑</p>
<p>CopyOnWrite并发容器还包括CopyOnWriteArraySet，用来替代同步Set</p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>读操作尽可能快，而写即使慢也没有太大关系</p>
<p>读多写少：黑名单、每日更新、监听器，这些的迭代操作远多于修改操作</p>
<h3 id="读写原则"><a href="#读写原则" class="headerlink" title="读写原则"></a>读写原则</h3><p>回顾读写锁，读读共享，其他都互斥（写写互斥，读写互斥，写读互斥）</p>
<p>读写锁规则的升级：读取是完全不用加锁的，并且更厉害的是写入也不会阻塞读取操作，只用写入和写入之间要进行同步等待</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：演示CopyOnWriteArrayList可以在迭代的过程中修改数组内容，但是ArrayList不行，对比</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayListDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//CopyOnWriteArrayList&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line">        list.add(<span class="string">"1"</span>);</span><br><span class="line">        list.add(<span class="string">"2"</span>);</span><br><span class="line">        list.add(<span class="string">"3"</span>);</span><br><span class="line">        list.add(<span class="string">"4"</span>);</span><br><span class="line">        list.add(<span class="string">"5"</span>);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"list is"</span> + list);</span><br><span class="line">            String next = iterator.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (next.equals(<span class="string">"2"</span>)) &#123;</span><br><span class="line">                list.remove(<span class="string">"5"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (next.equals(<span class="string">"3"</span>)) &#123;</span><br><span class="line">                list.add(<span class="string">"3 found"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">list is[1, 2, 3, 4, 5]</span><br><span class="line">1</span><br><span class="line">list is[1, 2, 3, 4, 5]</span><br><span class="line">2</span><br><span class="line">list is[1, 2, 3, 4]</span><br><span class="line">Exception in thread &quot;main&quot; java.util.ConcurrentModificationException</span><br><span class="line">	at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909)</span><br><span class="line">	at java.util.ArrayList$Itr.next(ArrayList.java:859)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：演示CopyOnWriteArrayList可以在迭代的过程中修改数组内容，但是ArrayList不行，对比</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayListDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line">        CopyOnWriteArrayList&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="string">"1"</span>);</span><br><span class="line">        list.add(<span class="string">"2"</span>);</span><br><span class="line">        list.add(<span class="string">"3"</span>);</span><br><span class="line">        list.add(<span class="string">"4"</span>);</span><br><span class="line">        list.add(<span class="string">"5"</span>);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"list is"</span> + list);</span><br><span class="line">            String next = iterator.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (next.equals(<span class="string">"2"</span>)) &#123;</span><br><span class="line">                list.remove(<span class="string">"5"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (next.equals(<span class="string">"3"</span>)) &#123;</span><br><span class="line">                list.add(<span class="string">"3 found"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">list is[1, 2, 3, 4, 5]</span><br><span class="line">1</span><br><span class="line">list is[1, 2, 3, 4, 5]</span><br><span class="line">2</span><br><span class="line">list is[1, 2, 3, 4]</span><br><span class="line">3</span><br><span class="line">list is[1, 2, 3, 4, 3 found]</span><br><span class="line">4</span><br><span class="line">list is[1, 2, 3, 4, 3 found]</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="CopyOnWrite的含义"><a href="#CopyOnWrite的含义" class="headerlink" title="CopyOnWrite的含义"></a>CopyOnWrite的含义</h4><p>创建新副本，读写分离</p>
<p>不可变原理</p>
<p>迭代时候</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>数据一致性问题</p>
<p>CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性，所以如果希望写入的数据马上能读到，就不要使用CopyOnWrite容器</p>
<p>内存占用问题</p>
<p>因为CopyOnWrite的写是复制机制，所以在进行写操作的时候，内存里会同时保存两个对象的内存</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>数据结构</p>
<p>get</p>
<p>add</p>
<h2 id="并发队列Queue"><a href="#并发队列Queue" class="headerlink" title="并发队列Queue"></a>并发队列Queue</h2><p>阻塞队列、非阻塞队列</p>
<h3 id="为什么要使用队列"><a href="#为什么要使用队列" class="headerlink" title="为什么要使用队列"></a>为什么要使用队列</h3><p>用队列可以在线程间传递数据：生产者消费者模式、银行转账</p>
<p>考虑锁等线程安全问题的重任从用户转移到了队列上</p>
<h3 id="并发队列简介"><a href="#并发队列简介" class="headerlink" title="并发队列简介"></a>并发队列简介</h3><p>Queue与BlockingQueue是JDK5中新增的，Queue只用来保存一组等待处理的数据，它会有很多种实现，底层是LinkedList，Queue只能从头或者尾来获取数据，不能从中间获取数据</p>
<p>BlockingQueue增加了可阻塞的插入和获取操作，若队列为空，取的操作会一直阻塞，直到里面有了数据，如果队列满了，插入也插入不进去，也会一直阻塞，直到有用户把其中的数据取出来，这体现了生产者消费者模式</p>
<h3 id="各并发队列关系图"><a href="#各并发队列关系图" class="headerlink" title="各并发队列关系图"></a>各并发队列关系图</h3><p><img src="/2020/03/06/4悟空Java并发编程/并发容器精讲/image-20200224174734549.png" alt="image-20200224174734549"></p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>BlockingQueue</p>
<h4 id="什么是阻塞队列"><a href="#什么是阻塞队列" class="headerlink" title="什么是阻塞队列"></a>什么是阻塞队列</h4><p>阻塞队列是具有阻塞功能的队列，所以它首先是一个队列，其次是具有阻塞功能</p>
<p>通常，阻塞队列的一端是给生产者放数据用，另一端给消费者拿数据用，阻塞队列是线程安全的，所以生产者和消费者都可以是多线程的</p>
<img src="/2020/03/06/4悟空Java并发编程/并发容器精讲/image-20200224185451780.png" alt="image-20200224185451780" style="zoom:50%;">

<p>阻塞功能：最有特色的两个带有阻塞功能的方法是take()方法和put()方法</p>
<p>take()方法：获取并移除队列的头结点，一旦在执行take的时候，队列里无数据，则阻塞，直到队列里有数据</p>
<img src="/2020/03/06/4悟空Java并发编程/并发容器精讲/image-20200224191055479.png" alt="image-20200224191055479" style="zoom:50%;">

<p>put()方法：插入元素，但是如果队列已满，那么就无法继续插入，并且阻塞，直到队列里有了空闲空间</p>
<img src="/2020/03/06/4悟空Java并发编程/并发容器精讲/image-20200224192035440.png" alt="image-20200224192035440" style="zoom:50%;">

<p>是否有界(容量有多大)</p>
<p>这是一个非常重要的属性，无界队列意味着里面可以容纳非常多的数据，Integer.MAX_VALUE，约为2的31次方，可以近似认为是无限容量</p>
<p>线程池与阻塞队列的关系：阻塞队列是线程池的重要组成部分</p>
<h4 id="BlockingQueue的主要方法"><a href="#BlockingQueue的主要方法" class="headerlink" title="BlockingQueue的主要方法"></a>BlockingQueue的主要方法</h4><p>put、take（会阻塞住）</p>
<p>add、remove、element（会抛出异常）</p>
<p>offer（添加元素）、poll（取出元素）、peek</p>
<h4 id="主要方法介绍"><a href="#主要方法介绍" class="headerlink" title="主要方法介绍"></a>主要方法介绍</h4><h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><p>有界</p>
<p>指定容量</p>
<p>公平：可以指定是否需要保证公平，如果要保证公平的话，那么等待了最长时间的线程就会被优先处理，不过这同时会带来一定的性能损耗</p>
<p>使用案例</p>
<p>有10个面试者，但只有1个面试官，大厅里有三个位置休息，每个人面试时间是10秒，模拟所有人面试的场景</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     TODO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayBlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        Interviewer r1 = <span class="keyword">new</span> Interviewer(queue);</span><br><span class="line">        Consumer r2 = <span class="keyword">new</span> Consumer(queue);</span><br><span class="line">        <span class="keyword">new</span> Thread(r1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interviewer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BlockingQueue&lt;String&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Interviewer</span><span class="params">(BlockingQueue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"10个候选人都来啦"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            String candidate = <span class="string">"Candidate"</span> + i;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(candidate);</span><br><span class="line">                System.out.println(<span class="string">"安排好了"</span> + candidate);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.put(<span class="string">"stop"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BlockingQueue&lt;String&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue queue)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        String msg;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(!(msg = queue.take()).equals(<span class="string">"stop"</span>))&#123;</span><br><span class="line">                System.out.println(msg + <span class="string">"到了"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"所有候选人都结束了"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">10个候选人都来啦</span><br><span class="line">安排好了Candidate0</span><br><span class="line">安排好了Candidate1</span><br><span class="line">安排好了Candidate2</span><br><span class="line">安排好了Candidate3</span><br><span class="line">Candidate0到了</span><br><span class="line">Candidate1到了</span><br><span class="line">安排好了Candidate4</span><br><span class="line">Candidate2到了</span><br><span class="line">安排好了Candidate5</span><br><span class="line">Candidate3到了</span><br><span class="line">安排好了Candidate6</span><br><span class="line">Candidate4到了</span><br><span class="line">安排好了Candidate7</span><br><span class="line">Candidate5到了</span><br><span class="line">安排好了Candidate8</span><br><span class="line">Candidate6到了</span><br><span class="line">安排好了Candidate9</span><br><span class="line">Candidate7到了</span><br><span class="line">Candidate8到了</span><br><span class="line">Candidate9到了</span><br><span class="line">所有候选人都结束了</span><br></pre></td></tr></table></figure>

<p>源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p>无界，容量能达到Integer.MAX_VALUE</p>
<p>内部结构：Node、两把锁</p>
<p>put()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// Note: convention in all put/take/etc is to preset local var</span></span><br><span class="line">    <span class="comment">// holding count negative to indicate failure unless set.</span></span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Note that count is used in wait guard even though it is</span></span><br><span class="line"><span class="comment">         * not protected by lock. This works because count can</span></span><br><span class="line"><span class="comment">         * only decrease at this point (all other puts are shut</span></span><br><span class="line"><span class="comment">         * out by lock), and we (or some other waiting put) are</span></span><br><span class="line"><span class="comment">         * signalled if it ever changes from capacity. Similarly</span></span><br><span class="line"><span class="comment">         * for all other uses of count in other wait guards.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(node);</span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h4><p>支持优先级</p>
<p>自然排序，而不是先进先出</p>
<p>无界队列</p>
<p>是PriorityQueue的线程安全版本</p>
<h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><p>容量为0，值得注意的是，SynchronousQueue的容量不是1而是0，因为SynchronousQueue不需要持有元素，它所做的就是直接传递（direct handoff），因此效率很高</p>
<img src="/2020/03/06/4悟空Java并发编程/并发容器精讲/image-20200225082849924.png" alt="image-20200225082849924" style="zoom:50%;">

<p>SynchronousQueue没有peek函数，因为peek的含义是取出头结点，但是SynchronousQueue的容量为0，所以连头结点都没有，也就没有peek方法，同理，没有iterate相关方法</p>
<p>因此它是一个极好的用来直接传递的并发数据结构</p>
<p>SynchronousQueue是线程池Executors.newCachedThreadPool()使用的阻塞队列</p>
<h3 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h3><p>ConcurrentLinkedQueue</p>
<p>并发包中的非阻塞队列只有ConcurrentLinkedQueue这一种，ConcurrentLinkedQueue是使用链表作为其数据结构的，使用CAS非阻塞算法来实现线程安全（不具备阻塞功能），适合用在对性能要求较高的并发场景，用的相对比较少</p>
<p>源码中的offer体现了CAS的思想，内有p.casNext方法，用了Unsafe.compareAndSwapObject</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// p is last node</span></span><br><span class="line">            <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, newNode)) &#123;</span><br><span class="line">                <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                <span class="comment">// for e to become an element of this queue,</span></span><br><span class="line">                <span class="comment">// and for newNode to become "live".</span></span><br><span class="line">                <span class="keyword">if</span> (p != t) <span class="comment">// hop two nodes at a time</span></span><br><span class="line">                    casTail(t, newNode);  <span class="comment">// Failure is OK.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Lost CAS race to another thread; re-read next</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">            <span class="comment">// We have fallen off list.  If tail is unchanged, it</span></span><br><span class="line">            <span class="comment">// will also be off-list, in which case we need to</span></span><br><span class="line">            <span class="comment">// jump to head, from which all live nodes are always</span></span><br><span class="line">            <span class="comment">// reachable.  Else the new tail is a better bet.</span></span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// Check for tail updates after two hops.</span></span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何选择适合自己的队列"><a href="#如何选择适合自己的队列" class="headerlink" title="如何选择适合自己的队列"></a>如何选择适合自己的队列</h3><p>边界</p>
<p>空间</p>
<p>吞吐量</p>
<h2 id="各并发容器总结"><a href="#各并发容器总结" class="headerlink" title="各并发容器总结"></a>各并发容器总结</h2><p>Java.util.concurrent包提供的容器分为3类，Concurrent*、CopyOnWrite*、Blocking*</p>
<p>Concurrent*的特点是大部分通过CAS实现并发的</p>
<p>CopyOnWrite*则是通过复制一份原数据来实现的</p>
<p>Blocking*通过AQS实现的</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-4悟空Java并发编程/实战项目" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/06/4悟空Java并发编程/实战项目/" class="article-date">
      <time datetime="2020-03-06T09:41:28.618Z" itemprop="datePublished">2020-03-06</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h1><p>高性能缓存</p>
<p>从0开始迭代，一步步设计并实现</p>
<p>缓存是在实际生产中非常常用的工具，使用缓存可以避免重复计算，提高吞吐量</p>
<p>最初级的缓存可以用一个Map来实现，但一个功能完备，性能强劲的缓存，需要考虑的点就非常多了，从最简单的HashMap入手，一点点提高项目缓存的性能</p>
<h2 id="最简单缓存"><a href="#最简单缓存" class="headerlink" title="最简单缓存"></a>最简单缓存</h2><p>HashMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：最简单的缓存形式：HashMap</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImoocCache1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String,Integer&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">computer</span><span class="params">(String userId)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Integer result = cache.get(userId);</span><br><span class="line">        <span class="comment">//先检查HashMap里面有没有保存过之前的计算结果</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果缓存中找不到，那么需要现在计算一下结果，并且保存到HashMap中</span></span><br><span class="line">            result = doCompute(userId);</span><br><span class="line">            cache.put(userId, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Integer <span class="title">doCompute</span><span class="params">(String userId)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ImoocCache1 imoocCache1 = <span class="keyword">new</span> ImoocCache1();</span><br><span class="line">        System.out.println(<span class="string">"开始计算了"</span>);</span><br><span class="line">        Integer result = imoocCache1.computer(<span class="string">"13"</span>);</span><br><span class="line">        System.out.println(<span class="string">"第一次计算结果："</span>+result);</span><br><span class="line">        result = imoocCache1.computer(<span class="string">"13"</span>);</span><br><span class="line">        System.out.println(<span class="string">"第二次计算结果："</span>+result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的写法有一些问题</p>
<p>在多线程的情况下是并发不安全的</p>
<p>可以在此情况下进行升级</p>
<h2 id="使用synchronized实现"><a href="#使用synchronized实现" class="headerlink" title="使用synchronized实现"></a>使用synchronized实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：最简单的缓存形式：HashMap</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImoocCache1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String,Integer&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Integer <span class="title">computer</span><span class="params">(String userId)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Integer result = cache.get(userId);</span><br><span class="line">        <span class="comment">//先检查HashMap里面有没有保存过之前的计算结果</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果缓存中找不到，那么需要现在计算一下结果，并且保存到HashMap中</span></span><br><span class="line">            result = doCompute(userId);</span><br><span class="line">            cache.put(userId, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Integer <span class="title">doCompute</span><span class="params">(String userId)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ImoocCache1 imoocCache1 = <span class="keyword">new</span> ImoocCache1();</span><br><span class="line">        System.out.println(<span class="string">"开始计算了"</span>);</span><br><span class="line">        Integer result = imoocCache1.computer(<span class="string">"13"</span>);</span><br><span class="line">        System.out.println(<span class="string">"第一次计算结果："</span>+result);</span><br><span class="line">        result = imoocCache1.computer(<span class="string">"13"</span>);</span><br><span class="line">        System.out.println(<span class="string">"第二次计算结果："</span>+result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用synchronized有如下缺点</p>
<p>性能差</p>
<p>代码复用性差</p>
<h3 id="给HashMap加final关键字"><a href="#给HashMap加final关键字" class="headerlink" title="给HashMap加final关键字"></a>给HashMap加final关键字</h3><p>属性被声明为final后，该变量则只能被赋值一次，一旦被赋值了，fianl变量就不能被改变</p>
<h2 id="解决代码复用性"><a href="#解决代码复用性" class="headerlink" title="解决代码复用性"></a>解决代码复用性</h2><p>使用装饰者模式</p>
<p>假设ExpensiveFunction类是耗时计算的实现类，实现了Computable接口，但是其本身不具有缓存的功能，也不考虑缓存的事情</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：有一个计算函数computer，用来代表耗时计算，每个计算器都要实现这个接口，这样就可以无侵入实现缓存功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Computable</span> &lt;<span class="title">A</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：耗时计算的实现类，实现了Computable接口，但是本身不具备缓存能力，不需要考虑缓存的事情</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpensiveFunction</span> <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">compute</span><span class="params">(String arg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     用装饰者模式，给计算器自动添加缓存功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImoocCache2</span>&lt;<span class="title">A</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, V&gt; cache = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">final</span> Computable&lt;A,V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImoocCache2</span><span class="params">(Computable&lt;A, V&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入缓存机制"</span>);</span><br><span class="line">        V result = cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            result = c.compute(arg);</span><br><span class="line">            cache.put(arg, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ImoocCache2&lt;String, Integer&gt; expensiveComputer = <span class="keyword">new</span> ImoocCache2&lt;&gt;(</span><br><span class="line">                <span class="keyword">new</span> ExpensiveFunction());</span><br><span class="line">        Integer result = expensiveComputer.compute(<span class="string">"666"</span>);</span><br><span class="line">        System.out.println(<span class="string">"第一次计算结果："</span>+result);</span><br><span class="line">        result = expensiveComputer.compute(<span class="string">"13"</span>);</span><br><span class="line">        System.out.println(<span class="string">"第二次计算结果："</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不足</p>
<p>当多个线程同时想计算的时候，需要慢慢等待，严重的时候甚至比不用缓存性能更差</p>
<h2 id="性能待优化"><a href="#性能待优化" class="headerlink" title="性能待优化"></a>性能待优化</h2><p>引出锁性能优化经验，缩小锁的粒度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     缩小了synchronized的粒度，提高性能，但是依然并发不安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImoocCache4</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, V&gt; cache = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImoocCache4</span><span class="params">(Computable&lt;A, V&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入缓存机制"</span>);</span><br><span class="line">        V result = cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            result = c.compute(arg);</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                cache.put(arg, result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ImoocCache4&lt;String, Integer&gt; expensiveComputer = <span class="keyword">new</span> ImoocCache4&lt;&gt;(</span><br><span class="line">                <span class="keyword">new</span> ExpensiveFunction());</span><br><span class="line">        Integer result = expensiveComputer.compute(<span class="string">"666"</span>);</span><br><span class="line">        System.out.println(<span class="string">"第一次计算结果："</span> + result);</span><br><span class="line">        result = expensiveComputer.compute(<span class="string">"666"</span>);</span><br><span class="line">        System.out.println(<span class="string">"第二次计算结果："</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然提高并发效率，但是并不意味着线程安全，还需要考虑同时读写等情况</p>
<h2 id="使用ConcurrentHashMap"><a href="#使用ConcurrentHashMap" class="headerlink" title="使用ConcurrentHashMap"></a>使用ConcurrentHashMap</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImoocCache5</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, V&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImoocCache5</span><span class="params">(Computable&lt;A, V&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入缓存机制"</span>);</span><br><span class="line">        V result = cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            result = c.compute(arg);</span><br><span class="line">            cache.put(arg, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ImoocCache5&lt;String, Integer&gt; expensiveComputer = <span class="keyword">new</span> ImoocCache5&lt;&gt;(</span><br><span class="line">                <span class="keyword">new</span> ExpensiveFunction());</span><br><span class="line">        Integer result = expensiveComputer.compute(<span class="string">"666"</span>);</span><br><span class="line">        System.out.println(<span class="string">"第一次计算结果："</span> + result);</span><br><span class="line">        result = expensiveComputer.compute(<span class="string">"666"</span>);</span><br><span class="line">        System.out.println(<span class="string">"第二次计算结果："</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时也存在缺点</p>
<p>在计算完成前，另一个要求计算相同值的请求到来，会导致计算两遍，这和缓存想避免多次计算的初衷恰恰相反</p>
<p>如图</p>
<p><img src="/2020/03/06/4悟空Java并发编程/实战项目/image-20200227104708583.png" alt="image-20200227104708583"></p>
<h2 id="避免重复计算"><a href="#避免重复计算" class="headerlink" title="避免重复计算"></a>避免重复计算</h2><p>Future和Callable的使用</p>
<p>现在不同的线程进来之后，确实可以同时计算，但是如果两个线程相差无几的进来请求同一个数据，就会出现重复计算，若是更多的线程请求同样的内容，却都需要重新计算，则会造成更大的浪费</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     利用Future，避免重复计算</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImoocCache7</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, Future&lt;V&gt;&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImoocCache7</span><span class="params">(Computable&lt;A, V&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Future&lt;V&gt; f = cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Callable&lt;V&gt; callable = <span class="keyword">new</span> Callable&lt;V&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> c.compute(arg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            FutureTask&lt;V&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(callable);</span><br><span class="line">            f = ft;</span><br><span class="line">            cache.put(arg, ft);</span><br><span class="line">            System.out.println(<span class="string">"从FutureTask调用了计算函数"</span>);</span><br><span class="line">            ft.run();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ImoocCache7&lt;String, Integer&gt; expensiveComputer = <span class="keyword">new</span> ImoocCache7&lt;&gt;(</span><br><span class="line">                <span class="keyword">new</span> ExpensiveFunction());</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Integer result = expensiveComputer.compute(<span class="string">"666"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"第一次的计算结果："</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Integer result = expensiveComputer.compute(<span class="string">"666"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"第三次的计算结果："</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Integer result = expensiveComputer.compute(<span class="string">"667"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"第二次的计算结果："</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上方法依然存在重复计算的可能</p>
<p>如果有两个同时计算666的线程，同时调用cache.get()方法，那么返回的结果都为null，后面还是会创建两个任务去计算相同的值</p>
<p><img src="/2020/03/06/4悟空Java并发编程/实战项目/image-20200227110045352.png" alt="image-20200227110045352"></p>
<h2 id="计算抛出异常"><a href="#计算抛出异常" class="headerlink" title="计算抛出异常"></a>计算抛出异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     耗时计算的实现类，有概率计算失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MayFail</span> <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">compute</span><span class="params">(String arg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> random = Math.random();</span><br><span class="line">        <span class="keyword">if</span> (random &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"读取文件出错"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-4悟空Java并发编程/原子类" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/06/4悟空Java并发编程/原子类/" class="article-date">
      <time datetime="2020-03-06T09:41:28.613Z" itemprop="datePublished">2020-03-06</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/06/4悟空Java并发编程/原子类/">原子类</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <h1 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h1><h2 id="什么是原子类有什么作用"><a href="#什么是原子类有什么作用" class="headerlink" title="什么是原子类有什么作用"></a>什么是原子类有什么作用</h2><p>不可分割</p>
<p>一个操作是不可中断的，即使是多线程的情况也可以保证</p>
<p>java.util.concurrent.atomic</p>
<p>原子类的作用和锁类似，是为了保证并发情况下线程安全，不过原子类相比于锁，有一定的优势</p>
<p>原子类粒度更细，原子变量可以把竞争范围缩小到变量级别，这是用户可以获得的最细粒度的情况，通常所得粒度都要大于原子变量的粒度</p>
<p>原子类效率更高，通常使用原子类的效率会比使用锁的效率更高，除了高度竞争的情况</p>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java多线程/">Java多线程</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/2020/03/06/4悟空Java并发编程/原子类/#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-4悟空Java并发编程/ThreadLocal详解" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/06/4悟空Java并发编程/ThreadLocal详解/" class="article-date">
      <time datetime="2020-03-06T09:41:28.608Z" itemprop="datePublished">2020-03-06</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/06/4悟空Java并发编程/ThreadLocal详解/">ThreadLocal详解</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <h1 id="ThreadLocal详解"><a href="#ThreadLocal详解" class="headerlink" title="ThreadLocal详解"></a>ThreadLocal详解</h1><h2 id="两大使用场景"><a href="#两大使用场景" class="headerlink" title="两大使用场景"></a>两大使用场景</h2><h3 id="典型场景1"><a href="#典型场景1" class="headerlink" title="典型场景1"></a>典型场景1</h3><p>每个线程需要一个独享的对象的时候</p>
<p>即每个Thread类中有自己的实例副本，而各个线程之间的实例之间是不共享的，如同教材只有一本，一起做笔记就会有线程安全问题，使并发读写带来数据的不一致，而使用ThreadLocal相当于把书本复印多份，这样每个用户使用自己的教材，就不会出问题了。而每一本书（每一个实例）都是由当前的线程访问并使用，其他线程是无法访问，不是共用的，这样就解决了线程问题</p>
<p>通常是工具类，典型需要使用的类有SimpleDateFormat和Random，这两个类都是线程不安全的</p>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java多线程/">Java多线程</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/2020/03/06/4悟空Java并发编程/ThreadLocal详解/#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-4悟空Java并发编程/Java内存模型之底层原理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/06/4悟空Java并发编程/Java内存模型之底层原理/" class="article-date">
      <time datetime="2020-03-06T09:41:28.603Z" itemprop="datePublished">2020-03-06</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/06/4悟空Java并发编程/Java内存模型之底层原理/">Java内存模型之底层原理</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <h1 id="Java内存模型之底层原理"><a href="#Java内存模型之底层原理" class="headerlink" title="Java内存模型之底层原理"></a>Java内存模型之底层原理</h1><p><img src="/2020/03/06/4悟空Java并发编程/Java内存模型之底层原理/image-20200212215745899.png" alt="image-20200212215745899"></p>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java多线程/">Java多线程</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/2020/03/06/4悟空Java并发编程/Java内存模型之底层原理/#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2019-2020 爱吃鱼的呆先生
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>